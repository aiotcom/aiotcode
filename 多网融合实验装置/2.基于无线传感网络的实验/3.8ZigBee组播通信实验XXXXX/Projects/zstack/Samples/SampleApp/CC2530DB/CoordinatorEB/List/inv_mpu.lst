###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         27/Feb/2019  10:11:28 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Components\HARDWARE\MPU6050\eMPL\inv_mpu.c    #
#    Command line       =  -f D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\gr #
#                          oup-ext\Projects\zstack\Samples\SampleApp\CC2530DB #
#                          \..\..\..\Tools\CC2530DB\f8wCoord.cfg (-DCPU32MHZ  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\Tools\CC2530DB\f8wConfig.cfg (-DSECURE=0    #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFF11                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Components\HARDWARE\MPU6050\eMPL\inv_mpu.c    #
#                          -D ZIGBEEPRO -D ZTOOL_P1 -D MT_SYS_FUNC -D         #
#                          xMT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -D NV_RESTORE  #
#                          -lC D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\g #
#                          roup-ext\Projects\zstack\Samples\SampleApp\CC2530D #
#                          B\CoordinatorEB\List\ -lA                          #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\Co #
#                          ordinatorEB\List\ --diag_suppress Pe001,Pa010 -o   #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\Co #
#                          ordinatorEB\Obj\ -e --debug --core=plain           #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I D:\ZigBee\KJXY-ZigBee\usef #
#                          ul_code\ZigBee-Ext\group-ext\Projects\zstack\Sampl #
#                          es\SampleApp\CC2530DB\ -I                          #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \SOURCE\ -I D:\ZigBee\KJXY-ZigBee\useful_code\ZigB #
#                          ee-Ext\group-ext\Projects\zstack\Samples\SampleApp #
#                          \CC2530DB\..\..\..\ZMAIN\TI2530DB\ -I              #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\MT\ -I                     #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I            #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\ -I    #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\ -I         #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\OSAL\INCLUDE\ -I           #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\AF\ -I               #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\NWK\ -I              #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\SEC\ -I              #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\SAPI\ -I             #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\SYS\ -I              #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\STACK\ZDO\ -I              #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\ZMAC\F8W\ -I               #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\ZMAC\ -I                   #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\SERVICES\SADDR\ -I         #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\SERVICES\SDATA\ -I         #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\MAC\INCLUDE\ -I            #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\ -I         #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\ -I    #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE #
#                          _CHIP\ -I D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee #
#                          -Ext\group-ext\Projects\zstack\Samples\SampleApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\HARDWARE\ -I     #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\HARDWARE\MPU6050\ -I       #
#                          D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\HARDWARE\MPU6050\eMPL\     #
#                          -Ohz                                               #
#    List file          =  D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\Co #
#                          ordinatorEB\List\inv_mpu.lst                       #
#    Object file        =  D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group #
#                          -ext\Projects\zstack\Samples\SampleApp\CC2530DB\Co #
#                          ordinatorEB\Obj\inv_mpu.r51                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\ZigBee\KJXY-ZigBee\useful_code\ZigBee-Ext\group-ext\Components\HARDWARE\MPU6050\eMPL\inv_mpu.c
      1          /*
      2           $License:
      3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
      4              See included License.txt for License information.
      5           $
      6           */
      7          /**
      8           *  @addtogroup  DRIVERS Sensor Driver Layer
      9           *  @brief       Hardware drivers to communicate with sensors via I2C.
     10           *
     11           *  @{
     12           *      @file       inv_mpu.c
     13           *      @brief      An I2C-based driver for Invensense gyroscopes.
     14           *      @details    This driver currently works for the following devices:
     15           *                  MPU6050
     16           *                  MPU6500
     17           *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
     18           *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
     19           */
     20          #include <stdio.h>
     21          //#include <stdint.h>
     22          #include <stdlib.h>
     23          #include <string.h>
     24          #include <math.h>
     25          #include "inv_mpu.h"
     26          #include "inv_mpu_dmp_motion_driver.h"
     27          #include "mpu6050.h"
     28          #include "delay.h"
     29          
     30          #define MPU6050					//定义我们使用的传感器为MPU6050
     31          #define MOTION_DRIVER_TARGET_MSP430		//定义驱动部分,采用MSP430的驱动(移植到STM32F1)
     32          
     33          /* The following functions must be defined for this platform:
     34           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
     35           *      unsigned char length, unsigned char const *data)
     36           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
     37           *      unsigned char length, unsigned char *data)
     38           * delay_ms(unsigned long num_ms)
     39           * get_ms(unsigned long *count)
     40           * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
     41           * labs(long x)
     42           * fabsf(float x)
     43           * min(int a, int b)
     44           */
     45          #if defined MOTION_DRIVER_TARGET_MSP430
     46          //#include "msp430.h"
     47          //#include "msp430_i2c.h"
     48          //#include "msp430_clock.h"
     49          //#include "msp430_interrupt.h"
     50          
     51          #define i2c_write   MPU_Write_Len
     52          #define i2c_read    MPU_Read_Len
     53          #define delay_ms    delay_ms
     54          #define get_ms      mget_ms
     55          //static inline int reg_int_cb(struct int_param_s *int_param)
     56          //{
     57          //    return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
     58          //        int_param->active_low);
     59          //}
     60          #define log_i 	printf	//打印信息
     61          #define log_e  	printf	//打印信息
     62          /* labs is already defined by TI's toolchain. */
     63          /* fabs is for doubles. fabsf is for floats. */
     64          //#define fabs  fabsf
     65          #define min(a,b) ((a<b)?a:b)
     66          #elif defined EMPL_TARGET_MSP430
     67          #include "msp430.h"
     68          #include "msp430_i2c.h"
     69          #include "msp430_clock.h"
     70          #include "msp430_interrupt.h"
     71          #include "log.h"
     72          #define i2c_write   msp430_i2c_write
     73          #define i2c_read    msp430_i2c_read
     74          #define delay_ms    msp430_delay_ms
     75          #define get_ms      msp430_get_clock_ms
     76          static inline int reg_int_cb(struct int_param_s *int_param)
     77          {
     78              return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
     79                  int_param->active_low);
     80          }
     81          #define log_i       MPL_LOGI
     82          #define log_e       MPL_LOGE
     83          /* labs is already defined by TI's toolchain. */
     84          /* fabs is for doubles. fabsf is for floats. */
     85          #define fabs   fabsf
     86          #define min(a,b) ((a<b)?a:b)
     87          #elif defined EMPL_TARGET_UC3L0
     88          /* Instead of using the standard TWI driver from the ASF library, we're using
     89           * a TWI driver that follows the slave address + register address convention.
     90           */
     91          #include "twi.h"
     92          #include "delay.h"
     93          #include "sysclk.h"
     94          #include "log.h"
     95          #include "sensors_xplained.h"
     96          #include "uc3l0_clock.h"
     97          #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
     98          #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
     99          /* delay_ms is a function already defined in ASF. */
    100          #define get_ms  uc3l0_get_clock_ms
    101          static inline int reg_int_cb(struct int_param_s *int_param)
    102          {
    103              sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
    104              return 0;
    105          }
    106          #define log_i       MPL_LOGI
    107          #define log_e       MPL_LOGE
    108          /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
    109          #define labs        abs
    110          #define fabs(x)     (((x)>0)?(x):-(x))
    111          #else
    112          #error  Gyro driver is missing the system layer implementations.
    113          #endif
    114          
    115          #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
    116          #error  Which gyro are you using? Define MPUxxxx in your compiler options.
    117          #endif
    118          
    119          /* Time for some messy macro work. =]
    120           * #define MPU9150
    121           * is equivalent to..
    122           * #define MPU6050
    123           * #define AK8975_SECONDARY
    124           *
    125           * #define MPU9250
    126           * is equivalent to..
    127           * #define MPU6500
    128           * #define AK8963_SECONDARY
    129           */
    130          #if defined MPU9150
    131          #ifndef MPU6050
    132          #define MPU6050
    133          #endif                          /* #ifndef MPU6050 */
    134          #if defined AK8963_SECONDARY
    135          #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
    136          #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
    137          #define AK8975_SECONDARY
    138          #endif                          /* #if defined AK8963_SECONDARY */
    139          #elif defined MPU9250           /* #if defined MPU9150 */
    140          #ifndef MPU6500
    141          #define MPU6500
    142          #endif                          /* #ifndef MPU6500 */
    143          #if defined AK8975_SECONDARY
    144          #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
    145          #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
    146          #define AK8963_SECONDARY
    147          #endif                          /* #if defined AK8975_SECONDARY */
    148          #endif                          /* #if defined MPU9150 */
    149          
    150          #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
    151          #define AK89xx_SECONDARY
    152          #else
    153          /* #warning "No compass = less profit for Invensense. Lame." */
    154          #endif
    155          
    156          static int set_int_enable(unsigned char enable);
    157          
    158          /* Hardware registers needed by driver. */
    159          struct gyro_reg_s {
    160              unsigned char who_am_i;
    161              unsigned char rate_div;
    162              unsigned char lpf;
    163              unsigned char prod_id;
    164              unsigned char user_ctrl;
    165              unsigned char fifo_en;
    166              unsigned char gyro_cfg;
    167              unsigned char accel_cfg;
    168          //    unsigned char accel_cfg2;
    169          //    unsigned char lp_accel_odr;
    170              unsigned char motion_thr;
    171              unsigned char motion_dur;
    172              unsigned char fifo_count_h;
    173              unsigned char fifo_r_w;
    174              unsigned char raw_gyro;
    175              unsigned char raw_accel;
    176              unsigned char temp;
    177              unsigned char int_enable;
    178              unsigned char dmp_int_status;
    179              unsigned char int_status;
    180          //    unsigned char accel_intel;
    181              unsigned char pwr_mgmt_1;
    182              unsigned char pwr_mgmt_2;
    183              unsigned char int_pin_cfg;
    184              unsigned char mem_r_w;
    185              unsigned char accel_offs;
    186              unsigned char i2c_mst;
    187              unsigned char bank_sel;
    188              unsigned char mem_start_addr;
    189              unsigned char prgm_start_h;
    190          #if defined AK89xx_SECONDARY
    191              unsigned char s0_addr;
    192              unsigned char s0_reg;
    193              unsigned char s0_ctrl;
    194              unsigned char s1_addr;
    195              unsigned char s1_reg;
    196              unsigned char s1_ctrl;
    197              unsigned char s4_ctrl;
    198              unsigned char s0_do;
    199              unsigned char s1_do;
    200              unsigned char i2c_delay_ctrl;
    201              unsigned char raw_compass;
    202              /* The I2C_MST_VDDIO bit is in this register. */
    203              unsigned char yg_offs_tc;
    204          #endif
    205          };
    206          
    207          /* Information specific to a particular device. */
    208          struct hw_s {
    209              unsigned char addr;
    210              unsigned short max_fifo;
    211              unsigned char num_reg;
    212              unsigned short temp_sens;
    213              short temp_offset;
    214              unsigned short bank_size;
    215          #if defined AK89xx_SECONDARY
    216              unsigned short compass_fsr;
    217          #endif
    218          };
    219          
    220          /* When entering motion interrupt mode, the driver keeps track of the
    221           * previous state so that it can be restored at a later time.
    222           * TODO: This is tacky. Fix it.
    223           */
    224          struct motion_int_cache_s {
    225              unsigned short gyro_fsr;
    226              unsigned char accel_fsr;
    227              unsigned short lpf;
    228              unsigned short sample_rate;
    229              unsigned char sensors_on;
    230              unsigned char fifo_sensors;
    231              unsigned char dmp_on;
    232          };
    233          
    234          /* Cached chip configuration data.
    235           * TODO: A lot of these can be handled with a bitmask.
    236           */
    237          struct chip_cfg_s {
    238              /* Matches gyro_cfg >> 3 & 0x03 */
    239              unsigned char gyro_fsr;
    240              /* Matches accel_cfg >> 3 & 0x03 */
    241              unsigned char accel_fsr;
    242              /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
    243              unsigned char sensors;
    244              /* Matches config register. */
    245              unsigned char lpf;
    246              unsigned char clk_src;
    247              /* Sample rate, NOT rate divider. */
    248              unsigned short sample_rate;
    249              /* Matches fifo_en register. */
    250              unsigned char fifo_enable;
    251              /* Matches int enable register. */
    252              unsigned char int_enable;
    253              /* 1 if devices on auxiliary I2C bus appear on the primary. */
    254              unsigned char bypass_mode;
    255              /* 1 if half-sensitivity.
    256               * NOTE: This doesn't belong here, but everything else in hw_s is const,
    257               * and this allows us to save some precious RAM.
    258               */
    259              unsigned char accel_half;
    260              /* 1 if device in low-power accel-only mode. */
    261              unsigned char lp_accel_mode;
    262              /* 1 if interrupts are only triggered on motion events. */
    263              unsigned char int_motion_only;
    264              struct motion_int_cache_s cache;
    265              /* 1 for active low interrupts. */
    266              unsigned char active_low_int;
    267              /* 1 for latched interrupts. */
    268              unsigned char latched_int;
    269              /* 1 if DMP is enabled. */
    270              unsigned char dmp_on;
    271              /* Ensures that DMP will only be loaded once. */
    272              unsigned char dmp_loaded;
    273              /* Sampling rate used when DMP is enabled. */
    274              unsigned short dmp_sample_rate;
    275          #ifdef AK89xx_SECONDARY
    276              /* Compass sample rate. */
    277              unsigned short compass_sample_rate;
    278              unsigned char compass_addr;
    279              short mag_sens_adj[3];
    280          #endif
    281          };
    282          
    283          /* Information for self-test. */
    284          struct test_s {
    285              unsigned long gyro_sens;
    286              unsigned long accel_sens;
    287              unsigned char reg_rate_div;
    288              unsigned char reg_lpf;
    289              unsigned char reg_gyro_fsr;
    290              unsigned char reg_accel_fsr;
    291              unsigned short wait_ms;
    292              unsigned char packet_thresh;
    293              float min_dps;
    294              float max_dps;
    295              float max_gyro_var;
    296              float min_g;
    297              float max_g;
    298              float max_accel_var;
    299          };
    300          
    301          /* Gyro driver state variables. */
    302          struct gyro_state_s {
    303              const struct gyro_reg_s *reg;
    304              const struct hw_s *hw;
    305              struct chip_cfg_s chip_cfg;
    306              const struct test_s *test;
    307          };
    308          
    309          /* Filter configurations. */
    310          enum lpf_e {
    311              INV_FILTER_256HZ_NOLPF2 = 0,
    312              INV_FILTER_188HZ,
    313              INV_FILTER_98HZ,
    314              INV_FILTER_42HZ,
    315              INV_FILTER_20HZ,
    316              INV_FILTER_10HZ,
    317              INV_FILTER_5HZ,
    318              INV_FILTER_2100HZ_NOLPF,
    319              NUM_FILTER
    320          };
    321          
    322          /* Full scale ranges. */
    323          enum gyro_fsr_e {
    324              INV_FSR_250DPS = 0,
    325              INV_FSR_500DPS,
    326              INV_FSR_1000DPS,
    327              INV_FSR_2000DPS,
    328              NUM_GYRO_FSR
    329          };
    330          
    331          /* Full scale ranges. */
    332          enum accel_fsr_e {
    333              INV_FSR_2G = 0,
    334              INV_FSR_4G,
    335              INV_FSR_8G,
    336              INV_FSR_16G,
    337              NUM_ACCEL_FSR
    338          };
    339          
    340          /* Clock sources. */
    341          enum clock_sel_e {
    342              INV_CLK_INTERNAL = 0,
    343              INV_CLK_PLL,
    344              NUM_CLK
    345          };
    346          
    347          /* Low-power accel wakeup rates. */
    348          enum lp_accel_rate_e {
    349          #if defined MPU6050
    350              INV_LPA_1_25HZ,
    351              INV_LPA_5HZ,
    352              INV_LPA_20HZ,
    353              INV_LPA_40HZ
    354          #elif defined MPU6500
    355              INV_LPA_0_3125HZ,
    356              INV_LPA_0_625HZ,
    357              INV_LPA_1_25HZ,
    358              INV_LPA_2_5HZ,
    359              INV_LPA_5HZ,
    360              INV_LPA_10HZ,
    361              INV_LPA_20HZ,
    362              INV_LPA_40HZ,
    363              INV_LPA_80HZ,
    364              INV_LPA_160HZ,
    365              INV_LPA_320HZ,
    366              INV_LPA_640HZ
    367          #endif
    368          };
    369          
    370          #define BIT_I2C_MST_VDDIO   (0x80)
    371          #define BIT_FIFO_EN         (0x40)
    372          #define BIT_DMP_EN          (0x80)
    373          #define BIT_FIFO_RST        (0x04)
    374          #define BIT_DMP_RST         (0x08)
    375          #define BIT_FIFO_OVERFLOW   (0x10)
    376          #define BIT_DATA_RDY_EN     (0x01)
    377          #define BIT_DMP_INT_EN      (0x02)
    378          #define BIT_MOT_INT_EN      (0x40)
    379          #define BITS_FSR            (0x18)
    380          #define BITS_LPF            (0x07)
    381          #define BITS_HPF            (0x07)
    382          #define BITS_CLK            (0x07)
    383          #define BIT_FIFO_SIZE_1024  (0x40)
    384          #define BIT_FIFO_SIZE_2048  (0x80)
    385          #define BIT_FIFO_SIZE_4096  (0xC0)
    386          #define BIT_RESET           (0x80)
    387          #define BIT_SLEEP           (0x40)
    388          #define BIT_S0_DELAY_EN     (0x01)
    389          #define BIT_S2_DELAY_EN     (0x04)
    390          #define BITS_SLAVE_LENGTH   (0x0F)
    391          #define BIT_SLAVE_BYTE_SW   (0x40)
    392          #define BIT_SLAVE_GROUP     (0x10)
    393          #define BIT_SLAVE_EN        (0x80)
    394          #define BIT_I2C_READ        (0x80)
    395          #define BITS_I2C_MASTER_DLY (0x1F)
    396          #define BIT_AUX_IF_EN       (0x20)
    397          #define BIT_ACTL            (0x80)
    398          #define BIT_LATCH_EN        (0x20)
    399          #define BIT_ANY_RD_CLR      (0x10)
    400          #define BIT_BYPASS_EN       (0x02)
    401          #define BITS_WOM_EN         (0xC0)
    402          #define BIT_LPA_CYCLE       (0x20)
    403          #define BIT_STBY_XA         (0x20)
    404          #define BIT_STBY_YA         (0x10)
    405          #define BIT_STBY_ZA         (0x08)
    406          #define BIT_STBY_XG         (0x04)
    407          #define BIT_STBY_YG         (0x02)
    408          #define BIT_STBY_ZG         (0x01)
    409          #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
    410          #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
    411          
    412          #if defined AK8975_SECONDARY
    413          #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
    414          #define AK89xx_FSR                  (9830)
    415          #elif defined AK8963_SECONDARY
    416          #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
    417          #define AK89xx_FSR                  (4915)
    418          #endif
    419          
    420          #ifdef AK89xx_SECONDARY
    421          #define AKM_REG_WHOAMI      (0x00)
    422          
    423          #define AKM_REG_ST1         (0x02)
    424          #define AKM_REG_HXL         (0x03)
    425          #define AKM_REG_ST2         (0x09)
    426          
    427          #define AKM_REG_CNTL        (0x0A)
    428          #define AKM_REG_ASTC        (0x0C)
    429          #define AKM_REG_ASAX        (0x10)
    430          #define AKM_REG_ASAY        (0x11)
    431          #define AKM_REG_ASAZ        (0x12)
    432          
    433          #define AKM_DATA_READY      (0x01)
    434          #define AKM_DATA_OVERRUN    (0x02)
    435          #define AKM_OVERFLOW        (0x80)
    436          #define AKM_DATA_ERROR      (0x40)
    437          
    438          #define AKM_BIT_SELF_TEST   (0x40)
    439          
    440          #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
    441          #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
    442          #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
    443          #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
    444          
    445          #define AKM_WHOAMI      (0x48)
    446          #endif
    447          
    448          #if defined MPU6050
    449          //const struct gyro_reg_s reg = {
    450          //    .who_am_i       = 0x75,
    451          //    .rate_div       = 0x19,
    452          //    .lpf            = 0x1A,
    453          //    .prod_id        = 0x0C,
    454          //    .user_ctrl      = 0x6A,
    455          //    .fifo_en        = 0x23,
    456          //    .gyro_cfg       = 0x1B,
    457          //    .accel_cfg      = 0x1C,
    458          //    .motion_thr     = 0x1F,
    459          //    .motion_dur     = 0x20,
    460          //    .fifo_count_h   = 0x72,
    461          //    .fifo_r_w       = 0x74,
    462          //    .raw_gyro       = 0x43,
    463          //    .raw_accel      = 0x3B,
    464          //    .temp           = 0x41,
    465          //    .int_enable     = 0x38,
    466          //    .dmp_int_status = 0x39,
    467          //    .int_status     = 0x3A,
    468          //    .pwr_mgmt_1     = 0x6B,
    469          //    .pwr_mgmt_2     = 0x6C,
    470          //    .int_pin_cfg    = 0x37,
    471          //    .mem_r_w        = 0x6F,
    472          //    .accel_offs     = 0x06,
    473          //    .i2c_mst        = 0x24,
    474          //    .bank_sel       = 0x6D,
    475          //    .mem_start_addr = 0x6E,
    476          //    .prgm_start_h   = 0x70
    477          //#ifdef AK89xx_SECONDARY
    478          //    ,.raw_compass   = 0x49,
    479          //    .yg_offs_tc     = 0x01,
    480          //    .s0_addr        = 0x25,
    481          //    .s0_reg         = 0x26,
    482          //    .s0_ctrl        = 0x27,
    483          //    .s1_addr        = 0x28,
    484          //    .s1_reg         = 0x29,
    485          //    .s1_ctrl        = 0x2A,
    486          //    .s4_ctrl        = 0x34,
    487          //    .s0_do          = 0x63,
    488          //    .s1_do          = 0x64,
    489          //    .i2c_delay_ctrl = 0x67
    490          //#endif
    491          //};

   \                                 In  segment XDATA_ROM_C, align 1
    492          const struct gyro_reg_s reg = {
   \                     reg:
   \   000000   75           DB 117
   \   000001   19           DB 25
   \   000002   1A           DB 26
   \   000003   0C           DB 12
   \   000004   6A           DB 106
   \   000005   23           DB 35
   \   000006   1B           DB 27
   \   000007   1C           DB 28
   \   000008   1F           DB 31
   \   000009   20           DB 32
   \   00000A   72           DB 114
   \   00000B   74           DB 116
   \   00000C   43           DB 67
   \   00000D   3B           DB 59
   \   00000E   41           DB 65
   \   00000F   38           DB 56
   \   000010   39           DB 57
   \   000011   3A           DB 58
   \   000012   6B           DB 107
   \   000013   6C           DB 108
   \   000014   37           DB 55
   \   000015   6F           DB 111
   \   000016   06           DB 6
   \   000017   24           DB 36
   \   000018   6D           DB 109
   \   000019   6E           DB 110
   \   00001A   70           DB 112
    493          0x75,  //who_am_i
    494          0x19,  //rate_div
    495          0x1A,  //lpf
    496          0x0C,  //prod_id
    497          0x6A,  //user_ctrl
    498          0x23,  //fifo_en
    499          0x1B,  //gyro_cfg
    500          0x1C,  //accel_cfg
    501          0x1F,  // motion_thr
    502          0x20,  // motion_dur
    503          0x72,  // fifo_count_h
    504          0x74,  // fifo_r_w
    505          0x43,  // raw_gyro
    506          0x3B,  // raw_accel
    507          0x41,  // temp
    508          0x38,  // int_enable
    509          0x39,  //  dmp_int_status
    510          0x3A,  //  int_status
    511          0x6B,  // pwr_mgmt_1
    512          0x6C,  // pwr_mgmt_2
    513          0x37,  // int_pin_cfg
    514          0x6F,  // mem_r_w
    515          0x06,  // accel_offs
    516          0x24,  // i2c_mst
    517          0x6D,  // bank_sel
    518          0x6E,  // mem_start_addr
    519          0x70   // prgm_start_h
    520          };
    521          
    522          //const struct hw_s hw = {
    523          //    .addr           = 0x68,
    524          //    .max_fifo       = 1024,
    525          //    .num_reg        = 118,
    526          //    .temp_sens      = 340,
    527          //    .temp_offset    = -521,
    528          //    .bank_size      = 256
    529          //#if defined AK89xx_SECONDARY
    530          //    ,.compass_fsr    = AK89xx_FSR
    531          //#endif
    532          //};

   \                                 In  segment XDATA_ROM_C, align 1
    533          const struct hw_s hw={
   \                     hw:
   \   000000   68           DB 104
   \   000001   0004         DW 1024
   \   000003   76           DB 118
   \   000004   5401         DW 340
   \   000006   F7FD         DW -521
   \   000008   0001         DW 256
    534            0x68,	 //addr
    535            1024,	 //max_fifo
    536            118,	 //num_reg
    537            340,	 //temp_sens
    538            -521,	 //temp_offset
    539            256	 //bank_size
    540          };
    541          
    542          //const struct test_s test = {
    543          //    .gyro_sens      = 32768/250,
    544          //    .accel_sens     = 32768/16,
    545          //    .reg_rate_div   = 0,    /* 1kHz. */
    546          //    .reg_lpf        = 1,    /* 188Hz. */
    547          //    .reg_gyro_fsr   = 0,    /* 250dps. */
    548          //    .reg_accel_fsr  = 0x18, /* 16g. */
    549          //    .wait_ms        = 50,
    550          //    .packet_thresh  = 5,    /* 5% */
    551          //    .min_dps        = 10.f,
    552          //    .max_dps        = 105.f,
    553          //    .max_gyro_var   = 0.14f,
    554          //    .min_g          = 0.3f,
    555          //    .max_g          = 0.95f,
    556          //    .max_accel_var  = 0.14f
    557          //};

   \                                 In  segment XDATA_ROM_C, align 1
    558          const struct test_s test={
   \                     test:
   \   000000   83000000     DD 131
   \   000004   00080000     DD 2048
   \   000008   00           DB 0
   \   000009   01           DB 1
   \   00000A   00           DB 0
   \   00000B   18           DB 24
   \   00000C   3200         DW 50
   \   00000E   05           DB 5
   \   00000F   00002041     DD 41200000H
   \   000013   0000D242     DD 42D20000H
   \   000017   295C0F3E     DD 3E0F5C29H
   \   00001B   9A99993E     DD 3E99999AH
   \   00001F   3333733F     DD 3F733333H
   \   000023   295C0F3E     DD 3E0F5C29H
    559          32768/250,		 //gyro_sens
    560          32768/16,		 //	accel_sens
    561          0,				 //	reg_rate_div
    562          1,				//	reg_lpf
    563          0,				 //	reg_gyro_fsr
    564          0x18,			//	reg_accel_fsr
    565          50,				//	wait_ms
    566          5,				//	packet_thresh
    567          10.0f,			 //	min_dps
    568          105.0f,			 //	max_dps
    569          0.14f,			//	max_gyro_var
    570          0.3f,		   //	min_g
    571          0.95f,		   //	max_g
    572          0.14f		   //	max_accel_var
    573          };
    574          
    575          //static struct gyro_state_s st = {
    576          //    .reg = &reg,
    577          //    .hw = &hw,
    578          //    .test = &test
    579          //};

   \                                 In  segment XDATA_I, align 1, keep-with-next
    580          static struct gyro_state_s st={
   \                     st:
   \   000000                DS 35
   \   000023                REQUIRE `?<Initializer for st>`
   \   000023                REQUIRE __INIT_XDATA_I
    581            &reg,
    582            &hw,
    583            {0},
    584            &test
    585          };
    586          
    587          
    588          #elif defined MPU6500
    589          const struct gyro_reg_s reg = {
    590              .who_am_i       = 0x75,
    591              .rate_div       = 0x19,
    592              .lpf            = 0x1A,
    593              .prod_id        = 0x0C,
    594              .user_ctrl      = 0x6A,
    595              .fifo_en        = 0x23,
    596              .gyro_cfg       = 0x1B,
    597              .accel_cfg      = 0x1C,
    598              .accel_cfg2     = 0x1D,
    599              .lp_accel_odr   = 0x1E,
    600              .motion_thr     = 0x1F,
    601              .motion_dur     = 0x20,
    602              .fifo_count_h   = 0x72,
    603              .fifo_r_w       = 0x74,
    604              .raw_gyro       = 0x43,
    605              .raw_accel      = 0x3B,
    606              .temp           = 0x41,
    607              .int_enable     = 0x38,
    608              .dmp_int_status = 0x39,
    609              .int_status     = 0x3A,
    610              .accel_intel    = 0x69,
    611              .pwr_mgmt_1     = 0x6B,
    612              .pwr_mgmt_2     = 0x6C,
    613              .int_pin_cfg    = 0x37,
    614              .mem_r_w        = 0x6F,
    615              .accel_offs     = 0x77,
    616              .i2c_mst        = 0x24,
    617              .bank_sel       = 0x6D,
    618              .mem_start_addr = 0x6E,
    619              .prgm_start_h   = 0x70
    620          #ifdef AK89xx_SECONDARY
    621              ,.raw_compass   = 0x49,
    622              .s0_addr        = 0x25,
    623              .s0_reg         = 0x26,
    624              .s0_ctrl        = 0x27,
    625              .s1_addr        = 0x28,
    626              .s1_reg         = 0x29,
    627              .s1_ctrl        = 0x2A,
    628              .s4_ctrl        = 0x34,
    629              .s0_do          = 0x63,
    630              .s1_do          = 0x64,
    631              .i2c_delay_ctrl = 0x67
    632          #endif
    633          };
    634          const struct hw_s hw = {
    635              .addr           = 0x68,
    636              .max_fifo       = 1024,
    637              .num_reg        = 128,
    638              .temp_sens      = 321,
    639              .temp_offset    = 0,
    640              .bank_size      = 256
    641          #if defined AK89xx_SECONDARY
    642              ,.compass_fsr    = AK89xx_FSR
    643          #endif
    644          };
    645          
    646          const struct test_s test = {
    647              .gyro_sens      = 32768/250,
    648              .accel_sens     = 32768/16,
    649              .reg_rate_div   = 0,    /* 1kHz. */
    650              .reg_lpf        = 1,    /* 188Hz. */
    651              .reg_gyro_fsr   = 0,    /* 250dps. */
    652              .reg_accel_fsr  = 0x18, /* 16g. */
    653              .wait_ms        = 50,
    654              .packet_thresh  = 5,    /* 5% */
    655              .min_dps        = 10.f,
    656              .max_dps        = 105.f,
    657              .max_gyro_var   = 0.14f,
    658              .min_g          = 0.3f,
    659              .max_g          = 0.95f,
    660              .max_accel_var  = 0.14f
    661          };
    662          
    663          static struct gyro_state_s st = {
    664              .reg = &reg,
    665              .hw = &hw,
    666              .test = &test
    667          };
    668          #endif
    669          
    670          #define MAX_PACKET_LENGTH (12)
    671          
    672          #ifdef AK89xx_SECONDARY
    673          static int setup_compass(void);
    674          #define MAX_COMPASS_SAMPLE_RATE (100)
    675          #endif
    676          
    677          /**
    678           *  @brief      Enable/disable data ready interrupt.
    679           *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
    680           *  interrupt is used.
    681           *  @param[in]  enable      1 to enable interrupt.
    682           *  @return     0 if successful.
    683           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    684          static int set_int_enable(unsigned char enable)
   \                     set_int_enable:
    685          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    686              unsigned char tmp;
    687          
    688              if (st.chip_cfg.dmp_on) {
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   601D         JZ      ??set_int_enable_0
    689                  if (enable)
   \   000012   EE           MOV     A,R6
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   6004         JZ      ??set_int_enable_1
    690                      tmp = BIT_DMP_INT_EN;
   \   00001B   7402         MOV     A,#0x2
   \   00001D   8001         SJMP    ??set_int_enable_2
    691                  else
    692                      tmp = 0x00;
   \                     ??set_int_enable_1:
   \   00001F   E4           CLR     A
   \                     ??set_int_enable_2:
   \   000020   12....       LCALL   ??Subroutine136_0 & 0xFFFF
    693                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
   \                     ??CrossCallReturnLabel_258:
   \   000023   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000026   6035         JZ      ??set_int_enable_3
    694                      return -1;
   \                     ??set_int_enable_4:
   \   000028   7AFF         MOV     R2,#-0x1
   \   00002A   7BFF         MOV     R3,#-0x1
   \                     ??set_int_enable_5:
   \   00002C   02....       LJMP    ?Subroutine0 & 0xFFFF
    695                  st.chip_cfg.int_enable = tmp;
    696              } else {
    697                  if (!st.chip_cfg.sensors)
   \                     ??set_int_enable_0:
   \   00002F   90....       MOV     DPTR,#st + 6
   \   000032   E0           MOVX    A,@DPTR
   \   000033   60F3         JZ      ??set_int_enable_4
    698                      return -1;
    699                  if (enable && st.chip_cfg.int_enable)
   \   000035   EE           MOV     A,R6
   \   000036   6016         JZ      ??set_int_enable_6
   \   000038   90....       MOV     DPTR,#st + 12
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6006         JZ      ??set_int_enable_7
    700                      return 0;
   \                     ??set_int_enable_8:
   \   00003E   7A00         MOV     R2,#0x0
   \   000040   7B00         MOV     R3,#0x0
   \   000042   80E8         SJMP    ??set_int_enable_5
    701                  if (enable)
    702                      tmp = BIT_DATA_RDY_EN;
   \                     ??set_int_enable_7:
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   7401         MOV     A,#0x1
   \   00004C   8007         SJMP    ??set_int_enable_9
    703                  else
    704                      tmp = 0x00;
   \                     ??set_int_enable_6:
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   E4           CLR     A
    705                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
    706                      return -1;
    707                  st.chip_cfg.int_enable = tmp;
    708              }
   \                     ??set_int_enable_9:
   \   000055   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000058   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   00005B   70CB         JNZ     ??set_int_enable_4
   \                     ??set_int_enable_3:
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   90....       MOV     DPTR,#st + 12
   \   000067   F0           MOVX    @DPTR,A
   \   000068   80D4         SJMP    ??set_int_enable_8
    709              return 0;
    710          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7401         MOV     A,#0x1
   \   000002                REQUIRE ??Subroutine105_0
   \   000002                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine106_0
   \   000003                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001   AC82         MOV     R4,DPL
   \   000003   AD83         MOV     R5,DPH
   \   000005   7B01         MOV     R3,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   240F         ADD     A,#0xf
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003   90....       MOV     DPTR,#st
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine140_0:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000003                REQUIRE ??Subroutine141_0
   \   000003                ; // Fall through to label ??Subroutine141_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine141_0:
   \   000000   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000003   12....       LCALL   ??MPU_Write_Len?relay
   \   000006   E9           MOV     A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F9           MOV     R1,A
   \   000006   8882         MOV     DPL,R0
   \   000008   8983         MOV     DPH,R1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   90....       MOV     DPTR,#st + 2
   \   000005   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F9           MOV     R1,A
   \   00000A   22           RET
    711          
    712          /**
    713           *  @brief      Register dump for testing.
    714           *  @return     0 if successful.
    715           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    716          int mpu_reg_dump(void)
   \                     mpu_reg_dump:
    717          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    718              unsigned char ii;
    719              unsigned char data;
    720          
    721              for (ii = 0; ii < st.hw->num_reg; ii++) {
   \   00000A   7E00         MOV     R6,#0x0
   \   00000C   8025         SJMP    ??mpu_reg_dump_0
    722                  if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
    723                      continue;
    724                  if (i2c_read(st.hw->addr, ii, 1, &data))
    725                      return -1;
    726                  log_i("%#5x: %#5x\r\n", ii, data);
   \                     ??mpu_reg_dump_1:
   \   00000E                ; Setup parameters for call to function printf
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 0,A
   \   000017   75..00       MOV     ?V0 + 1,#0x0
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F   8E..         MOV     ?V0 + 0,R6
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   7A..         MOV     R2,#`?<Constant "%#5x: %#5x\\r\\n">` & 0xff
   \   000028   7B..         MOV     R3,#(`?<Constant "%#5x: %#5x\\r\\n">` >> 8) & 0xff
   \   00002A   12....       LCALL   ??printf?relay
   \   00002D   7404         MOV     A,#0x4
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??mpu_reg_dump_2:
   \   000032   0E           INC     R6
   \                     ??mpu_reg_dump_0:
   \   000033   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000036   502E         JNC     ??mpu_reg_dump_3
   \   000038   90....       MOV     DPTR,#st
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   240B         ADD     A,#0xb
   \   00003E   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000041   60EF         JZ      ??mpu_reg_dump_2
   \   000043   90....       MOV     DPTR,#st
   \   000046   E0           MOVX    A,@DPTR
   \   000047   2415         ADD     A,#0x15
   \   000049   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00004C   60E4         JZ      ??mpu_reg_dump_2
   \   00004E                ; Setup parameters for call to function MPU_Read_Len
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   AC82         MOV     R4,DPL
   \   000056   AD83         MOV     R5,DPH
   \   000058   7B01         MOV     R3,#0x1
   \   00005A   EE           MOV     A,R6
   \   00005B   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   00005E   60AE         JZ      ??mpu_reg_dump_1
   \   000060   7AFF         MOV     R2,#-0x1
   \   000062   7BFF         MOV     R3,#-0x1
   \   000064   8004         SJMP    ??mpu_reg_dump_4
    727              }
    728              return 0;
   \                     ??mpu_reg_dump_3:
   \   000066   7A00         MOV     R2,#0x0
   \   000068   7B00         MOV     R3,#0x0
   \                     ??mpu_reg_dump_4:
   \   00006A   02....       LJMP    ?Subroutine1 & 0xFFFF
    729          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   FB           MOV     R3,A
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   6E           XRL     A,R6
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   EE           MOV     A,R6
   \   000006   C3           CLR     C
   \   000007   9A           SUBB    A,R2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7401         MOV     A,#0x1
   \   000002                REQUIRE ??Subroutine103_0
   \   000002                ; // Fall through to label ??Subroutine103_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine104_0
   \   000003                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   FA           MOV     R2,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005                REQUIRE ??Subroutine117_0
   \   000005                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??MPU_Read_Len?relay
   \   000005   E9           MOV     A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   8882         MOV     DPL,R0
   \   00000A   8983         MOV     DPH,R1
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET
    730          
    731          /**
    732           *  @brief      Read from a single register.
    733           *  NOTE: The memory and FIFO read/write registers cannot be accessed.
    734           *  @param[in]  reg     Register address.
    735           *  @param[out] data    Register data.
    736           *  @return     0 if successful.
    737           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    738          int mpu_read_reg(unsigned char reg, unsigned char *data)
   \                     mpu_read_reg:
    739          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
    740              if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
   \   00000B   90....       MOV     DPTR,#st
   \   00000E   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000011   6E           XRL     A,R6
   \   000012   600C         JZ      ??mpu_read_reg_0
   \   000014   90....       MOV     DPTR,#st
   \   000017   E0           MOVX    A,@DPTR
   \   000018   2415         ADD     A,#0x15
   \   00001A   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   00001D   6E           XRL     A,R6
   \   00001E   7006         JNZ     ??mpu_read_reg_1
    741                  return -1;
   \                     ??mpu_read_reg_0:
   \   000020   7AFF         MOV     R2,#-0x1
   \   000022   7BFF         MOV     R3,#-0x1
   \   000024   8018         SJMP    ??mpu_read_reg_2
    742              if (reg >= st.hw->num_reg)
   \                     ??mpu_read_reg_1:
   \   000026   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000029   50F5         JNC     ??mpu_read_reg_0
    743                  return -1;
    744              return i2c_read(st.hw->addr, reg, 1, data);
   \   00002B                ; Setup parameters for call to function MPU_Read_Len
   \   00002B   7B01         MOV     R3,#0x1
   \   00002D   EE           MOV     A,R6
   \   00002E   FA           MOV     R2,A
   \   00002F   8882         MOV     DPL,R0
   \   000031   8983         MOV     DPH,R1
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F9           MOV     R1,A
   \   000035   12....       LCALL   ??MPU_Read_Len?relay
   \   000038   89..         MOV     ?V0 + 0,R1
   \   00003A   AA..         MOV     R2,?V0 + 0
   \   00003C   7B00         MOV     R3,#0x0
   \                     ??mpu_read_reg_2:
   \   00003E   02....       LJMP    ??Subroutine106_0 & 0xFFFF
    745          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   240B         ADD     A,#0xb
   \   000003   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET
    746          
    747          /**
    748           *  @brief      Initialize hardware.
    749           *  Initial configuration:\n
    750           *  Gyro FSR: +/- 2000DPS\n
    751           *  Accel FSR +/- 2G\n
    752           *  DLPF: 42Hz\n
    753           *  FIFO rate: 50Hz\n
    754           *  Clock source: Gyro PLL\n
    755           *  FIFO: Disabled.\n
    756           *  Data ready interrupt: Disabled, active low, unlatched.
    757           *  @param[in]  int_param   Platform-specific parameters to interrupt API.
    758           *  @return     0 if successful.
    759           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    760          int mpu_init(void)
   \                     mpu_init:
    761          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    762              unsigned char data[6], rev;
    763          
    764              /* Reset device. */
    765              data[0] = BIT_RESET;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7480         MOV     A,#-0x80
   \   000012   12....       LCALL   ?Subroutine57 & 0xFFFF
    766              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \                     ??CrossCallReturnLabel_80:
   \   000015   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000018   6007         JZ      ??mpu_init_0
    767                  return -1;
   \                     ??mpu_init_1:
   \   00001A   7AFF         MOV     R2,#-0x1
   \   00001C   7BFF         MOV     R3,#-0x1
   \   00001E   02....       LJMP    ??mpu_init_2 & 0xFFFF
    768              delay_ms(100);
   \                     ??mpu_init_0:
   \   000021                ; Setup parameters for call to function delay_ms
   \   000021   90....       MOV     DPTR,#__Constant_64
   \   000024   12....       LCALL   ?XLOAD_R2345
   \   000027   12....       LCALL   ?Subroutine63 & 0xFFFF
    769          
    770              /* Wake up chip. */
    771              data[0] = 0x00;
   \                     ??CrossCallReturnLabel_89:
   \   00002A   E4           CLR     A
   \   00002B   12....       LCALL   ?Subroutine57 & 0xFFFF
    772              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \                     ??CrossCallReturnLabel_81:
   \   00002E   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000031   70E7         JNZ     ??mpu_init_1
    773                  return -1;
    774          
    775          #if defined MPU6050
    776              /* Check product revision. */
    777              if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
   \   000033                ; Setup parameters for call to function MPU_Read_Len
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   AC82         MOV     R4,DPL
   \   00003B   AD83         MOV     R5,DPH
   \   00003D   7B06         MOV     R3,#0x6
   \   00003F   90....       MOV     DPTR,#st
   \   000042   E0           MOVX    A,@DPTR
   \   000043   2416         ADD     A,#0x16
   \   000045   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000048   70D0         JNZ     ??mpu_init_1
    778                  return -1;
    779              rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
    780                  (data[1] & 0x01);
   \   00004A   7401         MOV     A,#0x1
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   A2E0         MOV     C,0xE0 /* A   */.0
   \   000052   E4           CLR     A
   \   000053   33           RLC     A
   \   000054   F9           MOV     R1,A
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005D   E4           CLR     A
   \   00005E   33           RLC     A
   \   00005F   33           RLC     A
   \   000060   F8           MOV     R0,A
   \   000061   7405         MOV     A,#0x5
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   E0           MOVX    A,@DPTR
   \   000067   A2E0         MOV     C,0xE0 /* A   */.0
   \   000069   E4           CLR     A
   \   00006A   33           RLC     A
   \   00006B   33           RLC     A
   \   00006C   33           RLC     A
   \   00006D   48           ORL     A,R0
   \   00006E   49           ORL     A,R1
   \   00006F   F5..         MOV     ?V0 + 0,A
    781          
    782              if (rev) {
   \   000071   6029         JZ      ??mpu_init_3
    783                  /* Congrats, these parts are better. */
    784                  if (rev == 1)
   \   000073   7401         MOV     A,#0x1
   \   000075   65..         XRL     A,?V0 + 0
   \   000077   6059         JZ      ??mpu_init_4
    785                      st.chip_cfg.accel_half = 1;
    786                  else if (rev == 2)
   \   000079   7402         MOV     A,#0x2
   \   00007B   65..         XRL     A,?V0 + 0
   \   00007D   7006         JNZ     ??mpu_init_5
    787                      st.chip_cfg.accel_half = 0;
   \                     ??mpu_init_6:
   \   00007F   90....       MOV     DPTR,#st + 14
   \   000082   E4           CLR     A
   \   000083   8052         SJMP    ??mpu_init_7
    788                  else {
    789                      log_e("Unsupported software product rev %d.\n", rev);
   \                     ??mpu_init_5:
   \   000085                ; Setup parameters for call to function printf
   \   000085   75..00       MOV     ?V0 + 1,#0x0
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008D   7A..         MOV     R2,#`?<Constant "Unsupported software ...">` & 0xff
   \   00008F   7B..         MOV     R3,#(`?<Constant "Unsupported software ...">` >> 8) & 0xff
   \   000091   12....       LCALL   ??printf?relay
   \   000094   7402         MOV     A,#0x2
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   \   000099   02....       LJMP    ??mpu_init_1 & 0xFFFF
    790                      return -1;
    791                  }
    792              } else {
    793                  if (i2c_read(st.hw->addr, st.reg->prod_id, 1, data))
   \                     ??mpu_init_3:
   \   00009C                ; Setup parameters for call to function MPU_Read_Len
   \   00009C   85..82       MOV     DPL,?XSP + 0
   \   00009F   85..83       MOV     DPH,?XSP + 1
   \   0000A2   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   0000A5   A3           INC     DPTR
   \   0000A6   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   0000A9   6003         JZ      $+5
   \   0000AB   02....       LJMP    ??mpu_init_1 & 0xFFFF
    794                      return -1;
    795                  rev = data[0] & 0x0F;
   \   0000AE   85..82       MOV     DPL,?XSP + 0
   \   0000B1   85..83       MOV     DPH,?XSP + 1
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   540F         ANL     A,#0xf
   \   0000B7   F5..         MOV     ?V0 + 0,A
    796                  if (!rev) {
   \   0000B9   700A         JNZ     ??mpu_init_8
    797                      log_e("Product ID read as 0 indicates device is either "
    798                          "incompatible or an MPU3050.\n");
   \   0000BB                ; Setup parameters for call to function printf
   \   0000BB   7A..         MOV     R2,#`?<Constant "Product ID read as 0 ...">` & 0xff
   \   0000BD   7B..         MOV     R3,#(`?<Constant "Product ID read as 0 ...">` >> 8) & 0xff
   \   0000BF   12....       LCALL   ??printf?relay
   \   0000C2   02....       LJMP    ??mpu_init_1 & 0xFFFF
    799                      return -1;
    800                  } else if (rev == 4) {
   \                     ??mpu_init_8:
   \   0000C5   7404         MOV     A,#0x4
   \   0000C7   65..         XRL     A,?V0 + 0
   \   0000C9   70B4         JNZ     ??mpu_init_6
    801                      log_i("Half sensitivity part found.\n");
   \   0000CB                ; Setup parameters for call to function printf
   \   0000CB   7A..         MOV     R2,#`?<Constant "Half sensitivity part...">` & 0xff
   \   0000CD   7B..         MOV     R3,#(`?<Constant "Half sensitivity part...">` >> 8) & 0xff
   \   0000CF   12....       LCALL   ??printf?relay
    802                      st.chip_cfg.accel_half = 1;
   \                     ??mpu_init_4:
   \   0000D2   90....       MOV     DPTR,#st + 14
   \   0000D5   7401         MOV     A,#0x1
   \                     ??mpu_init_7:
   \   0000D7   F0           MOVX    @DPTR,A
    803                  } else
    804                      st.chip_cfg.accel_half = 0;
    805              }
    806          #elif defined MPU6500
    807          #define MPU6500_MEM_REV_ADDR    (0x17)
    808              if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
    809                  return -1;
    810              if (rev == 0x1)
    811                  st.chip_cfg.accel_half = 0;
    812              else {
    813                  log_e("Unsupported software product rev %d.\n", rev);
    814                  return -1;
    815              }
    816          
    817              /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
    818               * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
    819               */
    820              data[0] = BIT_FIFO_SIZE_1024 | 0x8;
    821              if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
    822                  return -1;
    823          #endif
    824          
    825              /* Set to invalid values to ensure no I2C writes are skipped. */
    826              st.chip_cfg.sensors = 0xFF;
   \   0000D8   90....       MOV     DPTR,#st + 6
   \   0000DB   74FF         MOV     A,#-0x1
   \   0000DD   F0           MOVX    @DPTR,A
    827              st.chip_cfg.gyro_fsr = 0xFF;
   \   0000DE   90....       MOV     DPTR,#st + 4
   \   0000E1   12....       LCALL   ?Subroutine90 & 0xFFFF
    828              st.chip_cfg.accel_fsr = 0xFF;
    829              st.chip_cfg.lpf = 0xFF;
    830              st.chip_cfg.sample_rate = 0xFFFF;
    831              st.chip_cfg.fifo_enable = 0xFF;
   \                     ??CrossCallReturnLabel_135:
   \   0000E4   A3           INC     DPTR
   \   0000E5   F0           MOVX    @DPTR,A
    832              st.chip_cfg.bypass_mode = 0xFF;
   \   0000E6   90....       MOV     DPTR,#st + 13
   \   0000E9   F0           MOVX    @DPTR,A
    833          #ifdef AK89xx_SECONDARY
    834              st.chip_cfg.compass_sample_rate = 0xFFFF;
    835          #endif
    836              /* mpu_set_sensors always preserves this setting. */
    837              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   0000EA   90....       MOV     DPTR,#st + 8
   \   0000ED   7401         MOV     A,#0x1
   \   0000EF   F0           MOVX    @DPTR,A
    838              /* Handled in next call to mpu_set_bypass. */
    839              st.chip_cfg.active_low_int = 1;
   \   0000F0   90....       MOV     DPTR,#st + 27
   \   0000F3   F0           MOVX    @DPTR,A
    840              st.chip_cfg.latched_int = 0;
   \   0000F4   A3           INC     DPTR
   \   0000F5   E4           CLR     A
   \   0000F6   F0           MOVX    @DPTR,A
    841              st.chip_cfg.int_motion_only = 0;
   \   0000F7   90....       MOV     DPTR,#st + 16
   \   0000FA   F0           MOVX    @DPTR,A
    842              st.chip_cfg.lp_accel_mode = 0;
   \   0000FB   90....       MOV     DPTR,#st + 15
   \   0000FE   F0           MOVX    @DPTR,A
    843              memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
   \   0000FF                ; Setup parameters for call to function memset
   \   0000FF   75..0A       MOV     ?V0 + 0,#0xa
   \   000102   F5..         MOV     ?V0 + 1,A
   \   000104   78..         MOV     R0,#?V0 + 0
   \   000106   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000109   7C00         MOV     R4,#0x0
   \   00010B   7D00         MOV     R5,#0x0
   \   00010D   7A..         MOV     R2,#(st + 17) & 0xff
   \   00010F   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   000111   12....       LCALL   ??memset?relay
   \   000114   7402         MOV     A,#0x2
   \   000116   12....       LCALL   ?DEALLOC_XSTACK8
    844              st.chip_cfg.dmp_on = 0;
   \   000119   90....       MOV     DPTR,#st + 29
   \   00011C   E4           CLR     A
   \   00011D   F0           MOVX    @DPTR,A
    845              st.chip_cfg.dmp_loaded = 0;
   \   00011E   A3           INC     DPTR
   \   00011F   F0           MOVX    @DPTR,A
    846              st.chip_cfg.dmp_sample_rate = 0;
   \   000120   A3           INC     DPTR
   \   000121   F0           MOVX    @DPTR,A
   \   000122   A3           INC     DPTR
   \   000123   F0           MOVX    @DPTR,A
    847          
    848              if (mpu_set_gyro_fsr(2000))
   \   000124                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   000124   7AD0         MOV     R2,#-0x30
   \   000126   7B07         MOV     R3,#0x7
   \   000128   12....       LCALL   ??mpu_set_gyro_fsr?relay
   \   00012B   8B..         MOV     ?V0 + 1,R3
   \   00012D   EA           MOV     A,R2
   \   00012E   45..         ORL     A,?V0 + 1
   \   000130   6003         JZ      $+5
   \   000132   02....       LJMP    ??mpu_init_1 & 0xFFFF
    849                  return -1;
    850              if (mpu_set_accel_fsr(2))
   \   000135                ; Setup parameters for call to function mpu_set_accel_fsr
   \   000135   7902         MOV     R1,#0x2
   \   000137   12....       LCALL   ??mpu_set_accel_fsr?relay
   \   00013A   8B..         MOV     ?V0 + 1,R3
   \   00013C   EA           MOV     A,R2
   \   00013D   45..         ORL     A,?V0 + 1
   \   00013F   6003         JZ      $+5
   \   000141   02....       LJMP    ??mpu_init_1 & 0xFFFF
    851                  return -1;
    852              if (mpu_set_lpf(42))
   \   000144                ; Setup parameters for call to function mpu_set_lpf
   \   000144   7A2A         MOV     R2,#0x2a
   \   000146   7B00         MOV     R3,#0x0
   \   000148   12....       LCALL   ??mpu_set_lpf?relay
   \   00014B   8B..         MOV     ?V0 + 1,R3
   \   00014D   EA           MOV     A,R2
   \   00014E   45..         ORL     A,?V0 + 1
   \   000150   6003         JZ      $+5
   \   000152   02....       LJMP    ??mpu_init_1 & 0xFFFF
    853                  return -1;
    854              if (mpu_set_sample_rate(50))
   \   000155                ; Setup parameters for call to function mpu_set_sample_rate
   \   000155   7A32         MOV     R2,#0x32
   \   000157   7B00         MOV     R3,#0x0
   \   000159   12....       LCALL   ??mpu_set_sample_rate?relay
   \   00015C   8B..         MOV     ?V0 + 1,R3
   \   00015E   EA           MOV     A,R2
   \   00015F   45..         ORL     A,?V0 + 1
   \   000161   6003         JZ      $+5
   \   000163   02....       LJMP    ??mpu_init_1 & 0xFFFF
    855                  return -1;
    856              if (mpu_configure_fifo(0))
   \   000166                ; Setup parameters for call to function mpu_configure_fifo
   \   000166   7900         MOV     R1,#0x0
   \   000168   12....       LCALL   ??mpu_configure_fifo?relay
   \   00016B   8B..         MOV     ?V0 + 1,R3
   \   00016D   EA           MOV     A,R2
   \   00016E   45..         ORL     A,?V0 + 1
   \   000170   6003         JZ      $+5
   \   000172   02....       LJMP    ??mpu_init_1 & 0xFFFF
    857                  return -1;
    858          
    859          //    if (int_param)
    860          //        reg_int_cb(int_param);
    861          
    862          #ifdef AK89xx_SECONDARY
    863              setup_compass();
    864              if (mpu_set_compass_sample_rate(10))
    865                  return -1;
    866          #else
    867              /* Already disabled by setup_compass. */
    868              if (mpu_set_bypass(0))
   \   000175                ; Setup parameters for call to function mpu_set_bypass
   \   000175   7900         MOV     R1,#0x0
   \   000177   12....       LCALL   ??mpu_set_bypass?relay
   \   00017A   8B..         MOV     ?V0 + 1,R3
   \   00017C   EA           MOV     A,R2
   \   00017D   45..         ORL     A,?V0 + 1
   \   00017F   6003         JZ      $+5
   \   000181   02....       LJMP    ??mpu_init_1 & 0xFFFF
    869                  return -1;
    870          #endif
    871          
    872              mpu_set_sensors(0);
   \   000184                ; Setup parameters for call to function mpu_set_sensors
   \   000184   7900         MOV     R1,#0x0
   \   000186   12....       LCALL   ??mpu_set_sensors?relay
    873              return 0;
   \   000189   7A00         MOV     R2,#0x0
   \   00018B   7B00         MOV     R3,#0x0
   \                     ??mpu_init_2:
   \   00018D   7406         MOV     A,#0x6
   \   00018F   80..         SJMP    ??Subroutine103_0
    874          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000003                REQUIRE ??Subroutine108_0
   \   000003                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   000003   12....       LCALL   ??MPU_Read_Len?relay
   \   000006   E9           MOV     A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL   ??delay_ms?relay
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   90....       MOV     DPTR,#st
   \   000009   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   90....       MOV     DPTR,#st + 7
   \   000006   F0           MOVX    @DPTR,A
   \   000007   90....       MOV     DPTR,#st + 9
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   90....       MOV     DPTR,#st
   \   000003   E0           MOVX    A,@DPTR
   \   000004   2412         ADD     A,#0x12
   \   000006                REQUIRE ??Subroutine140_0
   \   000006                ; // Fall through to label ??Subroutine140_0
    875          
    876          /**
    877           *  @brief      Enter low-power accel-only mode.
    878           *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
    879           *  the accelerometer at one of the following frequencies:
    880           *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
    881           *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
    882           *  \n If the requested rate is not one listed above, the device will be set to
    883           *  the next highest rate. Requesting a rate above the maximum supported
    884           *  frequency will result in an error.
    885           *  \n To select a fractional wake-up frequency, round down the value passed to
    886           *  @e rate.
    887           *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
    888           *                          accel mode.
    889           *  @return     0 if successful.
    890           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    891          int mpu_lp_accel_mode(unsigned char rate)
   \                     mpu_lp_accel_mode:
    892          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    893              unsigned char tmp[2];
    894          
    895              if (rate > 40)
   \   00000C   C3           CLR     C
   \   00000D   9429         SUBB    A,#0x29
   \   00000F   4007         JC      ??mpu_lp_accel_mode_0
    896                  return -1;
   \                     ??mpu_lp_accel_mode_1:
   \   000011   7AFF         MOV     R2,#-0x1
   \   000013   7BFF         MOV     R3,#-0x1
   \   000015   02....       LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
    897          
    898              if (!rate) {
   \                     ??mpu_lp_accel_mode_0:
   \   000018   EE           MOV     A,R6
   \   000019   701B         JNZ     ??mpu_lp_accel_mode_3
    899                  mpu_set_int_latched(0);
   \   00001B                ; Setup parameters for call to function mpu_set_int_latched
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   12....       LCALL   ?Subroutine65 & 0xFFFF
    900                  tmp[0] = 0;
   \                     ??CrossCallReturnLabel_92:
   \   000020   E4           CLR     A
   \   000021   F0           MOVX    @DPTR,A
    901                  tmp[1] = BIT_STBY_XYZG;
   \   000022   04           INC     A
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   7407         MOV     A,#0x7
   \   000028   12....       LCALL   ??Subroutine137_0 & 0xFFFF
    902                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \                     ??CrossCallReturnLabel_277:
   \   00002B   70E4         JNZ     ??mpu_lp_accel_mode_1
    903                      return -1;
    904                  st.chip_cfg.lp_accel_mode = 0;
   \   00002D   90....       MOV     DPTR,#st + 15
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
    905                  return 0;
   \   000032   FA           MOV     R2,A
   \   000033   FB           MOV     R3,A
   \   000034   806D         SJMP    ??mpu_lp_accel_mode_2
    906              }
    907              /* For LP accel, we automatically configure the hardware to produce latched
    908               * interrupts. In LP accel mode, the hardware cycles into sleep mode before
    909               * it gets a chance to deassert the interrupt pin; therefore, we shift this
    910               * responsibility over to the MCU.
    911               *
    912               * Any register read will clear the interrupt.
    913               */
    914              mpu_set_int_latched(1);
   \                     ??mpu_lp_accel_mode_3:
   \   000036                ; Setup parameters for call to function mpu_set_int_latched
   \   000036   7901         MOV     R1,#0x1
   \   000038   12....       LCALL   ?Subroutine65 & 0xFFFF
    915          #if defined MPU6050
    916              tmp[0] = BIT_LPA_CYCLE;
   \                     ??CrossCallReturnLabel_93:
   \   00003B   7420         MOV     A,#0x20
   \   00003D   F0           MOVX    @DPTR,A
    917              if (rate == 1) {
   \   00003E   7401         MOV     A,#0x1
   \   000040   6E           XRL     A,R6
   \   000041   700C         JNZ     ??mpu_lp_accel_mode_4
    918                  tmp[1] = INV_LPA_1_25HZ;
   \   000043   7401         MOV     A,#0x1
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
    919                  mpu_set_lpf(5);
   \   00004A                ; Setup parameters for call to function mpu_set_lpf
   \   00004A   7A05         MOV     R2,#0x5
   \   00004C   FB           MOV     R3,A
   \   00004D   802E         SJMP    ??mpu_lp_accel_mode_5
    920              } else if (rate <= 5) {
   \                     ??mpu_lp_accel_mode_4:
   \   00004F   EE           MOV     A,R6
   \   000050   C3           CLR     C
   \   000051   9406         SUBB    A,#0x6
   \   000053   500C         JNC     ??mpu_lp_accel_mode_6
    921                  tmp[1] = INV_LPA_5HZ;
   \   000055   7401         MOV     A,#0x1
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   7401         MOV     A,#0x1
   \   00005C   F0           MOVX    @DPTR,A
    922                  mpu_set_lpf(5);
   \   00005D                ; Setup parameters for call to function mpu_set_lpf
   \   00005D   7A05         MOV     R2,#0x5
   \   00005F   801A         SJMP    ??mpu_lp_accel_mode_7
    923              } else if (rate <= 20) {
   \                     ??mpu_lp_accel_mode_6:
   \   000061   EE           MOV     A,R6
   \   000062   C3           CLR     C
   \   000063   9415         SUBB    A,#0x15
   \   000065   7401         MOV     A,#0x1
   \   000067   500A         JNC     ??mpu_lp_accel_mode_8
    924                  tmp[1] = INV_LPA_20HZ;
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   7402         MOV     A,#0x2
   \   00006E   F0           MOVX    @DPTR,A
    925                  mpu_set_lpf(10);
   \   00006F                ; Setup parameters for call to function mpu_set_lpf
   \   00006F   7A0A         MOV     R2,#0xa
   \   000071   8008         SJMP    ??mpu_lp_accel_mode_7
    926              } else {
    927                  tmp[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_accel_mode_8:
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   7403         MOV     A,#0x3
   \   000078   F0           MOVX    @DPTR,A
    928                  mpu_set_lpf(20);
   \   000079                ; Setup parameters for call to function mpu_set_lpf
   \   000079   7A14         MOV     R2,#0x14
   \                     ??mpu_lp_accel_mode_7:
   \   00007B   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_5:
   \   00007D   12....       LCALL   ??mpu_set_lpf?relay
    929              }
    930              tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
   \   000080   7401         MOV     A,#0x1
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   12....       LCALL   ?Subroutine11 & 0xFFFF
    931              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \                     ??CrossCallReturnLabel_275:
   \   000088   7087         JNZ     ??mpu_lp_accel_mode_1
    932                  return -1;
    933          #elif defined MPU6500
    934              /* Set wake frequency. */
    935              if (rate == 1)
    936                  tmp[0] = INV_LPA_1_25HZ;
    937              else if (rate == 2)
    938                  tmp[0] = INV_LPA_2_5HZ;
    939              else if (rate <= 5)
    940                  tmp[0] = INV_LPA_5HZ;
    941              else if (rate <= 10)
    942                  tmp[0] = INV_LPA_10HZ;
    943              else if (rate <= 20)
    944                  tmp[0] = INV_LPA_20HZ;
    945              else if (rate <= 40)
    946                  tmp[0] = INV_LPA_40HZ;
    947              else if (rate <= 80)
    948                  tmp[0] = INV_LPA_80HZ;
    949              else if (rate <= 160)
    950                  tmp[0] = INV_LPA_160HZ;
    951              else if (rate <= 320)
    952                  tmp[0] = INV_LPA_320HZ;
    953              else
    954                  tmp[0] = INV_LPA_640HZ;
    955              if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
    956                  return -1;
    957              tmp[0] = BIT_LPA_CYCLE;
    958              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
    959                  return -1;
    960          #endif
    961              st.chip_cfg.sensors = INV_XYZ_ACCEL;
   \   00008A   90....       MOV     DPTR,#st + 6
   \   00008D   7408         MOV     A,#0x8
   \   00008F   F0           MOVX    @DPTR,A
    962              st.chip_cfg.clk_src = 0;
   \   000090   90....       MOV     DPTR,#st + 8
   \   000093   E4           CLR     A
   \   000094   F0           MOVX    @DPTR,A
    963              st.chip_cfg.lp_accel_mode = 1;
   \   000095   90....       MOV     DPTR,#st + 15
   \   000098   04           INC     A
   \   000099   F0           MOVX    @DPTR,A
    964              mpu_configure_fifo(0);
   \   00009A                ; Setup parameters for call to function mpu_configure_fifo
   \   00009A   7900         MOV     R1,#0x0
   \   00009C   12....       LCALL   ??mpu_configure_fifo?relay
    965          
    966              return 0;
   \   00009F   7A00         MOV     R2,#0x0
   \   0000A1   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_2:
   \   0000A3                REQUIRE ?Subroutine8
   \   0000A3                ; // Fall through to label ?Subroutine8
    967          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7402         MOV     A,#0x2
   \   000002   80..         SJMP    ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL   ??mpu_set_int_latched?relay
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C4           SWAP    A
   \   000002   33           RLC     A
   \   000003   33           RLC     A
   \   000004   54C0         ANL     A,#0xc0
   \   000006   4407         ORL     A,#0x7
   \   000008                REQUIRE ??Subroutine137_0
   \   000008                ; // Fall through to label ??Subroutine137_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   000003                REQUIRE ??Subroutine138_0
   \   000003                ; // Fall through to label ??Subroutine138_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B02         MOV     R3,#0x2
   \   000006                REQUIRE ??Subroutine139_0
   \   000006                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function dmp_read_fifo
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET
    968          
    969          /**
    970           *  @brief      Read raw gyro data directly from the registers.
    971           *  @param[out] data        Raw data in hardware units.
    972           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
    973           *  @return     0 if successful.
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_gyro_reg:
    976          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    977              unsigned char tmp[6];
    978          
    979              if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   5470         ANL     A,#0x70
   \   000014   7006         JNZ     ??mpu_get_gyro_reg_0
    980                  return -1;
   \                     ??mpu_get_gyro_reg_1:
   \   000016   7AFF         MOV     R2,#-0x1
   \   000018   7BFF         MOV     R3,#-0x1
   \   00001A   803A         SJMP    ??CrossCallReturnLabel_25
    981          
    982              if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
   \                     ??mpu_get_gyro_reg_0:
   \   00001C                ; Setup parameters for call to function MPU_Read_Len
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   7B06         MOV     R3,#0x6
   \   000028   90....       MOV     DPTR,#st
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   240C         ADD     A,#0xc
   \   00002E   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000031   70E3         JNZ     ??mpu_get_gyro_reg_1
    983                  return -1;
    984              data[0] = (tmp[0] << 8) | tmp[1];
   \   000033   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine44 & 0xFFFF
    985              data[1] = (tmp[2] << 8) | tmp[3];
   \                     ??CrossCallReturnLabel_52:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine38 & 0xFFFF
    986              data[2] = (tmp[4] << 8) | tmp[5];
   \                     ??CrossCallReturnLabel_39:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine28 & 0xFFFF
    987              if (timestamp)
    988                  get_ms(timestamp);
    989              return 0;
   \                     ??CrossCallReturnLabel_25:
   \   000056                REQUIRE ?Subroutine9
   \   000056                ; // Fall through to label ?Subroutine9
    990          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7406         MOV     A,#0x6
   \   000002   80..         SJMP    ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E9           MOV     A,R1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   7402         MOV     A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   E9           MOV     A,R1
   \   000008   F0           MOVX    @DPTR,A
   \   000009   7404         MOV     A,#0x4
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   E9           MOV     A,R1
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   7A00         MOV     R2,#0x0
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   7401         MOV     A,#0x1
   \   00000A   22           RET
    991          
    992          /**
    993           *  @brief      Read raw accel data directly from the registers.
    994           *  @param[out] data        Raw data in hardware units.
    995           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
    996           *  @return     0 if successful.
    997           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    998          int mpu_get_accel_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_accel_reg:
    999          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1000              unsigned char tmp[6];
   1001          
   1002              if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   A2E3         MOV     C,0xE0 /* A   */.3
   \   000014   4006         JC      ??mpu_get_accel_reg_0
   1003                  return -1;
   \                     ??mpu_get_accel_reg_1:
   \   000016   7AFF         MOV     R2,#-0x1
   \   000018   7BFF         MOV     R3,#-0x1
   \   00001A   803A         SJMP    ??CrossCallReturnLabel_26
   1004          
   1005              if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
   \                     ??mpu_get_accel_reg_0:
   \   00001C                ; Setup parameters for call to function MPU_Read_Len
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   7B06         MOV     R3,#0x6
   \   000028   90....       MOV     DPTR,#st
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   240D         ADD     A,#0xd
   \   00002E   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000031   70E3         JNZ     ??mpu_get_accel_reg_1
   1006                  return -1;
   1007              data[0] = (tmp[0] << 8) | tmp[1];
   \   000033   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine44 & 0xFFFF
   1008              data[1] = (tmp[2] << 8) | tmp[3];
   \                     ??CrossCallReturnLabel_53:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine38 & 0xFFFF
   1009              data[2] = (tmp[4] << 8) | tmp[5];
   \                     ??CrossCallReturnLabel_40:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine28 & 0xFFFF
   1010              if (timestamp)
   1011                  get_ms(timestamp);
   1012              return 0;
   \                     ??CrossCallReturnLabel_26:
   \   000056   80..         SJMP    ?Subroutine9
   1013          }
   1014          
   1015          /**
   1016           *  @brief      Read temperature data directly from the registers.
   1017           *  @param[out] data        Data in q16 format.
   1018           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1019           *  @return     0 if successful.
   1020           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1021          int mpu_get_temperature(long *data, unsigned long *timestamp)
   \                     mpu_get_temperature:
   1022          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1023              unsigned char tmp[2];
   1024              short raw;
   1025          
   1026              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_get_temperature_0
   1027                  return -1;
   \                     ??mpu_get_temperature_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_get_temperature_2 & 0xFFFF
   1028          
   1029              if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
   \                     ??mpu_get_temperature_0:
   \   00001B                ; Setup parameters for call to function MPU_Read_Len
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   AC82         MOV     R4,DPL
   \   000023   AD83         MOV     R5,DPH
   \   000025   7B02         MOV     R3,#0x2
   \   000027   90....       MOV     DPTR,#st
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   240E         ADD     A,#0xe
   \   00002D   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000030   70E2         JNZ     ??mpu_get_temperature_1
   1030                  return -1;
   1031              raw = (tmp[0] << 8) | tmp[1];
   1032              if (timestamp)
   1033                  get_ms(timestamp);
   1034          
   1035              data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
   \   000032   90....       MOV     DPTR,#st + 2
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F8           MOV     R0,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   E8           MOV     A,R0
   \   00003B   FA           MOV     R2,A
   \   00003C   E9           MOV     A,R1
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F5..         MOV     ?V0 + 0,A
   \   000047   E9           MOV     A,R1
   \   000048   F5..         MOV     ?V0 + 1,A
   \   00004A   33           RLC     A
   \   00004B   95E0         SUBB    A,0xE0 /* A   */
   \   00004D   F5..         MOV     ?V0 + 2,A
   \   00004F   F5..         MOV     ?V0 + 3,A
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?L_TO_FLT
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000063   78..         MOV     R0,#?V0 + 4
   \   000065   12....       LCALL   ?L_TO_FLT
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   79..         MOV     R1,#?V0 + 4
   \   00006C   12....       LCALL   ?FLT_SUB
   \   00006F   8A82         MOV     DPL,R2
   \   000071   8B83         MOV     DPH,R3
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   00007A   E4           CLR     A
   \   00007B   F5..         MOV     ?V0 + 6,A
   \   00007D   F5..         MOV     ?V0 + 7,A
   \   00007F   78..         MOV     R0,#?V0 + 4
   \   000081   12....       LCALL   ?UL_TO_FLT
   \   000084   78..         MOV     R0,#?V0 + 0
   \   000086   79..         MOV     R1,#?V0 + 4
   \   000088   12....       LCALL   ?FLT_DIV
   \   00008B   90....       MOV     DPTR,#__Constant_420c0000
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   12....       LCALL   ?L_MOV_X
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   79..         MOV     R1,#?V0 + 4
   \   000097   12....       LCALL   ?FLT_ADD
   \   00009A   90....       MOV     DPTR,#__Constant_47800000
   \   00009D   78..         MOV     R0,#?V0 + 4
   \   00009F   12....       LCALL   ?L_MOV_X
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   79..         MOV     R1,#?V0 + 4
   \   0000A6   12....       LCALL   ?FLT_MUL
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?FLT_TO_L
   \   0000AE   8E82         MOV     DPL,R6
   \   0000B0   8F83         MOV     DPH,R7
   \   0000B2   78..         MOV     R0,#?V0 + 0
   \   0000B4   12....       LCALL   ?L_MOV_TO_X
   1036              return 0;
   \   0000B7   7A00         MOV     R2,#0x0
   \   0000B9   7B00         MOV     R3,#0x0
   \                     ??mpu_get_temperature_2:
   \   0000BB   02....       LJMP    ?Subroutine2 & 0xFFFF
   1037          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000003   33           RLC     A
   \   000004   95E0         SUBB    A,0xE0 /* A   */
   \   000006   F5..         MOV     ?V0 + 6,A
   \   000008   F5..         MOV     ?V0 + 7,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine133_0
   \   000002                ; // Fall through to label ??Subroutine133_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
   1038          
   1039          /**
   1040           *  @brief      Push biases to the accel bias registers.
   1041           *  This function expects biases relative to the current sensor output, and
   1042           *  these biases will be added to the factory-supplied values.
   1043           *  @param[in]  accel_bias  New biases.
   1044           *  @return     0 if successful.
   1045           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1046          int mpu_set_accel_bias(const long *accel_bias)
   \                     mpu_set_accel_bias:
   1047          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1048              unsigned char data[6];
   1049              short accel_hw[3];
   1050              short got_accel[3];
   1051              short fg[3];
   1052          
   1053              if (!accel_bias)
   \   00000E   EE           MOV     A,R6
   \   00000F   4F           ORL     A,R7
   \   000010   700E         JNZ     ??mpu_set_accel_bias_0
   1054                  return -1;
   \                     ??mpu_set_accel_bias_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \                     ??mpu_set_accel_bias_2:
   \   000016   7418         MOV     A,#0x18
   \   000018   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001B   7F0C         MOV     R7,#0xc
   \   00001D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1055              if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
   \                     ??mpu_set_accel_bias_0:
   \   000020   EE           MOV     A,R6
   \   000021   2408         ADD     A,#0x8
   \   000023   F5..         MOV     ?V0 + 2,A
   \   000025   EF           MOV     A,R7
   \   000026   3400         ADDC    A,#0x0
   \   000028   F5..         MOV     ?V0 + 3,A
   \   00002A   EE           MOV     A,R6
   \   00002B   2404         ADD     A,#0x4
   \   00002D   F5..         MOV     ?V0 + 0,A
   \   00002F   EF           MOV     A,R7
   \   000030   3400         ADDC    A,#0x0
   \   000032   F5..         MOV     ?V0 + 1,A
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   78..         MOV     R0,#?V0 + 4
   \   00003A   12....       LCALL   ?L_MOV_X
   \   00003D   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000040   7026         JNZ     ??mpu_set_accel_bias_3
   \   000042   85..82       MOV     DPL,?V0 + 0
   \   000045   85..83       MOV     DPH,?V0 + 1
   \   000048   78..         MOV     R0,#?V0 + 4
   \   00004A   12....       LCALL   ?L_MOV_X
   \   00004D   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000050   7016         JNZ     ??mpu_set_accel_bias_3
   \   000052   85..82       MOV     DPL,?V0 + 2
   \   000055   85..83       MOV     DPH,?V0 + 3
   \   000058   78..         MOV     R0,#?V0 + 4
   \   00005A   12....       LCALL   ?L_MOV_X
   \   00005D   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000060   7006         JNZ     ??mpu_set_accel_bias_3
   1056                  return 0;
   \                     ??mpu_set_accel_bias_4:
   \   000062   7A00         MOV     R2,#0x0
   \   000064   7B00         MOV     R3,#0x0
   \   000066   80AE         SJMP    ??mpu_set_accel_bias_2
   1057          
   1058              if (i2c_read(st.hw->addr, 3, 3, data))
   \                     ??mpu_set_accel_bias_3:
   \   000068                ; Setup parameters for call to function MPU_Read_Len
   \   000068   85..82       MOV     DPL,?XSP + 0
   \   00006B   85..83       MOV     DPH,?XSP + 1
   \   00006E   AC82         MOV     R4,DPL
   \   000070   AD83         MOV     R5,DPH
   \   000072   7B03         MOV     R3,#0x3
   \   000074   7A03         MOV     R2,#0x3
   \   000076   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000079   7097         JNZ     ??mpu_set_accel_bias_1
   1059                  return -1;
   1060              fg[0] = ((data[0] >> 4) + 8) & 0xf;
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000084   F8           MOV     R0,A
   \   000085   740C         MOV     A,#0xc
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   E8           MOV     A,R0
   \   00008B   F0           MOVX    @DPTR,A
   \   00008C   A3           INC     DPTR
   \   00008D   E4           CLR     A
   \   00008E   F0           MOVX    @DPTR,A
   1061              fg[1] = ((data[1] >> 4) + 8) & 0xf;
   \   00008F   04           INC     A
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000096   FA           MOV     R2,A
   \   000097   740E         MOV     A,#0xe
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   EA           MOV     A,R2
   \   00009D   F0           MOVX    @DPTR,A
   \   00009E   A3           INC     DPTR
   \   00009F   E4           CLR     A
   \   0000A0   F0           MOVX    @DPTR,A
   1062              fg[2] = ((data[2] >> 4) + 8) & 0xf;
   \   0000A1   7402         MOV     A,#0x2
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0000A9   FC           MOV     R4,A
   \   0000AA   7410         MOV     A,#0x10
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   EC           MOV     A,R4
   \   0000B0   F0           MOVX    @DPTR,A
   \   0000B1   A3           INC     DPTR
   \   0000B2   E4           CLR     A
   \   0000B3   F0           MOVX    @DPTR,A
   1063          
   1064              accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
   \   0000B4   8E82         MOV     DPL,R6
   \   0000B6   8F83         MOV     DPH,R7
   \   0000B8   78..         MOV     R0,#?V0 + 8
   \   0000BA   12....       LCALL   ?L_MOV_X
   \   0000BD   7401         MOV     A,#0x1
   \   0000BF   78..         MOV     R0,#?V0 + 8
   \   0000C1   12....       LCALL   ?L_SHL
   \   0000C4   740C         MOV     A,#0xc
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   2440         ADD     A,#0x40
   \   0000CC   F5..         MOV     ?V0 + 4,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   3400         ADDC    A,#0x0
   \   0000D2   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   0000D5   78..         MOV     R0,#?V0 + 8
   \   0000D7   79..         MOV     R1,#?V0 + 4
   \   0000D9   12....       LCALL   ?L_DIV_MOD
   \   0000DC   7406         MOV     A,#0x6
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   E5..         MOV     A,?V0 + 8
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   E5..         MOV     A,?V0 + 9
   \   0000E7   F0           MOVX    @DPTR,A
   1065              accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
   \   0000E8   85..82       MOV     DPL,?V0 + 0
   \   0000EB   85..83       MOV     DPH,?V0 + 1
   \   0000EE   78..         MOV     R0,#?V0 + 4
   \   0000F0   12....       LCALL   ?L_MOV_X
   \   0000F3   7401         MOV     A,#0x1
   \   0000F5   78..         MOV     R0,#?V0 + 4
   \   0000F7   12....       LCALL   ?L_SHL
   \   0000FA   EA           MOV     A,R2
   \   0000FB   2440         ADD     A,#0x40
   \   0000FD   F5..         MOV     ?V0 + 8,A
   \   0000FF   E4           CLR     A
   \   000100   F5..         MOV     ?V0 + 9,A
   \   000102   F5..         MOV     ?V0 + 10,A
   \   000104   F5..         MOV     ?V0 + 11,A
   \   000106   78..         MOV     R0,#?V0 + 4
   \   000108   79..         MOV     R1,#?V0 + 8
   \   00010A   12....       LCALL   ?L_DIV_MOD
   \   00010D   7408         MOV     A,#0x8
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   E5..         MOV     A,?V0 + 4
   \   000114   F0           MOVX    @DPTR,A
   \   000115   A3           INC     DPTR
   \   000116   E5..         MOV     A,?V0 + 5
   \   000118   F0           MOVX    @DPTR,A
   1066              accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
   \   000119   85..82       MOV     DPL,?V0 + 2
   \   00011C   85..83       MOV     DPH,?V0 + 3
   \   00011F   78..         MOV     R0,#?V0 + 0
   \   000121   12....       LCALL   ?L_MOV_X
   \   000124   7401         MOV     A,#0x1
   \   000126   78..         MOV     R0,#?V0 + 0
   \   000128   12....       LCALL   ?L_SHL
   \   00012B   EC           MOV     A,R4
   \   00012C   2440         ADD     A,#0x40
   \   00012E   F5..         MOV     ?V0 + 4,A
   \   000130   E4           CLR     A
   \   000131   F5..         MOV     ?V0 + 5,A
   \   000133   F5..         MOV     ?V0 + 6,A
   \   000135   F5..         MOV     ?V0 + 7,A
   \   000137   78..         MOV     R0,#?V0 + 0
   \   000139   79..         MOV     R1,#?V0 + 4
   \   00013B   12....       LCALL   ?L_DIV_MOD
   \   00013E   740A         MOV     A,#0xa
   \   000140   12....       LCALL   ?XSTACK_DISP0_8
   \   000143   E5..         MOV     A,?V0 + 0
   \   000145   F0           MOVX    @DPTR,A
   \   000146   A3           INC     DPTR
   \   000147   E5..         MOV     A,?V0 + 1
   \   000149   12....       LCALL   ?Subroutine55 & 0xFFFF
   1067          
   1068              if (i2c_read(st.hw->addr, 0x06, 6, data))
   \                     ??CrossCallReturnLabel_76:
   \   00014C   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   00014F   6003         JZ      $+5
   \   000151   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   1069                  return -1;
   1070          
   1071              got_accel[0] = ((short)data[0] << 8) | data[1];
   \   000154   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000157   12....       LCALL   ?XSTACK_DISP0_8
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   F8           MOV     R0,A
   \   00015C   7412         MOV     A,#0x12
   \   00015E   12....       LCALL   ?XSTACK_DISP0_8
   \   000161   12....       LCALL   ?Subroutine59 & 0xFFFF
   1072              got_accel[1] = ((short)data[2] << 8) | data[3];
   \                     ??CrossCallReturnLabel_165:
   \   000164   7402         MOV     A,#0x2
   \   000166   12....       LCALL   ?XSTACK_DISP0_8
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   F9           MOV     R1,A
   \   00016B   7403         MOV     A,#0x3
   \   00016D   12....       LCALL   ?XSTACK_DISP0_8
   \   000170   E0           MOVX    A,@DPTR
   \   000171   FA           MOV     R2,A
   \   000172   E9           MOV     A,R1
   \   000173   FB           MOV     R3,A
   \   000174   7414         MOV     A,#0x14
   \   000176   12....       LCALL   ?XSTACK_DISP0_8
   \   000179   12....       LCALL   ?Subroutine94 & 0xFFFF
   1073              got_accel[2] = ((short)data[4] << 8) | data[5];
   \                     ??CrossCallReturnLabel_139:
   \   00017C   7404         MOV     A,#0x4
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   E0           MOVX    A,@DPTR
   \   000182   F9           MOV     R1,A
   \   000183   7405         MOV     A,#0x5
   \   000185   12....       LCALL   ?XSTACK_DISP0_8
   \   000188   E0           MOVX    A,@DPTR
   \   000189   F8           MOV     R0,A
   \   00018A   7416         MOV     A,#0x16
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   12....       LCALL   ?Subroutine59 & 0xFFFF
   1074          
   1075              accel_hw[0] += got_accel[0];
   \                     ??CrossCallReturnLabel_166:
   \   000192   7412         MOV     A,#0x12
   \   000194   12....       LCALL   ?XSTACK_DISP0_8
   \   000197   E0           MOVX    A,@DPTR
   \   000198   FC           MOV     R4,A
   \   000199   A3           INC     DPTR
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   FD           MOV     R5,A
   \   00019C   7406         MOV     A,#0x6
   \   00019E   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A1   E0           MOVX    A,@DPTR
   \   0001A2   2C           ADD     A,R4
   \   0001A3   F0           MOVX    @DPTR,A
   \   0001A4   A3           INC     DPTR
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   3D           ADDC    A,R5
   \   0001A7   F0           MOVX    @DPTR,A
   1076              accel_hw[1] += got_accel[1];
   \   0001A8   7408         MOV     A,#0x8
   \   0001AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AD   E0           MOVX    A,@DPTR
   \   0001AE   2A           ADD     A,R2
   \   0001AF   F0           MOVX    @DPTR,A
   \   0001B0   A3           INC     DPTR
   \   0001B1   E0           MOVX    A,@DPTR
   \   0001B2   3B           ADDC    A,R3
   \   0001B3   F0           MOVX    @DPTR,A
   1077              accel_hw[2] += got_accel[2];
   \   0001B4   740A         MOV     A,#0xa
   \   0001B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B9   E0           MOVX    A,@DPTR
   \   0001BA   28           ADD     A,R0
   \   0001BB   F0           MOVX    @DPTR,A
   \   0001BC   A3           INC     DPTR
   \   0001BD   E0           MOVX    A,@DPTR
   \   0001BE   39           ADDC    A,R1
   \   0001BF   F0           MOVX    @DPTR,A
   1078          
   1079              data[0] = (accel_hw[0] >> 8) & 0xff;
   \   0001C0   7406         MOV     A,#0x6
   \   0001C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C5   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   0001C8   7408         MOV     A,#0x8
   \   0001CA   78..         MOV     R0,#?V0 + 0
   \   0001CC   12....       LCALL   ?SS_SHR
   \   0001CF   85..82       MOV     DPL,?XSP + 0
   \   0001D2   85..83       MOV     DPH,?XSP + 1
   \   0001D5   E5..         MOV     A,?V0 + 0
   \   0001D7   F0           MOVX    @DPTR,A
   1080              data[1] = (accel_hw[0]) & 0xff;
   \   0001D8   7406         MOV     A,#0x6
   \   0001DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DD   E0           MOVX    A,@DPTR
   \   0001DE   C0E0         PUSH    A
   \   0001E0   7401         MOV     A,#0x1
   \   0001E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E5   D0E0         POP     A
   \   0001E7   F0           MOVX    @DPTR,A
   1081              data[2] = (accel_hw[1] >> 8) & 0xff;
   \   0001E8   7408         MOV     A,#0x8
   \   0001EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001ED   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   0001F0   12....       LCALL   ?SS_SHR
   \   0001F3   7402         MOV     A,#0x2
   \   0001F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F8   E5..         MOV     A,?V0 + 0
   \   0001FA   F0           MOVX    @DPTR,A
   1082              data[3] = (accel_hw[1]) & 0xff;
   \   0001FB   7403         MOV     A,#0x3
   \   0001FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000200   EA           MOV     A,R2
   \   000201   F0           MOVX    @DPTR,A
   1083              data[4] = (accel_hw[2] >> 8) & 0xff;
   \   000202   740A         MOV     A,#0xa
   \   000204   12....       LCALL   ?XSTACK_DISP0_8
   \   000207   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00020A   12....       LCALL   ?SS_SHR
   \   00020D   7404         MOV     A,#0x4
   \   00020F   12....       LCALL   ?XSTACK_DISP0_8
   \   000212   E5..         MOV     A,?V0 + 0
   \   000214   F0           MOVX    @DPTR,A
   1084              data[5] = (accel_hw[2]) & 0xff;
   \   000215   7405         MOV     A,#0x5
   \   000217   12....       LCALL   ?XSTACK_DISP0_8
   \   00021A   EA           MOV     A,R2
   \   00021B   12....       LCALL   ?Subroutine55 & 0xFFFF
   1085          
   1086              if (i2c_write(st.hw->addr, 0x06, 6, data))
   \                     ??CrossCallReturnLabel_77:
   \   00021E   90....       MOV     DPTR,#st + 2
   \   000221   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000224   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000227   E9           MOV     A,R1
   \   000228   6003         JZ      $+5
   \   00022A   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   \   00022D   02....       LJMP    ??mpu_set_accel_bias_4 & 0xFFFF
   1087                  return -1;
   1088              return 0;
   1089          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   E5..         MOV     A,?V0 + 4
   \   000002   45..         ORL     A,?V0 + 5
   \   000004   45..         ORL     A,?V0 + 6
   \   000006   45..         ORL     A,?V0 + 7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine109_0
   \   000001                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000003   7B06         MOV     R3,#0x6
   \   000005   7A06         MOV     R2,#0x6
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   7408         MOV     A,#0x8
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C4           SWAP    A
   \   000002   540F         ANL     A,#0xf
   \   000004   2408         ADD     A,#0x8
   \   000006   540F         ANL     A,#0xf
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000003   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   F5..         MOV     ?V0 + 5,A
   \   000002   33           RLC     A
   \   000003   95E0         SUBB    A,0xE0 /* A   */
   \   000005   F5..         MOV     ?V0 + 6,A
   \   000007   F5..         MOV     ?V0 + 7,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003                REQUIRE ??Subroutine129_0
   \   000003                ; // Fall through to label ??Subroutine129_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??MPU_Write_Len?relay
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Read_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   AC82         MOV     R4,DPL
   \   000009   AD83         MOV     R5,DPH
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
   1090          
   1091          /**
   1092           *  @brief  Reset FIFO read/write pointers.
   1093           *  @return 0 if successful.
   1094           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1095          int mpu_reset_fifo(void)
   \                     mpu_reset_fifo:
   1096          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1097              unsigned char data;
   1098          
   1099              if (!(st.chip_cfg.sensors))
   \   000009   90....       MOV     DPTR,#st + 6
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   7007         JNZ     ??mpu_reset_fifo_0
   1100                  return -1;
   \                     ??mpu_reset_fifo_1:
   \   00000F   7AFF         MOV     R2,#-0x1
   \   000011   7BFF         MOV     R3,#-0x1
   \   000013   02....       LJMP    ??mpu_reset_fifo_2 & 0xFFFF
   1101          
   1102              data = 0;
   \                     ??mpu_reset_fifo_0:
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   12....       LCALL   ?Subroutine51 & 0xFFFF
   1103              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_256:
   \   00001F   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000022   70EB         JNZ     ??mpu_reset_fifo_1
   1104                  return -1;
   1105              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   \   000024                ; Setup parameters for call to function MPU_Write_Len
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   00002D   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000030   70DD         JNZ     ??mpu_reset_fifo_1
   1106                  return -1;
   1107              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   000032                ; Setup parameters for call to function MPU_Write_Len
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   00003B   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   00003E   70CF         JNZ     ??mpu_reset_fifo_1
   1108                  return -1;
   1109          
   1110              if (st.chip_cfg.dmp_on) {
   \   000040   90....       MOV     DPTR,#st + 29
   \   000043   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000046   6058         JZ      ??mpu_reset_fifo_3
   1111                  data = BIT_FIFO_RST | BIT_DMP_RST;
   \   000048   12....       LCALL   ?Subroutine34 & 0xFFFF
   1112                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_171:
   \   00004B   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   00004E   70BF         JNZ     ??mpu_reset_fifo_1
   1113                      return -1;
   1114                  delay_ms(50);
   \   000050                ; Setup parameters for call to function delay_ms
   \   000050   90....       MOV     DPTR,#__Constant_32
   \   000053   12....       LCALL   ?XLOAD_R2345
   \   000056   12....       LCALL   ?Subroutine63 & 0xFFFF
   1115                  data = BIT_DMP_EN | BIT_FIFO_EN;
   \                     ??CrossCallReturnLabel_90:
   \   000059   74C0         MOV     A,#-0x40
   \   00005B   F0           MOVX    @DPTR,A
   1116                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   00005C   90....       MOV     DPTR,#st + 6
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   A2E0         MOV     C,0xE0 /* A   */.0
   \   000062   5009         JNC     ??mpu_reset_fifo_4
   1117                      data |= BIT_AUX_IF_EN;
   \   000064   85..82       MOV     DPL,?XSP + 0
   \   000067   85..83       MOV     DPH,?XSP + 1
   \   00006A   74E0         MOV     A,#-0x20
   \   00006C   F0           MOVX    @DPTR,A
   1118                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??mpu_reset_fifo_4:
   \   00006D                ; Setup parameters for call to function MPU_Write_Len
   \   00006D   85..82       MOV     DPL,?XSP + 0
   \   000070   85..83       MOV     DPH,?XSP + 1
   \   000073   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   000076   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000079   7094         JNZ     ??mpu_reset_fifo_1
   1119                      return -1;
   1120                  if (st.chip_cfg.int_enable)
   \   00007B   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   00007E   6004         JZ      ??mpu_reset_fifo_5
   1121                      data = BIT_DMP_INT_EN;
   \   000080   7402         MOV     A,#0x2
   \   000082   8001         SJMP    ??mpu_reset_fifo_6
   1122                  else
   1123                      data = 0;
   \                     ??mpu_reset_fifo_5:
   \   000084   E4           CLR     A
   \                     ??mpu_reset_fifo_6:
   \   000085   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   1124                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_260:
   \   000088   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   00008B   7082         JNZ     ??mpu_reset_fifo_1
   1125                      return -1;
   1126                  data = 0;
   \   00008D   85..82       MOV     DPL,?XSP + 0
   \   000090   85..83       MOV     DPH,?XSP + 1
   \   000093   12....       LCALL   ?Subroutine33 & 0xFFFF
   1127                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   1128                      return -1;
   1129              } else {
   \                     ??CrossCallReturnLabel_221:
   \   000096   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000099   6003         JZ      $+5
   \   00009B   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   \   00009E   8065         SJMP    ??mpu_reset_fifo_7
   1130                  data = BIT_FIFO_RST;
   \                     ??mpu_reset_fifo_3:
   \   0000A0   7404         MOV     A,#0x4
   \   0000A2   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   1131                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_173:
   \   0000A5   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   0000A8   6003         JZ      $+5
   \   0000AA   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1132                      return -1;
   1133                  if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   \   0000AD   90....       MOV     DPTR,#st + 13
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   7008         JNZ     ??mpu_reset_fifo_8
   \   0000B3   90....       MOV     DPTR,#st + 6
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B9   400A         JC      ??mpu_reset_fifo_9
   1134                      data = BIT_FIFO_EN;
   \                     ??mpu_reset_fifo_8:
   \   0000BB   85..82       MOV     DPL,?XSP + 0
   \   0000BE   85..83       MOV     DPH,?XSP + 1
   \   0000C1   7440         MOV     A,#0x40
   \   0000C3   8008         SJMP    ??mpu_reset_fifo_10
   1135                  else
   1136                      data = BIT_FIFO_EN | BIT_AUX_IF_EN;
   \                     ??mpu_reset_fifo_9:
   \   0000C5   85..82       MOV     DPL,?XSP + 0
   \   0000C8   85..83       MOV     DPH,?XSP + 1
   \   0000CB   7460         MOV     A,#0x60
   \                     ??mpu_reset_fifo_10:
   \   0000CD   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   1137                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??CrossCallReturnLabel_174:
   \   0000D0   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   0000D3   6003         JZ      $+5
   \   0000D5   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1138                      return -1;
   1139                  delay_ms(50);
   \   0000D8                ; Setup parameters for call to function delay_ms
   \   0000D8   90....       MOV     DPTR,#__Constant_32
   \   0000DB   12....       LCALL   ?XLOAD_R2345
   \   0000DE   12....       LCALL   ??delay_ms?relay
   1140                  if (st.chip_cfg.int_enable)
   \   0000E1   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   0000E4   6004         JZ      ??mpu_reset_fifo_11
   1141                      data = BIT_DATA_RDY_EN;
   \   0000E6   7401         MOV     A,#0x1
   \   0000E8   8001         SJMP    ??mpu_reset_fifo_12
   1142                  else
   1143                      data = 0;
   \                     ??mpu_reset_fifo_11:
   \   0000EA   E4           CLR     A
   \                     ??mpu_reset_fifo_12:
   \   0000EB   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   1144                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_261:
   \   0000EE   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   0000F1   6003         JZ      $+5
   \   0000F3   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1145                      return -1;
   1146                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
   \   0000F6                ; Setup parameters for call to function MPU_Write_Len
   \   0000F6   7C..         MOV     R4,#(st + 11) & 0xff
   \   0000F8   7D..         MOV     R5,#((st + 11) >> 8) & 0xff
   \   0000FA   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   1147                      return -1;
   1148              }
   \                     ??CrossCallReturnLabel_224:
   \   0000FD   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000100   6003         JZ      $+5
   \   000102   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1149              return 0;
   \                     ??mpu_reset_fifo_7:
   \   000105   7A00         MOV     R2,#0x0
   \   000107   7B00         MOV     R3,#0x0
   \                     ??mpu_reset_fifo_2:
   \   000109                REQUIRE ?Subroutine10
   \   000109                ; // Fall through to label ?Subroutine10
   1150          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   7401         MOV     A,#0x1
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005   02....       LJMP    ??Subroutine121_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   740C         MOV     A,#0xc
   \   000002                REQUIRE ??Subroutine110_0
   \   000002                ; // Fall through to label ??Subroutine110_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                REQUIRE ??Subroutine111_0
   \   000001                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006                REQUIRE ??Subroutine112_0
   \   000006                ; // Fall through to label ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   90....       MOV     DPTR,#st
   \   000003   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   90....       MOV     DPTR,#st + 12
   \   000003                REQUIRE ??Subroutine118_0
   \   000003                ; // Fall through to label ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   E4           CLR     A
   \   000001                REQUIRE ??Subroutine126_0
   \   000001                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                REQUIRE ??Subroutine127_0
   \   000001                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004                REQUIRE ??Subroutine128_0
   \   000004                ; // Fall through to label ??Subroutine128_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   7B01         MOV     R3,#0x1
   \   000002   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E4           CLR     A
   \   000001                REQUIRE ??Subroutine136_0
   \   000001                ; // Fall through to label ??Subroutine136_0
   1151          
   1152          /**
   1153           *  @brief      Get the gyro full-scale range.
   1154           *  @param[out] fsr Current full-scale range.
   1155           *  @return     0 if successful.
   1156           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1157          int mpu_get_gyro_fsr(unsigned short *fsr)
   \                     mpu_get_gyro_fsr:
   1158          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1159              switch (st.chip_cfg.gyro_fsr) {
   \   000004   90....       MOV     DPTR,#st + 4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_gyro_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6013         JZ      ??mpu_get_gyro_fsr_1
   \   00000D   14           DEC     A
   \   00000E   601C         JZ      ??mpu_get_gyro_fsr_2
   \   000010   14           DEC     A
   \   000011   6025         JZ      ??mpu_get_gyro_fsr_3
   \   000013   802F         SJMP    ??mpu_get_gyro_fsr_4
   1160              case INV_FSR_250DPS:
   1161                  fsr[0] = 250;
   \                     ??mpu_get_gyro_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   74FA         MOV     A,#-0x6
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   E4           CLR     A
   \   00001E   802B         SJMP    ??mpu_get_gyro_fsr_5
   1162                  break;
   1163              case INV_FSR_500DPS:
   1164                  fsr[0] = 500;
   \                     ??mpu_get_gyro_fsr_1:
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   74F4         MOV     A,#-0xc
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   7401         MOV     A,#0x1
   \   00002A   801F         SJMP    ??mpu_get_gyro_fsr_5
   1165                  break;
   1166              case INV_FSR_1000DPS:
   1167                  fsr[0] = 1000;
   \                     ??mpu_get_gyro_fsr_2:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   74E8         MOV     A,#-0x18
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7403         MOV     A,#0x3
   \   000036   8013         SJMP    ??mpu_get_gyro_fsr_5
   1168                  break;
   1169              case INV_FSR_2000DPS:
   1170                  fsr[0] = 2000;
   \                     ??mpu_get_gyro_fsr_3:
   \   000038   8A82         MOV     DPL,R2
   \   00003A   8B83         MOV     DPH,R3
   \   00003C   74D0         MOV     A,#-0x30
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   7407         MOV     A,#0x7
   \   000042   8007         SJMP    ??mpu_get_gyro_fsr_5
   1171                  break;
   1172              default:
   1173                  fsr[0] = 0;
   \                     ??mpu_get_gyro_fsr_4:
   \   000044   8A82         MOV     DPL,R2
   \   000046   8B83         MOV     DPH,R3
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   1174                  break;
   1175              }
   \                     ??mpu_get_gyro_fsr_5:
   \   00004B   02....       LJMP    ??Subroutine119_0 & 0xFFFF
   1176              return 0;
   1177          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7A00         MOV     R2,#0x0
   \   000003                REQUIRE ??Subroutine120_0
   \   000003                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   7B00         MOV     R3,#0x0
   \   000002                REQUIRE ??Subroutine121_0
   \   000002                ; // Fall through to label ??Subroutine121_0
   1178          
   1179          /**
   1180           *  @brief      Set the gyro full-scale range.
   1181           *  @param[in]  fsr Desired full-scale range.
   1182           *  @return     0 if successful.
   1183           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1184          int mpu_set_gyro_fsr(unsigned short fsr)
   \                     mpu_set_gyro_fsr:
   1185          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1186              unsigned char data;
   1187          
   1188              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7006         JNZ     ??mpu_set_gyro_fsr_0
   1189                  return -1;
   \                     ??mpu_set_gyro_fsr_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   8060         SJMP    ??mpu_set_gyro_fsr_2
   1190          
   1191              switch (fsr) {
   \                     ??mpu_set_gyro_fsr_0:
   \   000016   8A..         MOV     ?V0 + 0,R2
   \   000018   8B..         MOV     ?V0 + 1,R3
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for mpu_set_gyro_fsr>_0`:
   \   00001F   0000         DW        0
   \   000021   0400         DW        4
   \   000023   FA00         DW        250
   \   000025   ....         DW        ??mpu_set_gyro_fsr_3
   \   000027   F401         DW        500
   \   000029   ....         DW        ??mpu_set_gyro_fsr_4
   \   00002B   E803         DW        1000
   \   00002D   ....         DW        ??mpu_set_gyro_fsr_5
   \   00002F   D007         DW        2000
   \   000031   ....         DW        ??mpu_set_gyro_fsr_6
   \   000033   ....         DW        ??mpu_set_gyro_fsr_1
   1192              case 250:
   1193                  data = INV_FSR_250DPS << 3;
   \                     ??mpu_set_gyro_fsr_3:
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   E4           CLR     A
   \   00003C   801C         SJMP    ??mpu_set_gyro_fsr_7
   1194                  break;
   1195              case 500:
   1196                  data = INV_FSR_500DPS << 3;
   \                     ??mpu_set_gyro_fsr_4:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   7408         MOV     A,#0x8
   \   000046   8012         SJMP    ??mpu_set_gyro_fsr_7
   1197                  break;
   1198              case 1000:
   1199                  data = INV_FSR_1000DPS << 3;
   \                     ??mpu_set_gyro_fsr_5:
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   7410         MOV     A,#0x10
   \   000050   8008         SJMP    ??mpu_set_gyro_fsr_7
   1200                  break;
   1201              case 2000:
   1202                  data = INV_FSR_2000DPS << 3;
   \                     ??mpu_set_gyro_fsr_6:
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   7418         MOV     A,#0x18
   \                     ??mpu_set_gyro_fsr_7:
   \   00005A   F0           MOVX    @DPTR,A
   1203                  break;
   1204              default:
   1205                  return -1;
   1206              }
   1207          
   1208              if (st.chip_cfg.gyro_fsr == (data >> 3))
   \   00005B   90....       MOV     DPTR,#st + 4
   \   00005E   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000061   600F         JZ      ??mpu_set_gyro_fsr_8
   1209                  return 0;
   1210              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
   \   000063                ; Setup parameters for call to function MPU_Write_Len
   \   000063   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000066   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   000069   70A5         JNZ     ??mpu_set_gyro_fsr_1
   1211                  return -1;
   1212              st.chip_cfg.gyro_fsr = data >> 3;
   \   00006B   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   00006E   90....       MOV     DPTR,#st + 4
   \   000071   F0           MOVX    @DPTR,A
   1213              return 0;
   \                     ??mpu_set_gyro_fsr_8:
   \   000072   7A00         MOV     R2,#0x0
   \   000074   7B00         MOV     R3,#0x0
   \                     ??mpu_set_gyro_fsr_2:
   \   000076   02....       LJMP    ?Subroutine1 & 0xFFFF
   1214          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine113_0
   \   000006                ; // Fall through to label ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000003   A2E7         MOV     C,0xE0 /* A   */.7
   \   000005   13           RRC     A
   \   000006   A2E7         MOV     C,0xE0 /* A   */.7
   \   000008   13           RRC     A
   \   000009   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000B   13           RRC     A
   \   00000C   68           XRL     A,R0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   90....       MOV     DPTR,#st
   \   000009   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET
   1215          
   1216          /**
   1217           *  @brief      Get the accel full-scale range.
   1218           *  @param[out] fsr Current full-scale range.
   1219           *  @return     0 if successful.
   1220           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1221          int mpu_get_accel_fsr(unsigned char *fsr)
   \                     mpu_get_accel_fsr:
   1222          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1223              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6024         JZ      ??mpu_get_accel_fsr_1
   \   00000D   14           DEC     A
   \   00000E   6029         JZ      ??mpu_get_accel_fsr_2
   \   000010   14           DEC     A
   \   000011   602E         JZ      ??mpu_get_accel_fsr_3
   \   000013   8034         SJMP    ??mpu_get_accel_fsr_4
   1224              case INV_FSR_2G:
   1225                  fsr[0] = 2;
   \                     ??mpu_get_accel_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   7402         MOV     A,#0x2
   \                     ??mpu_get_accel_fsr_5:
   \   00001B   F0           MOVX    @DPTR,A
   1226                  break;
   1227              case INV_FSR_4G:
   1228                  fsr[0] = 4;
   1229                  break;
   1230              case INV_FSR_8G:
   1231                  fsr[0] = 8;
   1232                  break;
   1233              case INV_FSR_16G:
   1234                  fsr[0] = 16;
   1235                  break;
   1236              default:
   1237                  return -1;
   1238              }
   1239              if (st.chip_cfg.accel_half)
   \   00001C   90....       MOV     DPTR,#st + 14
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6008         JZ      ??mpu_get_accel_fsr_6
   1240                  fsr[0] <<= 1;
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   E0           MOVX    A,@DPTR
   \   000027   C3           CLR     C
   \   000028   33           RLC     A
   \   000029   F0           MOVX    @DPTR,A
   1241              return 0;
   \                     ??mpu_get_accel_fsr_6:
   \   00002A   7A00         MOV     R2,#0x0
   \   00002C   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_fsr_7:
   \   00002E   02....       LJMP    ??Subroutine121_0 & 0xFFFF
   \                     ??mpu_get_accel_fsr_1:
   \   000031   8A82         MOV     DPL,R2
   \   000033   8B83         MOV     DPH,R3
   \   000035   7404         MOV     A,#0x4
   \   000037   80E2         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_2:
   \   000039   8A82         MOV     DPL,R2
   \   00003B   8B83         MOV     DPH,R3
   \   00003D   7408         MOV     A,#0x8
   \   00003F   80DA         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_3:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   7410         MOV     A,#0x10
   \   000047   80D2         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_4:
   \   000049   7AFF         MOV     R2,#-0x1
   \   00004B   7BFF         MOV     R3,#-0x1
   \   00004D   80DF         SJMP    ??mpu_get_accel_fsr_7
   1242          }
   1243          
   1244          /**
   1245           *  @brief      Set the accel full-scale range.
   1246           *  @param[in]  fsr Desired full-scale range.
   1247           *  @return     0 if successful.
   1248           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1249          int mpu_set_accel_fsr(unsigned char fsr)
   \                     mpu_set_accel_fsr:
   1250          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1251              unsigned char data;
   1252          
   1253              if (!(st.chip_cfg.sensors))
   \   00000C   90....       MOV     DPTR,#st + 6
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   7006         JNZ     ??mpu_set_accel_fsr_0
   1254                  return -1;
   \                     ??mpu_set_accel_fsr_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \   000016   8054         SJMP    ??mpu_set_accel_fsr_2
   1255          
   1256              switch (fsr) {
   \                     ??mpu_set_accel_fsr_0:
   \   000018   EE           MOV     A,R6
   \   000019   24FE         ADD     A,#-0x2
   \   00001B   600E         JZ      ??mpu_set_accel_fsr_3
   \   00001D   24FE         ADD     A,#-0x2
   \   00001F   6013         JZ      ??mpu_set_accel_fsr_4
   \   000021   24FC         ADD     A,#-0x4
   \   000023   6019         JZ      ??mpu_set_accel_fsr_5
   \   000025   24F8         ADD     A,#-0x8
   \   000027   601F         JZ      ??mpu_set_accel_fsr_6
   \   000029   80E7         SJMP    ??mpu_set_accel_fsr_1
   1257              case 2:
   1258                  data = INV_FSR_2G << 3;
   \                     ??mpu_set_accel_fsr_3:
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   E4           CLR     A
   \   000032   801C         SJMP    ??mpu_set_accel_fsr_7
   1259                  break;
   1260              case 4:
   1261                  data = INV_FSR_4G << 3;
   \                     ??mpu_set_accel_fsr_4:
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   7408         MOV     A,#0x8
   \   00003C   8012         SJMP    ??mpu_set_accel_fsr_7
   1262                  break;
   1263              case 8:
   1264                  data = INV_FSR_8G << 3;
   \                     ??mpu_set_accel_fsr_5:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   7410         MOV     A,#0x10
   \   000046   8008         SJMP    ??mpu_set_accel_fsr_7
   1265                  break;
   1266              case 16:
   1267                  data = INV_FSR_16G << 3;
   \                     ??mpu_set_accel_fsr_6:
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   7418         MOV     A,#0x18
   \                     ??mpu_set_accel_fsr_7:
   \   000050   F0           MOVX    @DPTR,A
   1268                  break;
   1269              default:
   1270                  return -1;
   1271              }
   1272          
   1273              if (st.chip_cfg.accel_fsr == (data >> 3))
   \   000051   90....       MOV     DPTR,#st + 5
   \   000054   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000057   600F         JZ      ??mpu_set_accel_fsr_8
   1274                  return 0;
   1275              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
   \   000059                ; Setup parameters for call to function MPU_Write_Len
   \   000059   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   00005C   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   00005F   70B1         JNZ     ??mpu_set_accel_fsr_1
   1276                  return -1;
   1277              st.chip_cfg.accel_fsr = data >> 3;
   \   000061   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   000064   90....       MOV     DPTR,#st + 5
   \   000067   F0           MOVX    @DPTR,A
   1278              return 0;
   \                     ??mpu_set_accel_fsr_8:
   \   000068   7A00         MOV     R2,#0x0
   \   00006A   7B00         MOV     R3,#0x0
   \                     ??mpu_set_accel_fsr_2:
   \   00006C   02....       LJMP    ?Subroutine0 & 0xFFFF
   1279          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
   1280          
   1281          /**
   1282           *  @brief      Get the current DLPF setting.
   1283           *  @param[out] lpf Current LPF setting.
   1284           *  0 if successful.
   1285           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1286          int mpu_get_lpf(unsigned short *lpf)
   \                     mpu_get_lpf:
   1287          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1288              switch (st.chip_cfg.lpf) {
   \   000004   90....       MOV     DPTR,#st + 7
   \   000007   E0           MOVX    A,@DPTR
   \   000008   14           DEC     A
   \   000009   6011         JZ      ??mpu_get_lpf_0
   \   00000B   14           DEC     A
   \   00000C   6019         JZ      ??mpu_get_lpf_1
   \   00000E   14           DEC     A
   \   00000F   601E         JZ      ??mpu_get_lpf_2
   \   000011   14           DEC     A
   \   000012   6023         JZ      ??mpu_get_lpf_3
   \   000014   14           DEC     A
   \   000015   6028         JZ      ??mpu_get_lpf_4
   \   000017   14           DEC     A
   \   000018   602D         JZ      ??mpu_get_lpf_5
   \   00001A   8033         SJMP    ??mpu_get_lpf_6
   1289              case INV_FILTER_188HZ:
   1290                  lpf[0] = 188;
   \                     ??mpu_get_lpf_0:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   74BC         MOV     A,#-0x44
   \                     ??mpu_get_lpf_7:
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E4           CLR     A
   \   000025   802F         SJMP    ??mpu_get_lpf_8
   1291                  break;
   1292              case INV_FILTER_98HZ:
   1293                  lpf[0] = 98;
   \                     ??mpu_get_lpf_1:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   7462         MOV     A,#0x62
   \   00002D   80F3         SJMP    ??mpu_get_lpf_7
   1294                  break;
   1295              case INV_FILTER_42HZ:
   1296                  lpf[0] = 42;
   \                     ??mpu_get_lpf_2:
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   742A         MOV     A,#0x2a
   \   000035   80EB         SJMP    ??mpu_get_lpf_7
   1297                  break;
   1298              case INV_FILTER_20HZ:
   1299                  lpf[0] = 20;
   \                     ??mpu_get_lpf_3:
   \   000037   8A82         MOV     DPL,R2
   \   000039   8B83         MOV     DPH,R3
   \   00003B   7414         MOV     A,#0x14
   \   00003D   80E3         SJMP    ??mpu_get_lpf_7
   1300                  break;
   1301              case INV_FILTER_10HZ:
   1302                  lpf[0] = 10;
   \                     ??mpu_get_lpf_4:
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   740A         MOV     A,#0xa
   \   000045   80DB         SJMP    ??mpu_get_lpf_7
   1303                  break;
   1304              case INV_FILTER_5HZ:
   1305                  lpf[0] = 5;
   \                     ??mpu_get_lpf_5:
   \   000047   8A82         MOV     DPL,R2
   \   000049   8B83         MOV     DPH,R3
   \   00004B   7405         MOV     A,#0x5
   \   00004D   80D3         SJMP    ??mpu_get_lpf_7
   1306                  break;
   1307              case INV_FILTER_256HZ_NOLPF2:
   1308              case INV_FILTER_2100HZ_NOLPF:
   1309              default:
   1310                  lpf[0] = 0;
   \                     ??mpu_get_lpf_6:
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   1311                  break;
   1312              }
   \                     ??mpu_get_lpf_8:
   \   000056   02....       LJMP    ??Subroutine119_0 & 0xFFFF
   1313              return 0;
   1314          }
   1315          
   1316          /**
   1317           *  @brief      Set digital low pass filter.
   1318           *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
   1319           *  @param[in]  lpf Desired LPF setting.
   1320           *  @return     0 if successful.
   1321           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1322          int mpu_set_lpf(unsigned short lpf)
   \                     mpu_set_lpf:
   1323          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1324              unsigned char data;
   1325          
   1326              if (!(st.chip_cfg.sensors))
   \   000009   90....       MOV     DPTR,#st + 6
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   7007         JNZ     ??mpu_set_lpf_0
   1327                  return -1;
   \                     ??mpu_set_lpf_1:
   \   00000F   7AFF         MOV     R2,#-0x1
   \   000011   7BFF         MOV     R3,#-0x1
   \   000013   02....       LJMP    ??mpu_set_lpf_2 & 0xFFFF
   1328          
   1329              if (lpf >= 188)
   \                     ??mpu_set_lpf_0:
   \   000016   C3           CLR     C
   \   000017   EA           MOV     A,R2
   \   000018   94BC         SUBB    A,#-0x44
   \   00001A   EB           MOV     A,R3
   \   00001B   9400         SUBB    A,#0x0
   \   00001D   400A         JC      ??mpu_set_lpf_3
   1330                  data = INV_FILTER_188HZ;
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   7401         MOV     A,#0x1
   \   000027   804E         SJMP    ??mpu_set_lpf_4
   1331              else if (lpf >= 98)
   \                     ??mpu_set_lpf_3:
   \   000029   C3           CLR     C
   \   00002A   EA           MOV     A,R2
   \   00002B   9462         SUBB    A,#0x62
   \   00002D   EB           MOV     A,R3
   \   00002E   9400         SUBB    A,#0x0
   \   000030   400A         JC      ??mpu_set_lpf_5
   1332                  data = INV_FILTER_98HZ;
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   7402         MOV     A,#0x2
   \   00003A   803B         SJMP    ??mpu_set_lpf_4
   1333              else if (lpf >= 42)
   \                     ??mpu_set_lpf_5:
   \   00003C   C3           CLR     C
   \   00003D   EA           MOV     A,R2
   \   00003E   942A         SUBB    A,#0x2a
   \   000040   EB           MOV     A,R3
   \   000041   9400         SUBB    A,#0x0
   \   000043   400A         JC      ??mpu_set_lpf_6
   1334                  data = INV_FILTER_42HZ;
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   7403         MOV     A,#0x3
   \   00004D   8028         SJMP    ??mpu_set_lpf_4
   1335              else if (lpf >= 20)
   \                     ??mpu_set_lpf_6:
   \   00004F   C3           CLR     C
   \   000050   EA           MOV     A,R2
   \   000051   9414         SUBB    A,#0x14
   \   000053   EB           MOV     A,R3
   \   000054   9400         SUBB    A,#0x0
   \   000056   400A         JC      ??mpu_set_lpf_7
   1336                  data = INV_FILTER_20HZ;
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   7404         MOV     A,#0x4
   \   000060   8015         SJMP    ??mpu_set_lpf_4
   1337              else if (lpf >= 10)
   \                     ??mpu_set_lpf_7:
   \   000062   C3           CLR     C
   \   000063   EA           MOV     A,R2
   \   000064   940A         SUBB    A,#0xa
   \   000066   EB           MOV     A,R3
   \   000067   9400         SUBB    A,#0x0
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   4004         JC      ??mpu_set_lpf_8
   1338                  data = INV_FILTER_10HZ;
   \   000071   7405         MOV     A,#0x5
   \   000073   8002         SJMP    ??mpu_set_lpf_4
   1339              else
   1340                  data = INV_FILTER_5HZ;
   \                     ??mpu_set_lpf_8:
   \   000075   7406         MOV     A,#0x6
   \                     ??mpu_set_lpf_4:
   \   000077   F0           MOVX    @DPTR,A
   1341          
   1342              if (st.chip_cfg.lpf == data)
   \   000078   90....       MOV     DPTR,#st + 7
   \   00007B   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00007E   68           XRL     A,R0
   \   00007F   6013         JZ      ??mpu_set_lpf_9
   1343                  return 0;
   1344              if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
   \   000081                ; Setup parameters for call to function MPU_Write_Len
   \   000081   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000084   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000087   7086         JNZ     ??mpu_set_lpf_1
   1345                  return -1;
   1346              st.chip_cfg.lpf = data;
   \   000089   85..82       MOV     DPL,?XSP + 0
   \   00008C   85..83       MOV     DPH,?XSP + 1
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   90....       MOV     DPTR,#st + 7
   \   000093   F0           MOVX    @DPTR,A
   1347              return 0;
   \                     ??mpu_set_lpf_9:
   \   000094   7A00         MOV     R2,#0x0
   \   000096   7B00         MOV     R3,#0x0
   \                     ??mpu_set_lpf_2:
   \   000098   02....       LJMP    ?Subroutine10 & 0xFFFF
   1348          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000003   22           RET
   1349          
   1350          /**
   1351           *  @brief      Get sampling rate.
   1352           *  @param[out] rate    Current sampling rate (Hz).
   1353           *  @return     0 if successful.
   1354           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1355          int mpu_get_sample_rate(unsigned short *rate)
   \                     mpu_get_sample_rate:
   1356          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1357              if (st.chip_cfg.dmp_on)
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6006         JZ      ??mpu_get_sample_rate_0
   1358                  return -1;
   \   00000A   7AFF         MOV     R2,#-0x1
   \   00000C   7BFF         MOV     R3,#-0x1
   \   00000E   8010         SJMP    ??CrossCallReturnLabel_251
   1359              else
   1360                  rate[0] = st.chip_cfg.sample_rate;
   \                     ??mpu_get_sample_rate_0:
   \   000010   90....       MOV     DPTR,#st + 9
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   E8           MOV     A,R0
   \   00001D   12....       LCALL   ?Subroutine58 & 0xFFFF
   1361              return 0;
   \                     ??CrossCallReturnLabel_251:
   \   000020   02....       LJMP    ??Subroutine121_0 & 0xFFFF
   1362          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003                REQUIRE ??Subroutine135_0
   \   000003                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7A00         MOV     R2,#0x0
   \   000003   7B00         MOV     R3,#0x0
   \   000005   22           RET
   1363          
   1364          /**
   1365           *  @brief      Set sampling rate.
   1366           *  Sampling rate must be between 4Hz and 1kHz.
   1367           *  @param[in]  rate    Desired sampling rate (Hz).
   1368           *  @return     0 if successful.
   1369           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1370          int mpu_set_sample_rate(unsigned short rate)
   \                     mpu_set_sample_rate:
   1371          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1372              unsigned char data;
   1373          
   1374              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_set_sample_rate_0
   1375                  return -1;
   \                     ??mpu_set_sample_rate_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_set_sample_rate_2 & 0xFFFF
   1376          
   1377              if (st.chip_cfg.dmp_on)
   \                     ??mpu_set_sample_rate_0:
   \   00001B   90....       MOV     DPTR,#st + 29
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   70F3         JNZ     ??mpu_set_sample_rate_1
   1378                  return -1;
   1379              else {
   1380                  if (st.chip_cfg.lp_accel_mode) {
   \   000021   90....       MOV     DPTR,#st + 15
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6019         JZ      ??mpu_set_sample_rate_3
   1381                      if (rate && (rate <= 40)) {
   \   000027   EE           MOV     A,R6
   \   000028   4F           ORL     A,R7
   \   000029   6010         JZ      ??mpu_set_sample_rate_4
   \   00002B   C3           CLR     C
   \   00002C   EE           MOV     A,R6
   \   00002D   9429         SUBB    A,#0x29
   \   00002F   EF           MOV     A,R7
   \   000030   9400         SUBB    A,#0x0
   \   000032   5007         JNC     ??mpu_set_sample_rate_4
   1382                          /* Just stay in low-power accel mode. */
   1383                          mpu_lp_accel_mode(rate);
   \   000034                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000034   EE           MOV     A,R6
   \   000035   F9           MOV     R1,A
   \   000036   12....       LCALL   ??mpu_lp_accel_mode?relay
   1384                          return 0;
   \   000039   8062         SJMP    ??mpu_set_sample_rate_5
   1385                      }
   1386                      /* Requested rate exceeds the allowed frequencies in LP accel mode,
   1387                       * switch back to full-power mode.
   1388                       */
   1389                      mpu_lp_accel_mode(0);
   \                     ??mpu_set_sample_rate_4:
   \   00003B                ; Setup parameters for call to function mpu_lp_accel_mode
   \   00003B   7900         MOV     R1,#0x0
   \   00003D   12....       LCALL   ??mpu_lp_accel_mode?relay
   1390                  }
   1391                  if (rate < 4)
   \                     ??mpu_set_sample_rate_3:
   \   000040   C3           CLR     C
   \   000041   EE           MOV     A,R6
   \   000042   9404         SUBB    A,#0x4
   \   000044   EF           MOV     A,R7
   \   000045   9400         SUBB    A,#0x0
   \   000047   5006         JNC     ??mpu_set_sample_rate_6
   1392                      rate = 4;
   \   000049   7E04         MOV     R6,#0x4
   \   00004B   7F00         MOV     R7,#0x0
   \   00004D   800D         SJMP    ??mpu_set_sample_rate_7
   1393                  else if (rate > 1000)
   \                     ??mpu_set_sample_rate_6:
   \   00004F   C3           CLR     C
   \   000050   EE           MOV     A,R6
   \   000051   94E9         SUBB    A,#-0x17
   \   000053   EF           MOV     A,R7
   \   000054   9403         SUBB    A,#0x3
   \   000056   4004         JC      ??mpu_set_sample_rate_7
   1394                      rate = 1000;
   \   000058   7EE8         MOV     R6,#-0x18
   \   00005A   7F03         MOV     R7,#0x3
   1395          
   1396                  data = 1000 / rate - 1;
   \                     ??mpu_set_sample_rate_7:
   \   00005C   78E8         MOV     R0,#-0x18
   \   00005E   7903         MOV     R1,#0x3
   \   000060   EE           MOV     A,R6
   \   000061   FA           MOV     R2,A
   \   000062   EF           MOV     A,R7
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   ?US_DIV_MOD
   \   000067   E8           MOV     A,R0
   \   000068   14           DEC     A
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   12....       LCALL   ?Subroutine36 & 0xFFFF
   1397                  if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
   \                     ??CrossCallReturnLabel_210:
   \   000072   A3           INC     DPTR
   \   000073   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   000076   709C         JNZ     ??mpu_set_sample_rate_1
   1398                      return -1;
   1399          
   1400                  st.chip_cfg.sample_rate = 1000 / (1 + data);
   \   000078   78E8         MOV     R0,#-0x18
   \   00007A   7903         MOV     R1,#0x3
   \   00007C   85..82       MOV     DPL,?XSP + 0
   \   00007F   85..83       MOV     DPH,?XSP + 1
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2401         ADD     A,#0x1
   \   000085   FA           MOV     R2,A
   \   000086   E4           CLR     A
   \   000087   3400         ADDC    A,#0x0
   \   000089   FB           MOV     R3,A
   \   00008A   12....       LCALL   ?S_DIV_MOD
   \   00008D   90....       MOV     DPTR,#st + 9
   \   000090   12....       LCALL   ?Subroutine59 & 0xFFFF
   1401          
   1402          #ifdef AK89xx_SECONDARY
   1403                  mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
   1404          #endif
   1405          
   1406                  /* Automatically set LPF to 1/2 sampling rate. */
   1407                  mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
   \                     ??CrossCallReturnLabel_167:
   \   000093                ; Setup parameters for call to function mpu_set_lpf
   \   000093   90....       MOV     DPTR,#st + 9
   \   000096   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000099   FA           MOV     R2,A
   \   00009A   12....       LCALL   ??mpu_set_lpf?relay
   1408                  return 0;
   \                     ??mpu_set_sample_rate_5:
   \   00009D   7A00         MOV     R2,#0x0
   \   00009F   7B00         MOV     R3,#0x0
   1409              }
   \                     ??mpu_set_sample_rate_2:
   \   0000A1   02....       LJMP    ?Subroutine0 & 0xFFFF
   1410          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C3           CLR     C
   \   000005   13           RRC     A
   \   000006   FB           MOV     R3,A
   \   000007   EA           MOV     A,R2
   \   000008   13           RRC     A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000003                REQUIRE ??Subroutine124_0
   \   000003                ; // Fall through to label ??Subroutine124_0
   1411          
   1412          /**
   1413           *  @brief      Get compass sampling rate.
   1414           *  @param[out] rate    Current compass sampling rate (Hz).
   1415           *  @return     0 if successful.
   1416           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1417          int mpu_get_compass_sample_rate(unsigned short *rate)
   \                     mpu_get_compass_sample_rate:
   1418          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1419          #ifdef AK89xx_SECONDARY
   1420              rate[0] = st.chip_cfg.compass_sample_rate;
   1421              return 0;
   1422          #else
   1423              rate[0] = 0;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   F0           MOVX    @DPTR,A
   1424              return -1;
   \   00000C   7AFF         MOV     R2,#-0x1
   \   00000E   7BFF         MOV     R3,#-0x1
   \   000010   02....       LJMP    ??Subroutine121_0 & 0xFFFF
   1425          #endif
   1426          }
   1427          
   1428          /**
   1429           *  @brief      Set compass sampling rate.
   1430           *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
   1431           *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
   1432           *  sampling rate.
   1433           *
   1434           *  \n WARNING: The new rate may be different than what was requested. Call
   1435           *  mpu_get_compass_sample_rate to check the actual setting.
   1436           *  @param[in]  rate    Desired compass sampling rate (Hz).
   1437           *  @return     0 if successful.
   1438           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1439          int mpu_set_compass_sample_rate(unsigned short rate)
   \                     mpu_set_compass_sample_rate:
   1440          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1441          #ifdef AK89xx_SECONDARY
   1442              unsigned char div;
   1443              if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
   1444                  return -1;
   1445          
   1446              div = st.chip_cfg.sample_rate / rate - 1;
   1447              if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
   1448                  return -1;
   1449              st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
   1450              return 0;
   1451          #else
   1452              return -1;
   \   000000   02....       LJMP    ?Subroutine4 & 0xFFFF
   1453          #endif
   1454          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7AFF         MOV     R2,#-0x1
   \   000002   7BFF         MOV     R3,#-0x1
   \   000004   02....       LJMP    ?BRET
   1455          
   1456          /**
   1457           *  @brief      Get gyro sensitivity scale factor.
   1458           *  @param[out] sens    Conversion from hardware units to dps.
   1459           *  @return     0 if successful.
   1460           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1461          int mpu_get_gyro_sens(float *sens)
   \                     mpu_get_gyro_sens:
   1462          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   1463              switch (st.chip_cfg.gyro_fsr) {
   \   000009   90....       MOV     DPTR,#st + 4
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   600B         JZ      ??mpu_get_gyro_sens_0
   \   00000F   14           DEC     A
   \   000010   601C         JZ      ??mpu_get_gyro_sens_1
   \   000012   14           DEC     A
   \   000013   601E         JZ      ??mpu_get_gyro_sens_2
   \   000015   14           DEC     A
   \   000016   6020         JZ      ??mpu_get_gyro_sens_3
   \   000018   8023         SJMP    ??mpu_get_gyro_sens_4
   1464              case INV_FSR_250DPS:
   1465                  sens[0] = 131.f;
   \                     ??mpu_get_gyro_sens_0:
   \   00001A   90....       MOV     DPTR,#__Constant_43030000
   \                     ??mpu_get_gyro_sens_5:
   \   00001D   12....       LCALL   ?XLOAD_R2345
   \   000020   8882         MOV     DPL,R0
   \   000022   8983         MOV     DPH,R1
   \   000024   12....       LCALL   ?XSTORE_R2345
   1466                  break;
   1467              case INV_FSR_500DPS:
   1468                  sens[0] = 65.5f;
   1469                  break;
   1470              case INV_FSR_1000DPS:
   1471                  sens[0] = 32.8f;
   1472                  break;
   1473              case INV_FSR_2000DPS:
   1474                  sens[0] = 16.4f;
   1475                  break;
   1476              default:
   1477                  return -1;
   1478              }
   1479              return 0;
   \   000027   7A00         MOV     R2,#0x0
   \   000029   7B00         MOV     R3,#0x0
   \                     ??mpu_get_gyro_sens_6:
   \   00002B   02....       LJMP    ??Subroutine106_0 & 0xFFFF
   \                     ??mpu_get_gyro_sens_1:
   \   00002E   90....       MOV     DPTR,#__Constant_42830000
   \   000031   80EA         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_2:
   \   000033   90....       MOV     DPTR,#__Constant_42033333
   \   000036   80E5         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_3:
   \   000038   90....       MOV     DPTR,#__Constant_41833333
   \   00003B   80E0         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_4:
   \   00003D   7AFF         MOV     R2,#-0x1
   \   00003F   7BFF         MOV     R3,#-0x1
   \   000041   80E8         SJMP    ??mpu_get_gyro_sens_6
   1480          }
   1481          
   1482          /**
   1483           *  @brief      Get accel sensitivity scale factor.
   1484           *  @param[out] sens    Conversion from hardware units to g's.
   1485           *  @return     0 if successful.
   1486           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1487          int mpu_get_accel_sens(unsigned short *sens)
   \                     mpu_get_accel_sens:
   1488          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1489              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_sens_0
   \   00000A   14           DEC     A
   \   00000B   6033         JZ      ??mpu_get_accel_sens_1
   \   00000D   14           DEC     A
   \   00000E   603C         JZ      ??mpu_get_accel_sens_2
   \   000010   14           DEC     A
   \   000011   6044         JZ      ??mpu_get_accel_sens_3
   \   000013   804D         SJMP    ??mpu_get_accel_sens_4
   1490              case INV_FSR_2G:
   1491                  sens[0] = 16384;
   \                     ??mpu_get_accel_sens_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7440         MOV     A,#0x40
   \                     ??mpu_get_accel_sens_5:
   \   00001E   F0           MOVX    @DPTR,A
   1492                  break;
   1493              case INV_FSR_4G:
   1494                  sens[0] = 8092;
   1495                  break;
   1496              case INV_FSR_8G:
   1497                  sens[0] = 4096;
   1498                  break;
   1499              case INV_FSR_16G:
   1500                  sens[0] = 2048;
   1501                  break;
   1502              default:
   1503                  return -1;
   1504              }
   1505              if (st.chip_cfg.accel_half)
   \   00001F   90....       MOV     DPTR,#st + 14
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6014         JZ      ??CrossCallReturnLabel_162
   1506                  sens[0] >>= 1;
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   C3           CLR     C
   \   00002E   13           RRC     A
   \   00002F   F9           MOV     R1,A
   \   000030   E8           MOV     A,R0
   \   000031   13           RRC     A
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   1507              return 0;
   \                     ??CrossCallReturnLabel_162:
   \   000039   7A00         MOV     R2,#0x0
   \   00003B   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_sens_6:
   \   00003D   02....       LJMP    ??Subroutine121_0 & 0xFFFF
   \                     ??mpu_get_accel_sens_1:
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   749C         MOV     A,#-0x64
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   741F         MOV     A,#0x1f
   \   00004A   80D2         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_2:
   \   00004C   8A82         MOV     DPL,R2
   \   00004E   8B83         MOV     DPH,R3
   \   000050   E4           CLR     A
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   7410         MOV     A,#0x10
   \   000055   80C7         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_3:
   \   000057   8A82         MOV     DPL,R2
   \   000059   8B83         MOV     DPH,R3
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   7408         MOV     A,#0x8
   \   000060   80BC         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_4:
   \   000062   7AFF         MOV     R2,#-0x1
   \   000064   7BFF         MOV     R3,#-0x1
   \   000066   80D5         SJMP    ??mpu_get_accel_sens_6
   1508          }
   1509          
   1510          /**
   1511           *  @brief      Get current FIFO configuration.
   1512           *  @e sensors can contain a combination of the following flags:
   1513           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1514           *  \n INV_XYZ_GYRO
   1515           *  \n INV_XYZ_ACCEL
   1516           *  @param[out] sensors Mask of sensors in FIFO.
   1517           *  @return     0 if successful.
   1518           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1519          int mpu_get_fifo_config(unsigned char *sensors)
   \                     mpu_get_fifo_config:
   1520          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1521              sensors[0] = st.chip_cfg.fifo_enable;
   \   000004   90....       MOV     DPTR,#st + 11
   \   000007   02....       LJMP    ?Subroutine3 & 0xFFFF
   1522              return 0;
   1523          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005                REQUIRE ??Subroutine119_0
   \   000005                ; // Fall through to label ??Subroutine119_0
   1524          
   1525          /**
   1526           *  @brief      Select which sensors are pushed to FIFO.
   1527           *  @e sensors can contain a combination of the following flags:
   1528           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1529           *  \n INV_XYZ_GYRO
   1530           *  \n INV_XYZ_ACCEL
   1531           *  @param[in]  sensors Mask of sensors to push to FIFO.
   1532           *  @return     0 if successful.
   1533           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1534          int mpu_configure_fifo(unsigned char sensors)
   \                     mpu_configure_fifo:
   1535          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1536              unsigned char prev;
   1537              int result = 0;
   1538          
   1539              /* Compass data isn't going into the FIFO. Stop trying. */
   1540              sensors &= ~INV_XYZ_COMPASS;
   \   000005   E9           MOV     A,R1
   \   000006   C2E0         CLR     0xE0 /* A   */.0
   \   000008   F5..         MOV     ?V0 + 0,A
   1541          
   1542              if (st.chip_cfg.dmp_on)
   \   00000A   90....       MOV     DPTR,#st + 29
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6006         JZ      ??mpu_configure_fifo_0
   1543                  return 0;
   \   000010   7A00         MOV     R2,#0x0
   \   000012   7B00         MOV     R3,#0x0
   \   000014   803E         SJMP    ??mpu_configure_fifo_1
   1544              else {
   1545                  if (!(st.chip_cfg.sensors))
   \                     ??mpu_configure_fifo_0:
   \   000016   90....       MOV     DPTR,#st + 6
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F8           MOV     R0,A
   \   00001B   7006         JNZ     ??mpu_configure_fifo_2
   1546                      return -1;
   \                     ??mpu_configure_fifo_3:
   \   00001D   7AFF         MOV     R2,#-0x1
   \   00001F   7BFF         MOV     R3,#-0x1
   \   000021   8031         SJMP    ??mpu_configure_fifo_1
   1547                  prev = st.chip_cfg.fifo_enable;
   \                     ??mpu_configure_fifo_2:
   \   000023   90....       MOV     DPTR,#st + 11
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F5..         MOV     ?V0 + 1,A
   1548                  st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
   \   000029   E5..         MOV     A,?V0 + 0
   \   00002B   58           ANL     A,R0
   \   00002C   F8           MOV     R0,A
   \   00002D   F0           MOVX    @DPTR,A
   1549                  if (st.chip_cfg.fifo_enable != sensors)
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   68           XRL     A,R0
   \   000031   6006         JZ      ??mpu_configure_fifo_4
   1550                      /* You're not getting what you asked for. Some sensors are
   1551                       * asleep.
   1552                       */
   1553                      result = -1;
   \   000033   7EFF         MOV     R6,#-0x1
   \   000035   7FFF         MOV     R7,#-0x1
   \   000037   8004         SJMP    ??mpu_configure_fifo_5
   1554                  else
   1555                      result = 0;
   \                     ??mpu_configure_fifo_4:
   \   000039   7E00         MOV     R6,#0x0
   \   00003B   7F00         MOV     R7,#0x0
   1556                  if (sensors || st.chip_cfg.lp_accel_mode)
   \                     ??mpu_configure_fifo_5:
   \   00003D   E5..         MOV     A,?V0 + 0
   \   00003F   7006         JNZ     ??mpu_configure_fifo_6
   \   000041   90....       MOV     DPTR,#st + 15
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6010         JZ      ??mpu_configure_fifo_7
   1557                      set_int_enable(1);
   \                     ??mpu_configure_fifo_6:
   \   000047                ; Setup parameters for call to function set_int_enable
   \   000047   7901         MOV     R1,#0x1
   \   000049   12....       LCALL   ??set_int_enable?relay
   1558                  else
   1559                      set_int_enable(0);
   1560                  if (sensors) {
   \   00004C   E5..         MOV     A,?V0 + 0
   \   00004E   700E         JNZ     ??mpu_configure_fifo_8
   1561                      if (mpu_reset_fifo()) {
   1562                          st.chip_cfg.fifo_enable = prev;
   1563                          return -1;
   1564                      }
   1565                  }
   1566              }
   1567          
   1568              return result;
   \                     ??mpu_configure_fifo_9:
   \   000050   EE           MOV     A,R6
   \   000051   FA           MOV     R2,A
   \   000052   EF           MOV     A,R7
   \   000053   FB           MOV     R3,A
   \                     ??mpu_configure_fifo_1:
   \   000054   02....       LJMP    ??Subroutine134_0 & 0xFFFF
   \                     ??mpu_configure_fifo_7:
   \   000057                ; Setup parameters for call to function set_int_enable
   \   000057   7900         MOV     R1,#0x0
   \   000059   12....       LCALL   ??set_int_enable?relay
   \   00005C   80F2         SJMP    ??mpu_configure_fifo_9
   \                     ??mpu_configure_fifo_8:
   \   00005E                ; Setup parameters for call to function mpu_reset_fifo
   \   00005E   12....       LCALL   ??mpu_reset_fifo?relay
   \   000061   8B..         MOV     ?V0 + 3,R3
   \   000063   EA           MOV     A,R2
   \   000064   45..         ORL     A,?V0 + 3
   \   000066   60E8         JZ      ??mpu_configure_fifo_9
   \   000068   E5..         MOV     A,?V0 + 1
   \   00006A   90....       MOV     DPTR,#st + 11
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   80AD         SJMP    ??mpu_configure_fifo_3
   1569          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1570          
   1571          /**
   1572           *  @brief      Get current power state.
   1573           *  @param[in]  power_on    1 if turned on, 0 if suspended.
   1574           *  @return     0 if successful.
   1575           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1576          int mpu_get_power_state(unsigned char *power_on)
   \                     mpu_get_power_state:
   1577          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1578              if (st.chip_cfg.sensors)
   \   000004   90....       MOV     DPTR,#st + 6
   \   000007   E0           MOVX    A,@DPTR
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   6004         JZ      ??mpu_get_power_state_0
   1579                  power_on[0] = 1;
   \   00000E   7401         MOV     A,#0x1
   \   000010   8001         SJMP    ??mpu_get_power_state_1
   1580              else
   1581                  power_on[0] = 0;
   \                     ??mpu_get_power_state_0:
   \   000012   E4           CLR     A
   \                     ??mpu_get_power_state_1:
   \   000013   02....       LJMP    ??Subroutine119_0 & 0xFFFF
   1582              return 0;
   1583          }
   1584          
   1585          /**
   1586           *  @brief      Turn specific sensors on/off.
   1587           *  @e sensors can contain a combination of the following flags:
   1588           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1589           *  \n INV_XYZ_GYRO
   1590           *  \n INV_XYZ_ACCEL
   1591           *  \n INV_XYZ_COMPASS
   1592           *  @param[in]  sensors    Mask of sensors to wake.
   1593           *  @return     0 if successful.
   1594           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1595          int mpu_set_sensors(unsigned char sensors)
   \                     mpu_set_sensors:
   1596          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1597              unsigned char data;
   1598          #ifdef AK89xx_SECONDARY
   1599              unsigned char user_ctrl;
   1600          #endif
   1601          
   1602              if (sensors & INV_XYZ_GYRO)
   \   00000C   7470         MOV     A,#0x70
   \   00000E   5E           ANL     A,R6
   \   00000F   600A         JZ      ??mpu_set_sensors_0
   1603                  data = INV_CLK_PLL;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7401         MOV     A,#0x1
   \   000019   800E         SJMP    ??mpu_set_sensors_1
   1604              else if (sensors)
   \                     ??mpu_set_sensors_0:
   \   00001B   EE           MOV     A,R6
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   6003         JZ      ??mpu_set_sensors_2
   1605                  data = 0;
   \   000024   E4           CLR     A
   \   000025   8002         SJMP    ??mpu_set_sensors_1
   1606              else
   1607                  data = BIT_SLEEP;
   \                     ??mpu_set_sensors_2:
   \   000027   7440         MOV     A,#0x40
   \                     ??mpu_set_sensors_1:
   \   000029   12....       LCALL   ?Subroutine57 & 0xFFFF
   1608              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
   \                     ??CrossCallReturnLabel_82:
   \   00002C   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   00002F   600B         JZ      ??mpu_set_sensors_3
   1609                  st.chip_cfg.sensors = 0;
   \                     ??mpu_set_sensors_4:
   \   000031   90....       MOV     DPTR,#st + 6
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   1610                  return -1;
   \   000036   7AFF         MOV     R2,#-0x1
   \   000038   7BFF         MOV     R3,#-0x1
   \   00003A   8069         SJMP    ??mpu_set_sensors_5
   1611              }
   1612              st.chip_cfg.clk_src = data & ~BIT_SLEEP;
   \                     ??mpu_set_sensors_3:
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   E0           MOVX    A,@DPTR
   \   000043   54BF         ANL     A,#0xbf
   \   000045   90....       MOV     DPTR,#st + 8
   \   000048   12....       LCALL   ?Subroutine92 & 0xFFFF
   1613          
   1614              data = 0;
   \                     ??CrossCallReturnLabel_268:
   \   00004B   E4           CLR     A
   \   00004C   F0           MOVX    @DPTR,A
   1615              if (!(sensors & INV_X_GYRO))
   \   00004D   EE           MOV     A,R6
   \   00004E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000050   4003         JC      ??mpu_set_sensors_6
   1616                  data |= BIT_STBY_XG;
   \   000052   7404         MOV     A,#0x4
   \   000054   F0           MOVX    @DPTR,A
   1617              if (!(sensors & INV_Y_GYRO))
   \                     ??mpu_set_sensors_6:
   \   000055   EE           MOV     A,R6
   \   000056   A2E5         MOV     C,0xE0 /* A   */.5
   \   000058   4004         JC      ??mpu_set_sensors_7
   1618                  data |= BIT_STBY_YG;
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   D2E1         SETB    0xE0 /* A   */.1
   \   00005D   F0           MOVX    @DPTR,A
   1619              if (!(sensors & INV_Z_GYRO))
   \                     ??mpu_set_sensors_7:
   \   00005E   EE           MOV     A,R6
   \   00005F   A2E4         MOV     C,0xE0 /* A   */.4
   \   000061   4004         JC      ??mpu_set_sensors_8
   1620                  data |= BIT_STBY_ZG;
   \   000063   E0           MOVX    A,@DPTR
   \   000064   D2E0         SETB    0xE0 /* A   */.0
   \   000066   F0           MOVX    @DPTR,A
   1621              if (!(sensors & INV_XYZ_ACCEL))
   \                     ??mpu_set_sensors_8:
   \   000067   EE           MOV     A,R6
   \   000068   A2E3         MOV     C,0xE0 /* A   */.3
   \   00006A   4004         JC      ??mpu_set_sensors_9
   1622                  data |= BIT_STBY_XYZA;
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   4438         ORL     A,#0x38
   \   00006F   F0           MOVX    @DPTR,A
   1623              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
   \                     ??mpu_set_sensors_9:
   \   000070                ; Setup parameters for call to function MPU_Write_Len
   \   000070   AC82         MOV     R4,DPL
   \   000072   AD83         MOV     R5,DPH
   \   000074   7B01         MOV     R3,#0x1
   \   000076   90....       MOV     DPTR,#st
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   2413         ADD     A,#0x13
   \   00007C   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   00007F   70B0         JNZ     ??mpu_set_sensors_4
   1624                  st.chip_cfg.sensors = 0;
   1625                  return -1;
   1626              }
   1627          
   1628              if (sensors && (sensors != INV_XYZ_ACCEL))
   \   000081   EE           MOV     A,R6
   \   000082   600A         JZ      ??mpu_set_sensors_10
   \   000084   7408         MOV     A,#0x8
   \   000086   6E           XRL     A,R6
   \   000087   6005         JZ      ??mpu_set_sensors_10
   1629                  /* Latched interrupts only used in LP accel mode. */
   1630                  mpu_set_int_latched(0);
   \   000089                ; Setup parameters for call to function mpu_set_int_latched
   \   000089   7900         MOV     R1,#0x0
   \   00008B   12....       LCALL   ??mpu_set_int_latched?relay
   1631          
   1632          #ifdef AK89xx_SECONDARY
   1633          #ifdef AK89xx_BYPASS
   1634              if (sensors & INV_XYZ_COMPASS)
   1635                  mpu_set_bypass(1);
   1636              else
   1637                  mpu_set_bypass(0);
   1638          #else
   1639              if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1640                  return -1;
   1641              /* Handle AKM power management. */
   1642              if (sensors & INV_XYZ_COMPASS) {
   1643                  data = AKM_SINGLE_MEASUREMENT;
   1644                  user_ctrl |= BIT_AUX_IF_EN;
   1645              } else {
   1646                  data = AKM_POWER_DOWN;
   1647                  user_ctrl &= ~BIT_AUX_IF_EN;
   1648              }
   1649              if (st.chip_cfg.dmp_on)
   1650                  user_ctrl |= BIT_DMP_EN;
   1651              else
   1652                  user_ctrl &= ~BIT_DMP_EN;
   1653              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
   1654                  return -1;
   1655              /* Enable/disable I2C master mode. */
   1656              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1657                  return -1;
   1658          #endif
   1659          #endif
   1660          
   1661              st.chip_cfg.sensors = sensors;
   \                     ??mpu_set_sensors_10:
   \   00008E   EE           MOV     A,R6
   \   00008F   90....       MOV     DPTR,#st + 6
   \   000092   F0           MOVX    @DPTR,A
   1662              st.chip_cfg.lp_accel_mode = 0;
   \   000093   90....       MOV     DPTR,#st + 15
   \   000096   E4           CLR     A
   \   000097   F0           MOVX    @DPTR,A
   1663              delay_ms(50);
   \   000098                ; Setup parameters for call to function delay_ms
   \   000098   90....       MOV     DPTR,#__Constant_32
   \   00009B   12....       LCALL   ?XLOAD_R2345
   \   00009E   12....       LCALL   ??delay_ms?relay
   1664              return 0;
   \   0000A1   7A00         MOV     R2,#0x0
   \   0000A3   7B00         MOV     R3,#0x0
   \                     ??mpu_set_sensors_5:
   \   0000A5   02....       LJMP    ?Subroutine0 & 0xFFFF
   1665          }
   1666          
   1667          /**
   1668           *  @brief      Read the MPU interrupt status registers.
   1669           *  @param[out] status  Mask of interrupt bits.
   1670           *  @return     0 if successful.
   1671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1672          int mpu_get_int_status(short *status)
   \                     mpu_get_int_status:
   1673          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1674              unsigned char tmp[2];
   1675              if (!st.chip_cfg.sensors)
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7006         JNZ     ??mpu_get_int_status_0
   1676                  return -1;
   \                     ??mpu_get_int_status_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   8023         SJMP    ??CrossCallReturnLabel_252
   1677              if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
   \                     ??mpu_get_int_status_0:
   \   00001A                ; Setup parameters for call to function MPU_Read_Len
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   AC82         MOV     R4,DPL
   \   000022   AD83         MOV     R5,DPH
   \   000024   7B02         MOV     R3,#0x2
   \   000026   90....       MOV     DPTR,#st
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   2410         ADD     A,#0x10
   \   00002C   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   00002F   70E3         JNZ     ??mpu_get_int_status_1
   1678                  return -1;
   1679              status[0] = (tmp[0] << 8) | tmp[1];
   \   000031   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   00003A   12....       LCALL   ?Subroutine58 & 0xFFFF
   1680              return 0;
   \                     ??CrossCallReturnLabel_252:
   \   00003D   02....       LJMP    ?Subroutine8 & 0xFFFF
   1681          }
   1682          
   1683          /**
   1684           *  @brief      Get one packet from the FIFO.
   1685           *  If @e sensors does not contain a particular sensor, disregard the data
   1686           *  returned to that pointer.
   1687           *  \n @e sensors can contain a combination of the following flags:
   1688           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1689           *  \n INV_XYZ_GYRO
   1690           *  \n INV_XYZ_ACCEL
   1691           *  \n If the FIFO has no new data, @e sensors will be zero.
   1692           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
   1693           *  return a non-zero error code.
   1694           *  @param[out] gyro        Gyro data in hardware units.
   1695           *  @param[out] accel       Accel data in hardware units.
   1696           *  @param[out] timestamp   Timestamp in milliseconds.
   1697           *  @param[out] sensors     Mask of sensors read from FIFO.
   1698           *  @param[out] more        Number of remaining packets.
   1699           *  @return     0 if successful.
   1700           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   90....       MOV     DPTR,#st
   \   000003   E0           MOVX    A,@DPTR
   \   000004   240B         ADD     A,#0xb
   \   000006                REQUIRE ??Subroutine107_0
   \   000006                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1701          int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
   \                     mpu_read_fifo:
   1702                  unsigned char *sensors, unsigned char *more)
   1703          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 10,R2
   \   00000C   8B..         MOV     ?V0 + 11,R3
   \   00000E   8C..         MOV     ?V0 + 8,R4
   \   000010   8D..         MOV     ?V0 + 9,R5
   \   000012   7426         MOV     A,#0x26
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 6,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 7,A
   \   00001E   7428         MOV     A,#0x28
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 12,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F5..         MOV     ?V0 + 13,A
   1704              /* Assumes maximum packet size is gyro (6) + accel (6). */
   1705              unsigned char data[MAX_PACKET_LENGTH];
   1706              unsigned char packet_size = 0;
   \   00002A   75..00       MOV     ?V0 + 2,#0x0
   1707              unsigned short fifo_count, index = 0;
   \   00002D   7E00         MOV     R6,#0x0
   \   00002F   7F00         MOV     R7,#0x0
   1708          
   1709              if (st.chip_cfg.dmp_on)
   \   000031   90....       MOV     DPTR,#st + 29
   \   000034   E0           MOVX    A,@DPTR
   \   000035   6009         JZ      ??mpu_read_fifo_0
   1710                  return -1;
   \                     ??mpu_read_fifo_1:
   \   000037   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_2:
   \   000039   7BFF         MOV     R3,#-0x1
   \                     ??mpu_read_fifo_3:
   \   00003B   740C         MOV     A,#0xc
   \   00003D   02....       LJMP    ?Subroutine6 & 0xFFFF
   1711          
   1712              sensors[0] = 0;
   \                     ??mpu_read_fifo_0:
   \   000040   85..82       MOV     DPL,?V0 + 6
   \   000043   85..83       MOV     DPH,?V0 + 7
   \   000046   E4           CLR     A
   \   000047   F0           MOVX    @DPTR,A
   1713              if (!st.chip_cfg.sensors)
   \   000048   90....       MOV     DPTR,#st + 6
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   60E9         JZ      ??mpu_read_fifo_1
   1714                  return -1;
   1715              if (!st.chip_cfg.fifo_enable)
   \   00004E   90....       MOV     DPTR,#st + 11
   \   000051   E0           MOVX    A,@DPTR
   \   000052   60E3         JZ      ??mpu_read_fifo_1
   1716                  return -1;
   1717          
   1718              if (st.chip_cfg.fifo_enable & INV_X_GYRO)
   \   000054   A2E6         MOV     C,0xE0 /* A   */.6
   \   000056   5003         JNC     ??mpu_read_fifo_4
   1719                  packet_size += 2;
   \   000058   75..02       MOV     ?V0 + 2,#0x2
   1720              if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
   \                     ??mpu_read_fifo_4:
   \   00005B   A2E5         MOV     C,0xE0 /* A   */.5
   \   00005D   5004         JNC     ??mpu_read_fifo_5
   1721                  packet_size += 2;
   \   00005F   05..         INC     ?V0 + 2
   \   000061   05..         INC     ?V0 + 2
   1722              if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
   \                     ??mpu_read_fifo_5:
   \   000063   A2E4         MOV     C,0xE0 /* A   */.4
   \   000065   5004         JNC     ??mpu_read_fifo_6
   1723                  packet_size += 2;
   \   000067   05..         INC     ?V0 + 2
   \   000069   05..         INC     ?V0 + 2
   1724              if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
   \                     ??mpu_read_fifo_6:
   \   00006B   A2E3         MOV     C,0xE0 /* A   */.3
   \   00006D   5006         JNC     ??mpu_read_fifo_7
   1725                  packet_size += 6;
   \   00006F   7406         MOV     A,#0x6
   \   000071   25..         ADD     A,?V0 + 2
   \   000073   F5..         MOV     ?V0 + 2,A
   1726          
   1727              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \                     ??mpu_read_fifo_7:
   \   000075                ; Setup parameters for call to function MPU_Read_Len
   \   000075   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000078   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   00007B   70BA         JNZ     ??mpu_read_fifo_1
   1728                  return -1;
   1729              fifo_count = (data[0] << 8) | data[1];
   \   00007D   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000080   12....       LCALL   ?XSTACK_DISP0_8
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   F5..         MOV     ?V0 + 0,A
   \   000087   E9           MOV     A,R1
   \   000088   F5..         MOV     ?V0 + 1,A
   1730              if (fifo_count < packet_size)
   \   00008A   85..82       MOV     DPL,?V0 + 2
   \   00008D   8582..       MOV     ?V0 + 4,DPL
   \   000090   C3           CLR     C
   \   000091   EA           MOV     A,R2
   \   000092   95..         SUBB    A,?V0 + 4
   \   000094   E9           MOV     A,R1
   \   000095   9400         SUBB    A,#0x0
   \   000097   5006         JNC     ??mpu_read_fifo_8
   1731                  return 0;
   \                     ??mpu_read_fifo_9:
   \   000099   7A00         MOV     R2,#0x0
   \   00009B   7B00         MOV     R3,#0x0
   \   00009D   809C         SJMP    ??mpu_read_fifo_3
   1732          //    log_i("FIFO count: %hd\n", fifo_count);
   1733              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_8:
   \   00009F   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000A2   5036         JNC     ??mpu_read_fifo_10
   1734                  /* FIFO is 50% full, better check overflow bit. */
   1735                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
   \   0000A4                ; Setup parameters for call to function MPU_Read_Len
   \   0000A4   85..82       MOV     DPL,?XSP + 0
   \   0000A7   85..83       MOV     DPH,?XSP + 1
   \   0000AA   AC82         MOV     R4,DPL
   \   0000AC   AD83         MOV     R5,DPH
   \   0000AE   7B01         MOV     R3,#0x1
   \   0000B0   90....       MOV     DPTR,#st
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   2411         ADD     A,#0x11
   \   0000B6   F5..         MOV     ?V0 + 14,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   3400         ADDC    A,#0x0
   \   0000BC   85..82       MOV     DPL,?V0 + 14
   \   0000BF   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0000C2   6003         JZ      $+5
   \   0000C4   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1736                      return -1;
   1737                  if (data[0] & BIT_FIFO_OVERFLOW) {
   \   0000C7   85..82       MOV     DPL,?XSP + 0
   \   0000CA   85..83       MOV     DPH,?XSP + 1
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000D0   5008         JNC     ??mpu_read_fifo_10
   1738                      mpu_reset_fifo();
   \   0000D2                ; Setup parameters for call to function mpu_reset_fifo
   \   0000D2   12....       LCALL   ??mpu_reset_fifo?relay
   1739                      return -2;
   \   0000D5   7AFE         MOV     R2,#-0x2
   \   0000D7   02....       LJMP    ??mpu_read_fifo_2 & 0xFFFF
   1740                  }
   1741              }
   1742              get_ms((unsigned long*)timestamp);
   1743          
   1744              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
   \                     ??mpu_read_fifo_10:
   \   0000DA                ; Setup parameters for call to function MPU_Read_Len
   \   0000DA   85..82       MOV     DPL,?XSP + 0
   \   0000DD   85..83       MOV     DPH,?XSP + 1
   \   0000E0   AC82         MOV     R4,DPL
   \   0000E2   AD83         MOV     R5,DPH
   \   0000E4   AB..         MOV     R3,?V0 + 2
   \   0000E6   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   0000E9   6003         JZ      $+5
   \   0000EB   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1745                  return -1;
   1746              more[0] = fifo_count / packet_size - 1;
   \   0000EE   A8..         MOV     R0,?V0 + 0
   \   0000F0   A9..         MOV     R1,?V0 + 1
   \   0000F2   AA..         MOV     R2,?V0 + 4
   \   0000F4   7B00         MOV     R3,#0x0
   \   0000F6   12....       LCALL   ?US_DIV_MOD
   \   0000F9   E8           MOV     A,R0
   \   0000FA   14           DEC     A
   \   0000FB   85..82       MOV     DPL,?V0 + 12
   \   0000FE   85..83       MOV     DPH,?V0 + 13
   \   000101   F0           MOVX    @DPTR,A
   1747              sensors[0] = 0;
   \   000102   85..82       MOV     DPL,?V0 + 6
   \   000105   85..83       MOV     DPH,?V0 + 7
   \   000108   E4           CLR     A
   \   000109   F0           MOVX    @DPTR,A
   1748          
   1749              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
   \   00010A   E5..         MOV     A,?V0 + 2
   \   00010C   608B         JZ      ??mpu_read_fifo_9
   \   00010E   90....       MOV     DPTR,#st + 11
   \   000111   E0           MOVX    A,@DPTR
   \   000112   A2E3         MOV     C,0xE0 /* A   */.3
   \   000114   5041         JNC     ??mpu_read_fifo_11
   1750                  accel[0] = (data[index+0] << 8) | data[index+1];
   \   000116   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000119   12....       LCALL   ?XSTACK_DISP0_8
   \   00011C   E0           MOVX    A,@DPTR
   \   00011D   85..82       MOV     DPL,?V0 + 8
   \   000120   85..83       MOV     DPH,?V0 + 9
   \   000123   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   1751                  accel[1] = (data[index+2] << 8) | data[index+3];
   \                     ??CrossCallReturnLabel_163:
   \   000126   7402         MOV     A,#0x2
   \   000128   12....       LCALL   ?XSTACK_DISP0_8
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   F9           MOV     R1,A
   \   00012D   7403         MOV     A,#0x3
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000135   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   1752                  accel[2] = (data[index+4] << 8) | data[index+5];
   \                     ??CrossCallReturnLabel_164:
   \   000138   7404         MOV     A,#0x4
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   F9           MOV     R1,A
   \   00013F   7405         MOV     A,#0x5
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000147   12....       LCALL   ?Subroutine53 & 0xFFFF
   1753                  sensors[0] |= INV_XYZ_ACCEL;
   \                     ??CrossCallReturnLabel_185:
   \   00014A   D2E3         SETB    0xE0 /* A   */.3
   \   00014C   F0           MOVX    @DPTR,A
   1754                  index += 6;
   \   00014D   7E06         MOV     R6,#0x6
   1755              }
   1756              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
   \   00014F   EE           MOV     A,R6
   \   000150   65..         XRL     A,?V0 + 2
   \   000152   7003         JNZ     $+5
   \   000154   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \                     ??mpu_read_fifo_11:
   \   000157   90....       MOV     DPTR,#st + 11
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   A2E6         MOV     C,0xE0 /* A   */.6
   \   00015D   5021         JNC     ??mpu_read_fifo_12
   1757                  gyro[0] = (data[index+0] << 8) | data[index+1];
   \   00015F   85..82       MOV     DPL,?XSP + 0
   \   000162   85..83       MOV     DPH,?XSP + 1
   \   000165   E582         MOV     A,DPL
   \   000167   2E           ADD     A,R6
   \   000168   F582         MOV     DPL,A
   \   00016A   E583         MOV     A,DPH
   \   00016C   3400         ADDC    A,#0x0
   \   00016E   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000171   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   1758                  sensors[0] |= INV_X_GYRO;
   \                     ??CrossCallReturnLabel_187:
   \   000174   D2E6         SETB    0xE0 /* A   */.6
   \   000176   F0           MOVX    @DPTR,A
   1759                  index += 2;
   \   000177   EE           MOV     A,R6
   \   000178   2402         ADD     A,#0x2
   \   00017A   0E           INC     R6
   \   00017B   0E           INC     R6
   \   00017C   E4           CLR     A
   \   00017D   3400         ADDC    A,#0x0
   \   00017F   FF           MOV     R7,A
   1760              }
   1761              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
   \                     ??mpu_read_fifo_12:
   \   000180   EE           MOV     A,R6
   \   000181   65..         XRL     A,?V0 + 2
   \   000183   601A         JZ      ??mpu_read_fifo_13
   \   000185   90....       MOV     DPTR,#st + 11
   \   000188   E0           MOVX    A,@DPTR
   \   000189   A2E5         MOV     C,0xE0 /* A   */.5
   \   00018B   5012         JNC     ??mpu_read_fifo_13
   1762                  gyro[1] = (data[index+0] << 8) | data[index+1];
   \   00018D   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000190   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   1763                  sensors[0] |= INV_Y_GYRO;
   \                     ??CrossCallReturnLabel_188:
   \   000193   D2E5         SETB    0xE0 /* A   */.5
   \   000195   F0           MOVX    @DPTR,A
   1764                  index += 2;
   \   000196   EE           MOV     A,R6
   \   000197   2402         ADD     A,#0x2
   \   000199   0E           INC     R6
   \   00019A   0E           INC     R6
   \   00019B   EF           MOV     A,R7
   \   00019C   3400         ADDC    A,#0x0
   \   00019E   FF           MOV     R7,A
   1765              }
   1766              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
   \                     ??mpu_read_fifo_13:
   \   00019F   EE           MOV     A,R6
   \   0001A0   65..         XRL     A,?V0 + 2
   \   0001A2   7003         JNZ     $+5
   \   0001A4   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \   0001A7   90....       MOV     DPTR,#st + 11
   \   0001AA   E0           MOVX    A,@DPTR
   \   0001AB   A2E4         MOV     C,0xE0 /* A   */.4
   \   0001AD   4003         JC      $+5
   \   0001AF   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1767                  gyro[2] = (data[index+0] << 8) | data[index+1];
   \   0001B2   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   0001B5   12....       LCALL   ?Subroutine53 & 0xFFFF
   1768                  sensors[0] |= INV_Z_GYRO;
   \                     ??CrossCallReturnLabel_186:
   \   0001B8   D2E4         SETB    0xE0 /* A   */.4
   \   0001BA   F0           MOVX    @DPTR,A
   1769                  index += 2;
   \   0001BB   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1770              }
   1771          
   1772              return 0;
   1773          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine114_0
   \   000002                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   85..82       MOV     DPL,?V0 + 6
   \   000007   85..83       MOV     DPH,?V0 + 7
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0 + 8
   \   000004   85..83       MOV     DPH,?V0 + 9
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   2E           ADD     A,R6
   \   000009   F582         MOV     DPL,A
   \   00000B   E583         MOV     A,DPH
   \   00000D   3F           ADDC    A,R7
   \   00000E   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   F583         MOV     DPH,A
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   85..82       MOV     DPL,?V0 + 10
   \   000009   85..83       MOV     DPH,?V0 + 11
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine115_0
   \   000006                ; // Fall through to label ??Subroutine115_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B02         MOV     R3,#0x2
   \   000006   90....       MOV     DPTR,#st
   \   000009                REQUIRE ??Subroutine116_0
   \   000009                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   F583         MOV     DPH,A
   \   000002   E0           MOVX    A,@DPTR
   \   000003   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000003   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000006   C3           CLR     C
   \   000007   95..         SUBB    A,?V0 + 0
   \   000009   EB           MOV     A,R3
   \   00000A   95..         SUBB    A,?V0 + 1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET
   1774          
   1775          /**
   1776           *  @brief      Get one unparsed packet from the FIFO.
   1777           *  This function should be used if the packet is to be parsed elsewhere.
   1778           *  @param[in]  length  Length of one FIFO packet.
   1779           *  @param[in]  data    FIFO packet.
   1780           *  @param[in]  more    Number of remaining packets.
   1781           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1782          int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
   \                     mpu_read_fifo_stream:
   1783              unsigned char *more)
   1784          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine79 & 0xFFFF
   1785              unsigned char tmp[2];
   1786              unsigned short fifo_count;
   1787              if (!st.chip_cfg.dmp_on)
   \                     ??CrossCallReturnLabel_114:
   \   00001A   90....       MOV     DPTR,#st + 29
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   7007         JNZ     ??mpu_read_fifo_stream_0
   1788              {
   1789                  //printf("mpu_read_fifo_stream -1\r\n");
   1790                  return -1;
   \                     ??mpu_read_fifo_stream_1:
   \   000020   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_stream_2:
   \   000022   7BFF         MOV     R3,#-0x1
   \   000024   02....       LJMP    ??CrossCallReturnLabel_253 & 0xFFFF
   1791              }
   1792              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_fifo_stream_0:
   \   000027   90....       MOV     DPTR,#st + 6
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   60F3         JZ      ??mpu_read_fifo_stream_1
   1793              {
   1794                  //printf("mpu_read_fifo_stream -2\r\n");      
   1795                  return -1;
   1796              }
   1797              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
   \   00002D                ; Setup parameters for call to function MPU_Read_Len
   \   00002D   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   000030   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000033   70EB         JNZ     ??mpu_read_fifo_stream_1
   1798              {
   1799                  //printf("mpu_read_fifo_stream -3\r\n");       
   1800                  return -1;
   1801              }
   1802              fifo_count = (tmp[0] << 8) | tmp[1];
   \   000035   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FA           MOV     R2,A
   \   00003D   F5..         MOV     ?V0 + 0,A
   \   00003F   E9           MOV     A,R1
   \   000040   F5..         MOV     ?V0 + 1,A
   1803              if (fifo_count < length) 
   \   000042   C3           CLR     C
   \   000043   EA           MOV     A,R2
   \   000044   9E           SUBB    A,R6
   \   000045   E9           MOV     A,R1
   \   000046   9F           SUBB    A,R7
   \   000047   500A         JNC     ??mpu_read_fifo_stream_3
   1804              {
   1805                  //printf("mpu_read_fifo_stream -4\r\n");       
   1806                  more[0] = 0;
   \   000049   85..82       MOV     DPL,?V0 + 4
   \   00004C   85..83       MOV     DPH,?V0 + 5
   \   00004F   E4           CLR     A
   \   000050   F0           MOVX    @DPTR,A
   \   000051   80CD         SJMP    ??mpu_read_fifo_stream_1
   1807                  return -1;
   1808              }
   1809              if (fifo_count > (st.hw->max_fifo >> 1)) 
   \                     ??mpu_read_fifo_stream_3:
   \   000053   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000056   5032         JNC     ??mpu_read_fifo_stream_4
   1810              {
   1811                  /* FIFO is 50% full, better check overflow bit. */
   1812                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
   \   000058                ; Setup parameters for call to function MPU_Read_Len
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   AC82         MOV     R4,DPL
   \   000060   AD83         MOV     R5,DPH
   \   000062   7B01         MOV     R3,#0x1
   \   000064   90....       MOV     DPTR,#st
   \   000067   E0           MOVX    A,@DPTR
   \   000068   2411         ADD     A,#0x11
   \   00006A   F5..         MOV     ?V0 + 6,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   3400         ADDC    A,#0x0
   \   000070   85..82       MOV     DPL,?V0 + 6
   \   000073   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000076   70A8         JNZ     ??mpu_read_fifo_stream_1
   1813                  {
   1814                      //printf("mpu_read_fifo_stream -5\r\n"); 
   1815                      return -1;
   1816                  }
   1817                  if (tmp[0] & BIT_FIFO_OVERFLOW) 
   \   000078   85..82       MOV     DPL,?XSP + 0
   \   00007B   85..83       MOV     DPH,?XSP + 1
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   A2E4         MOV     C,0xE0 /* A   */.4
   \   000081   5007         JNC     ??mpu_read_fifo_stream_4
   1818                  {
   1819                      //printf("mpu_read_fifo_stream -6\r\n");           
   1820                      mpu_reset_fifo();
   \   000083                ; Setup parameters for call to function mpu_reset_fifo
   \   000083   12....       LCALL   ??mpu_reset_fifo?relay
   1821                      return -2;
   \   000086   7AFE         MOV     R2,#-0x2
   \   000088   8098         SJMP    ??mpu_read_fifo_stream_2
   1822                  }
   1823              }
   1824          
   1825              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
   \                     ??mpu_read_fifo_stream_4:
   \   00008A                ; Setup parameters for call to function MPU_Read_Len
   \   00008A   AC..         MOV     R4,?V0 + 2
   \   00008C   AD..         MOV     R5,?V0 + 3
   \   00008E   EE           MOV     A,R6
   \   00008F   FB           MOV     R3,A
   \   000090   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000093   708B         JNZ     ??mpu_read_fifo_stream_1
   1826              {
   1827                  //printf("mpu_read_fifo_stream -7\r\n"); 
   1828                  return -1;
   1829              }
   1830              more[0] = fifo_count / length - 1;
   \   000095   A8..         MOV     R0,?V0 + 0
   \   000097   A9..         MOV     R1,?V0 + 1
   \   000099   EE           MOV     A,R6
   \   00009A   FA           MOV     R2,A
   \   00009B   EF           MOV     A,R7
   \   00009C   FB           MOV     R3,A
   \   00009D   12....       LCALL   ?US_DIV_MOD
   \   0000A0   E8           MOV     A,R0
   \   0000A1   14           DEC     A
   \   0000A2   85..82       MOV     DPL,?V0 + 4
   \   0000A5   85..83       MOV     DPH,?V0 + 5
   \   0000A8   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   1831              return 0;
   \                     ??CrossCallReturnLabel_253:
   \   0000AB   02....       LJMP    ?Subroutine2 & 0xFFFF
   1832          }
   1833          
   1834          /**
   1835           *  @brief      Set device to bypass mode.
   1836           *  @param[in]  bypass_on   1 to enable bypass mode.
   1837           *  @return     0 if successful.
   1838           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1839          int mpu_set_bypass(unsigned char bypass_on)
   \                     mpu_set_bypass:
   1840          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1841              unsigned char tmp;
   1842          
   1843              if (st.chip_cfg.bypass_mode == bypass_on)
   \   00000C   90....       MOV     DPTR,#st + 13
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   7003         JNZ     $+5
   \   000013   02....       LJMP    ??mpu_set_bypass_0 & 0xFFFF
   1844                  return 0;
   1845          
   1846              if (bypass_on) {
   \   000016   90....       MOV     DPTR,#st + 2
   \   000019   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F9           MOV     R1,A
   \   00001E   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FA           MOV     R2,A
   \   000023   EE           MOV     A,R6
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   AC82         MOV     R4,DPL
   \   00002C   AD83         MOV     R5,DPH
   \   00002E   7B01         MOV     R3,#0x1
   \   000030   6062         JZ      ??mpu_set_bypass_1
   1847                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   000032                ; Setup parameters for call to function MPU_Read_Len
   \   000032   12....       LCALL   ??MPU_Read_Len?relay
   \   000035   E9           MOV     A,R1
   \   000036   6007         JZ      ??mpu_set_bypass_2
   1848                      return -1;
   \                     ??mpu_set_bypass_3:
   \   000038   7AFF         MOV     R2,#-0x1
   \   00003A   7BFF         MOV     R3,#-0x1
   \   00003C   02....       LJMP    ??mpu_set_bypass_4 & 0xFFFF
   1849                  tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_2:
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   E0           MOVX    A,@DPTR
   \   000046   C2E5         CLR     0xE0 /* A   */.5
   \   000048   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   1850                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??CrossCallReturnLabel_175:
   \   00004B   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   00004E   70E8         JNZ     ??mpu_set_bypass_3
   1851                      return -1;
   1852                  delay_ms(3);
   \   000050                ; Setup parameters for call to function delay_ms
   \   000050   90....       MOV     DPTR,#__Constant_3
   \   000053   12....       LCALL   ?XLOAD_R2345
   \   000056   12....       LCALL   ?Subroutine63 & 0xFFFF
   1853                  tmp = BIT_BYPASS_EN;
   \                     ??CrossCallReturnLabel_91:
   \   000059   7402         MOV     A,#0x2
   \   00005B   F0           MOVX    @DPTR,A
   1854                  if (st.chip_cfg.active_low_int)
   \   00005C   90....       MOV     DPTR,#st + 27
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   6009         JZ      ??mpu_set_bypass_5
   1855                      tmp |= BIT_ACTL;
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   7482         MOV     A,#-0x7e
   \   00006A   F0           MOVX    @DPTR,A
   1856                  if (st.chip_cfg.latched_int)
   \                     ??mpu_set_bypass_5:
   \   00006B   90....       MOV     DPTR,#st + 28
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   600A         JZ      ??mpu_set_bypass_6
   1857                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   000071   85..82       MOV     DPL,?XSP + 0
   \   000074   85..83       MOV     DPH,?XSP + 1
   \   000077   E0           MOVX    A,@DPTR
   \   000078   4430         ORL     A,#0x30
   \   00007A   F0           MOVX    @DPTR,A
   1858                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_6:
   \   00007B                ; Setup parameters for call to function MPU_Write_Len
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   AC82         MOV     R4,DPL
   \   000083   AD83         MOV     R5,DPH
   \   000085   7B01         MOV     R3,#0x1
   \   000087   90....       MOV     DPTR,#st
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   2414         ADD     A,#0x14
   \   00008D   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   1859                      return -1;
   1860              } else {
   \                     ??CrossCallReturnLabel_289:
   \   000090   70A6         JNZ     ??mpu_set_bypass_3
   \   000092   8064         SJMP    ??mpu_set_bypass_7
   1861                  /* Enable I2C master mode if compass is being used. */
   1862                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??mpu_set_bypass_1:
   \   000094                ; Setup parameters for call to function MPU_Read_Len
   \   000094   12....       LCALL   ??MPU_Read_Len?relay
   \   000097   E9           MOV     A,R1
   \   000098   709E         JNZ     ??mpu_set_bypass_3
   1863                      return -1;
   1864                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   00009A   90....       MOV     DPTR,#st + 6
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000A0   85..82       MOV     DPL,?XSP + 0
   \   0000A3   85..83       MOV     DPH,?XSP + 1
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   5004         JNC     ??mpu_set_bypass_8
   1865                      tmp |= BIT_AUX_IF_EN;
   \   0000A9   D2E5         SETB    0xE0 /* A   */.5
   \   0000AB   8002         SJMP    ??mpu_set_bypass_9
   1866                  else
   1867                      tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_8:
   \   0000AD   C2E5         CLR     0xE0 /* A   */.5
   \                     ??mpu_set_bypass_9:
   \   0000AF   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   1868                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??CrossCallReturnLabel_176:
   \   0000B2   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   0000B5   7081         JNZ     ??mpu_set_bypass_3
   1869                      return -1;
   1870                  delay_ms(3);
   \   0000B7                ; Setup parameters for call to function delay_ms
   \   0000B7   90....       MOV     DPTR,#__Constant_3
   \   0000BA   12....       LCALL   ?XLOAD_R2345
   \   0000BD   12....       LCALL   ??delay_ms?relay
   1871                  if (st.chip_cfg.active_low_int)
   \   0000C0   90....       MOV     DPTR,#st + 27
   \   0000C3   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   0000C6   6004         JZ      ??mpu_set_bypass_10
   1872                      tmp = BIT_ACTL;
   \   0000C8   7480         MOV     A,#-0x80
   \   0000CA   8001         SJMP    ??mpu_set_bypass_11
   1873                  else
   1874                      tmp = 0;
   \                     ??mpu_set_bypass_10:
   \   0000CC   E4           CLR     A
   \                     ??mpu_set_bypass_11:
   \   0000CD   F0           MOVX    @DPTR,A
   1875                  if (st.chip_cfg.latched_int)
   \   0000CE   90....       MOV     DPTR,#st + 28
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   600A         JZ      ??mpu_set_bypass_12
   1876                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   0000D4   85..82       MOV     DPL,?XSP + 0
   \   0000D7   85..83       MOV     DPH,?XSP + 1
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   4430         ORL     A,#0x30
   \   0000DD   F0           MOVX    @DPTR,A
   1877                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_12:
   \   0000DE                ; Setup parameters for call to function MPU_Write_Len
   \   0000DE   85..82       MOV     DPL,?XSP + 0
   \   0000E1   85..83       MOV     DPH,?XSP + 1
   \   0000E4   AC82         MOV     R4,DPL
   \   0000E6   AD83         MOV     R5,DPH
   \   0000E8   7B01         MOV     R3,#0x1
   \   0000EA   90....       MOV     DPTR,#st
   \   0000ED   E0           MOVX    A,@DPTR
   \   0000EE   2414         ADD     A,#0x14
   \   0000F0   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   1878                      return -1;
   1879              }
   \                     ??CrossCallReturnLabel_290:
   \   0000F3   6003         JZ      $+5
   \   0000F5   02....       LJMP    ??mpu_set_bypass_3 & 0xFFFF
   1880              st.chip_cfg.bypass_mode = bypass_on;
   \                     ??mpu_set_bypass_7:
   \   0000F8   EE           MOV     A,R6
   \   0000F9   90....       MOV     DPTR,#st + 13
   \   0000FC   F0           MOVX    @DPTR,A
   1881              return 0;
   \                     ??mpu_set_bypass_0:
   \   0000FD   7A00         MOV     R2,#0x0
   \   0000FF   7B00         MOV     R3,#0x0
   \                     ??mpu_set_bypass_4:
   \   000101   02....       LJMP    ?Subroutine0 & 0xFFFF
   1882          }
   1883          
   1884          /**
   1885           *  @brief      Set interrupt level.
   1886           *  @param[in]  active_low  1 for active low, 0 for active high.
   1887           *  @return     0 if successful.
   1888           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1889          int mpu_set_int_level(unsigned char active_low)
   \                     mpu_set_int_level:
   1890          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1891              st.chip_cfg.active_low_int = active_low;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#st + 27
   \   000008   80..         SJMP    ??Subroutine119_0
   1892              return 0;
   1893          }
   1894          
   1895          /**
   1896           *  @brief      Enable latched interrupts.
   1897           *  Any MPU register will clear the interrupt.
   1898           *  @param[in]  enable  1 to enable, 0 to disable.
   1899           *  @return     0 if successful.
   1900           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1901          int mpu_set_int_latched(unsigned char enable)
   \                     mpu_set_int_latched:
   1902          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1903              unsigned char tmp;
   1904              if (st.chip_cfg.latched_int == enable)
   \   00000C   90....       MOV     DPTR,#st + 28
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   6051         JZ      ??mpu_set_int_latched_0
   1905                  return 0;
   1906          
   1907              if (enable)
   \   000013   EE           MOV     A,R6
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   6004         JZ      ??mpu_set_int_latched_1
   1908                  tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00001C   7430         MOV     A,#0x30
   \   00001E   8001         SJMP    ??mpu_set_int_latched_2
   1909              else
   1910                  tmp = 0;
   \                     ??mpu_set_int_latched_1:
   \   000020   E4           CLR     A
   \                     ??mpu_set_int_latched_2:
   \   000021   F0           MOVX    @DPTR,A
   1911              if (st.chip_cfg.bypass_mode)
   \   000022   90....       MOV     DPTR,#st + 13
   \   000025   E0           MOVX    A,@DPTR
   \   000026   600A         JZ      ??mpu_set_int_latched_3
   1912                  tmp |= BIT_BYPASS_EN;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   D2E1         SETB    0xE0 /* A   */.1
   \   000031   F0           MOVX    @DPTR,A
   1913              if (st.chip_cfg.active_low_int)
   \                     ??mpu_set_int_latched_3:
   \   000032   90....       MOV     DPTR,#st + 27
   \   000035   E0           MOVX    A,@DPTR
   \   000036   600A         JZ      ??mpu_set_int_latched_4
   1914                  tmp |= BIT_ACTL;
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   D2E7         SETB    0xE0 /* A   */.7
   \   000041   F0           MOVX    @DPTR,A
   1915              if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_int_latched_4:
   \   000042                ; Setup parameters for call to function MPU_Write_Len
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   AC82         MOV     R4,DPL
   \   00004A   AD83         MOV     R5,DPH
   \   00004C   7B01         MOV     R3,#0x1
   \   00004E   90....       MOV     DPTR,#st
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2414         ADD     A,#0x14
   \   000054   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000057   6006         JZ      ??mpu_set_int_latched_5
   1916                  return -1;
   \   000059   7AFF         MOV     R2,#-0x1
   \   00005B   7BFF         MOV     R3,#-0x1
   \   00005D   8009         SJMP    ??mpu_set_int_latched_6
   1917              st.chip_cfg.latched_int = enable;
   \                     ??mpu_set_int_latched_5:
   \   00005F   EE           MOV     A,R6
   \   000060   90....       MOV     DPTR,#st + 28
   \   000063   F0           MOVX    @DPTR,A
   1918              return 0;
   \                     ??mpu_set_int_latched_0:
   \   000064   7A00         MOV     R2,#0x0
   \   000066   7B00         MOV     R3,#0x0
   \                     ??mpu_set_int_latched_6:
   \   000068   02....       LJMP    ?Subroutine0 & 0xFFFF
   1919          }
   1920          
   1921          #ifdef MPU6050

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1922          static int get_accel_prod_shift(float *st_shift)
   \                     get_accel_prod_shift:
   1923          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 12,R2
   \   00000C   8B..         MOV     ?V0 + 13,R3
   1924              unsigned char tmp[4], shift_code[3], ii;
   1925          
   1926              if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
   \   00000E                ; Setup parameters for call to function MPU_Read_Len
   \   00000E   7403         MOV     A,#0x3
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   7B04         MOV     R3,#0x4
   \   000019   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   00001C   6005         JZ      ??get_accel_prod_shift_0
   1927                  return 0x07;
   \   00001E   7A07         MOV     R2,#0x7
   \   000020   02....       LJMP    ??get_accel_prod_shift_1 & 0xFFFF
   1928          
   1929              shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
   \                     ??get_accel_prod_shift_0:
   \   000023   7406         MOV     A,#0x6
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   C4           SWAP    A
   \   00002B   540F         ANL     A,#0xf
   \   00002D   5403         ANL     A,#0x3
   \   00002F   F8           MOV     R0,A
   \   000030   7403         MOV     A,#0x3
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   F0           MOVX    @DPTR,A
   1930              shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
   \   00003F   E9           MOV     A,R1
   \   000040   13           RRC     A
   \   000041   13           RRC     A
   \   000042   543F         ANL     A,#0x3f
   \   000044   5403         ANL     A,#0x3
   \   000046   F8           MOV     R0,A
   \   000047   7404         MOV     A,#0x4
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00004F   C0E0         PUSH    A
   \   000051   7401         MOV     A,#0x1
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   D0E0         POP     A
   \   000058   F0           MOVX    @DPTR,A
   1931              shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
   \   000059   7403         MOV     A,#0x3
   \   00005B   59           ANL     A,R1
   \   00005C   F8           MOV     R0,A
   \   00005D   7405         MOV     A,#0x5
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000065   C0E0         PUSH    A
   \   000067   7402         MOV     A,#0x2
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   D0E0         POP     A
   \   00006E   F0           MOVX    @DPTR,A
   1932              for (ii = 0; ii < 3; ii++) {
   \   00006F   7E00         MOV     R6,#0x0
   1933                  if (!shift_code[ii]) {
   \                     ??get_accel_prod_shift_2:
   \   000071   8E82         MOV     DPL,R6
   \   000073   AA82         MOV     R2,DPL
   \   000075   8A..         MOV     ?V0 + 0,R2
   \   000077   75..00       MOV     ?V0 + 1,#0x0
   \   00007A   7402         MOV     A,#0x2
   \   00007C   78..         MOV     R0,#?V0 + 0
   \   00007E   12....       LCALL   ?S_SHL
   \   000081   E5..         MOV     A,?V0 + 12
   \   000083   25..         ADD     A,?V0 + 0
   \   000085   F5..         MOV     ?V0 + 4,A
   \   000087   E5..         MOV     A,?V0 + 13
   \   000089   35..         ADDC    A,?V0 + 1
   \   00008B   F5..         MOV     ?V0 + 5,A
   \   00008D   85..82       MOV     DPL,?XSP + 0
   \   000090   85..83       MOV     DPH,?XSP + 1
   \   000093   E582         MOV     A,DPL
   \   000095   2A           ADD     A,R2
   \   000096   F5..         MOV     ?V0 + 6,A
   \   000098   E583         MOV     A,DPH
   \   00009A   3400         ADDC    A,#0x0
   \   00009C   F5..         MOV     ?V0 + 7,A
   \   00009E   85..82       MOV     DPL,?V0 + 6
   \   0000A1   F583         MOV     DPH,A
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   7011         JNZ     ??get_accel_prod_shift_3
   1934                      st_shift[ii] = 0.f;
   \   0000A6   90....       MOV     DPTR,#__Constant_0
   \   0000A9   12....       LCALL   ?XLOAD_R2345
   \   0000AC   85..82       MOV     DPL,?V0 + 4
   \   0000AF   85..83       MOV     DPH,?V0 + 5
   \   0000B2   12....       LCALL   ?XSTORE_R2345
   1935                      continue;
   \   0000B5   8041         SJMP    ??get_accel_prod_shift_4
   1936                  }
   1937                  /* Equivalent to..
   1938                   * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
   1939                   */
   1940                  st_shift[ii] = 0.34f;
   \                     ??get_accel_prod_shift_3:
   \   0000B7   90....       MOV     DPTR,#__Constant_3eae147b
   \   0000BA   12....       LCALL   ?XLOAD_R2345
   \   0000BD   85..82       MOV     DPL,?V0 + 4
   \   0000C0   85..83       MOV     DPH,?V0 + 5
   \   0000C3   12....       LCALL   ?XSTORE_R2345
   \   0000C6   8025         SJMP    ??get_accel_prod_shift_5
   1941                  while (--shift_code[ii])
   1942                      st_shift[ii] *= 1.034f;
   \                     ??get_accel_prod_shift_6:
   \   0000C8   85..82       MOV     DPL,?V0 + 4
   \   0000CB   85..83       MOV     DPH,?V0 + 5
   \   0000CE   78..         MOV     R0,#?V0 + 0
   \   0000D0   12....       LCALL   ?L_MOV_X
   \   0000D3   90....       MOV     DPTR,#__Constant_3f845a1d
   \   0000D6   78..         MOV     R0,#?V0 + 8
   \   0000D8   12....       LCALL   ?L_MOV_X
   \   0000DB   78..         MOV     R0,#?V0 + 0
   \   0000DD   79..         MOV     R1,#?V0 + 8
   \   0000DF   12....       LCALL   ?FLT_MUL
   \   0000E2   85..82       MOV     DPL,?V0 + 4
   \   0000E5   85..83       MOV     DPH,?V0 + 5
   \   0000E8   78..         MOV     R0,#?V0 + 0
   \   0000EA   12....       LCALL   ?L_MOV_TO_X
   \                     ??get_accel_prod_shift_5:
   \   0000ED   85..82       MOV     DPL,?V0 + 6
   \   0000F0   85..83       MOV     DPH,?V0 + 7
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   14           DEC     A
   \   0000F5   F0           MOVX    @DPTR,A
   \   0000F6   70D0         JNZ     ??get_accel_prod_shift_6
   1943              }
   \                     ??get_accel_prod_shift_4:
   \   0000F8   0E           INC     R6
   \   0000F9   EE           MOV     A,R6
   \   0000FA   C3           CLR     C
   \   0000FB   9403         SUBB    A,#0x3
   \   0000FD   5003         JNC     $+5
   \   0000FF   02....       LJMP    ??get_accel_prod_shift_2 & 0xFFFF
   1944              return 0;
   \   000102   7A00         MOV     R2,#0x0
   \                     ??get_accel_prod_shift_1:
   \   000104   7B00         MOV     R3,#0x0
   \   000106   7407         MOV     A,#0x7
   \   000108                REQUIRE ?Subroutine7
   \   000108                ; // Fall through to label ?Subroutine7
   1945          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F0E         MOV     R7,#0xe
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   000003   541C         ANL     A,#0x1c
   \   000005   48           ORL     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   7A0D         MOV     R2,#0xd
   \   000002                REQUIRE ??Subroutine122_0
   \   000002                ; // Fall through to label ??Subroutine122_0
   1946          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1947          static int accel_self_test(long *bias_regular, long *bias_st)
   \                     accel_self_test:
   1948          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   12....       LCALL   ?Subroutine56 & 0xFFFF
   1949              int jj, result = 0;
   1950              float st_shift[3], st_shift_cust, st_shift_var;
   1951          
   1952              get_accel_prod_shift(st_shift);
   \                     ??CrossCallReturnLabel_78:
   \   000013                ; Setup parameters for call to function get_accel_prod_shift
   \   000013   7402         MOV     A,#0x2
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??get_accel_prod_shift?relay
   1953              for(jj = 0; jj < 3; jj++) {
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   1954                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \                     ??accel_self_test_0:
   \   000023   8E..         MOV     ?V0 + 2,R6
   \   000025   8F..         MOV     ?V0 + 3,R7
   \   000027   7402         MOV     A,#0x2
   \   000029   78..         MOV     R0,#?V0 + 2
   \   00002B   12....       LCALL   ?S_SHL
   \   00002E   85....       MOV     ?V0 + 0,?V0 + 2
   \   000031   85....       MOV     ?V0 + 1,?V0 + 3
   \   000034                ; Setup parameters for call to function labs
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   25..         ADD     A,?V0 + 0
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   35..         ADDC    A,?V0 + 1
   \   000042   8882         MOV     DPL,R0
   \   000044   F583         MOV     DPH,A
   \   000046   78..         MOV     R0,#?V0 + 4
   \   000048   12....       LCALL   ?L_MOV_X
   \   00004B   E5..         MOV     A,?V0 + 14
   \   00004D   25..         ADD     A,?V0 + 0
   \   00004F   F582         MOV     DPL,A
   \   000051   E5..         MOV     A,?V0 + 15
   \   000053   35..         ADDC    A,?V0 + 1
   \   000055   F583         MOV     DPH,A
   \   000057   78..         MOV     R0,#?V0 + 4
   \   000059   12....       LCALL   ?L_SUB_X
   \   00005C   AA..         MOV     R2,?V0 + 4
   \   00005E   AB..         MOV     R3,?V0 + 5
   \   000060   AC..         MOV     R4,?V0 + 6
   \   000062   AD..         MOV     R5,?V0 + 7
   \   000064   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000067   12....       LCALL   ?L_TO_FLT
   \   00006A   90....       MOV     DPTR,#__Constant_37800000
   \   00006D   78..         MOV     R0,#?V0 + 8
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 4
   \   000074   79..         MOV     R1,#?V0 + 8
   \   000076   12....       LCALL   ?FLT_MUL
   1955                  if (st_shift[jj]) {
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000081   78..         MOV     R0,#?V0 + 8
   \   000083   12....       LCALL   ?L_MOV_X
   \   000086   90....       MOV     DPTR,#__Constant_0
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?L_MOV_X
   \   00008E   78..         MOV     R0,#?V0 + 8
   \   000090   79..         MOV     R1,#?V0 + 0
   \   000092   12....       LCALL   ?FLT_EQ
   \   000095   6056         JZ      ??accel_self_test_1
   1956                      st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
   1957                      if (fabs(st_shift_var) > test.max_accel_var)
   \   000097   8E..         MOV     ?V0 + 0,R6
   \   000099   8F..         MOV     ?V0 + 1,R7
   \   00009B   7402         MOV     A,#0x2
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?S_SHL
   \   0000A2   7402         MOV     A,#0x2
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   0000AA   78..         MOV     R0,#?V0 + 0
   \   0000AC   12....       LCALL   ?L_MOV_X
   \   0000AF   78..         MOV     R0,#?V0 + 4
   \   0000B1   79..         MOV     R1,#?V0 + 0
   \   0000B3   12....       LCALL   ?FLT_DIV
   \   0000B6   90....       MOV     DPTR,#__Constant_bf800000
   \   0000B9   78..         MOV     R0,#?V0 + 0
   \   0000BB   12....       LCALL   ?L_MOV_X
   \   0000BE   78..         MOV     R0,#?V0 + 4
   \   0000C0   79..         MOV     R1,#?V0 + 0
   \   0000C2   12....       LCALL   ?FLT_ADD
   \   0000C5   E5..         MOV     A,?V0 + 7
   \   0000C7   C2E7         CLR     0xE0 /* A   */.7
   \   0000C9   F5..         MOV     ?V0 + 7,A
   \   0000CB   90....       MOV     DPTR,#__Constant_3e0f5c2a
   \   0000CE   78..         MOV     R0,#?V0 + 0
   \   0000D0   12....       LCALL   ?L_MOV_X
   \   0000D3   78..         MOV     R0,#?V0 + 4
   \   0000D5   79..         MOV     R1,#?V0 + 0
   \   0000D7   12....       LCALL   ?FLT_GE
   \   0000DA   5033         JNC     ??accel_self_test_2
   1958                          result |= 1 << jj;
   \                     ??accel_self_test_3:
   \   0000DC   75..01       MOV     ?V0 + 0,#0x1
   \   0000DF   75..00       MOV     ?V0 + 1,#0x0
   \   0000E2   EE           MOV     A,R6
   \   0000E3   78..         MOV     R0,#?V0 + 0
   \   0000E5   12....       LCALL   ?S_SHL
   \   0000E8   12....       LCALL   ?Subroutine70 & 0xFFFF
   1959                  } else if ((st_shift_cust < test.min_g) ||
   \                     ??CrossCallReturnLabel_104:
   \   0000EB   8022         SJMP    ??accel_self_test_2
   1960                      (st_shift_cust > test.max_g))
   \                     ??accel_self_test_1:
   \   0000ED   90....       MOV     DPTR,#__Constant_3e99999a
   \   0000F0   78..         MOV     R0,#?V0 + 0
   \   0000F2   12....       LCALL   ?L_MOV_X
   \   0000F5   78..         MOV     R0,#?V0 + 4
   \   0000F7   79..         MOV     R1,#?V0 + 0
   \   0000F9   12....       LCALL   ?FLT_LT
   \   0000FC   40DE         JC      ??accel_self_test_3
   \   0000FE   90....       MOV     DPTR,#__Constant_3f733334
   \   000101   78..         MOV     R0,#?V0 + 0
   \   000103   12....       LCALL   ?L_MOV_X
   \   000106   78..         MOV     R0,#?V0 + 4
   \   000108   79..         MOV     R1,#?V0 + 0
   \   00010A   12....       LCALL   ?FLT_GE
   \   00010D   40CD         JC      ??accel_self_test_3
   1961                      result |= 1 << jj;
   1962              }
   \                     ??accel_self_test_2:
   \   00010F   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000112   5003         JNC     $+5
   \   000114   02....       LJMP    ??accel_self_test_0 & 0xFFFF
   1963          
   1964              return result;
   \   000117   AA..         MOV     R2,?V0 + 12
   \   000119   AB..         MOV     R3,?V0 + 13
   \   00011B   740E         MOV     A,#0xe
   \   00011D   02....       LJMP    ?Subroutine6 & 0xFFFF
   1965          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   E582         MOV     A,DPL
   \   000002   25..         ADD     A,?V0 + 0
   \   000004   F582         MOV     DPL,A
   \   000006   E583         MOV     A,DPH
   \   000008   35..         ADDC    A,?V0 + 1
   \   00000A   F583         MOV     DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   45..         ORL     A,?V0 + 12
   \   000004   F5..         MOV     ?V0 + 12,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   45..         ORL     A,?V0 + 13
   \   00000A   F5..         MOV     ?V0 + 13,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   12....       LCALL   ??labs?relay
   \   000003   8A..         MOV     ?V0 + 4,R2
   \   000005   8B..         MOV     ?V0 + 5,R3
   \   000007   8C..         MOV     ?V0 + 6,R4
   \   000009   8D..         MOV     ?V0 + 7,R5
   \   00000B   78..         MOV     R0,#?V0 + 4
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000003   9403         SUBB    A,#0x3
   \   000005   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000003   8C..         MOV     ?V0 + 14,R4
   \   000005   8D..         MOV     ?V0 + 15,R5
   \   000007   75..00       MOV     ?V0 + 12,#0x0
   \   00000A   75..00       MOV     ?V0 + 13,#0x0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   EF           MOV     A,R7
   \   000001                REQUIRE ??Subroutine132_0
   \   000001                ; // Fall through to label ??Subroutine132_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   9400         SUBB    A,#0x0
   \   000002   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000004   65D0         XRL     A,PSW
   \   000006   33           RLC     A
   \   000007   22           RET
   1966          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1967          static int gyro_self_test(long *bias_regular, long *bias_st)
   \                     gyro_self_test:
   1968          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7403         MOV     A,#0x3
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine56 & 0xFFFF
   1969              int jj, result = 0;
   1970              unsigned char tmp[3];
   1971              float st_shift, st_shift_cust, st_shift_var;
   1972          
   1973              if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
   \                     ??CrossCallReturnLabel_79:
   \   000012                ; Setup parameters for call to function MPU_Read_Len
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   7B03         MOV     R3,#0x3
   \   00001E   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000021   6007         JZ      ??gyro_self_test_0
   1974                  return 0x07;
   \   000023   7A07         MOV     R2,#0x7
   \   000025   7B00         MOV     R3,#0x0
   \   000027   02....       LJMP    ??gyro_self_test_1 & 0xFFFF
   1975          
   1976              tmp[0] &= 0x1F;
   \                     ??gyro_self_test_0:
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   541F         ANL     A,#0x1f
   \   000033   F0           MOVX    @DPTR,A
   1977              tmp[1] &= 0x1F;
   \   000034   7401         MOV     A,#0x1
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   541F         ANL     A,#0x1f
   \   00003C   F0           MOVX    @DPTR,A
   1978              tmp[2] &= 0x1F;
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   541F         ANL     A,#0x1f
   \   000045   F0           MOVX    @DPTR,A
   1979          
   1980              for (jj = 0; jj < 3; jj++) {
   \   000046   7E00         MOV     R6,#0x0
   \   000048   7F00         MOV     R7,#0x0
   1981                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \                     ??gyro_self_test_2:
   \   00004A   8E..         MOV     ?V0 + 0,R6
   \   00004C   8F..         MOV     ?V0 + 1,R7
   \   00004E   7402         MOV     A,#0x2
   \   000050   78..         MOV     R0,#?V0 + 0
   \   000052   12....       LCALL   ?S_SHL
   \   000055   AA..         MOV     R2,?V0 + 0
   \   000057   AB..         MOV     R3,?V0 + 1
   \   000059                ; Setup parameters for call to function labs
   \   000059   7403         MOV     A,#0x3
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   2A           ADD     A,R2
   \   000060   F8           MOV     R0,A
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   3B           ADDC    A,R3
   \   000064   8882         MOV     DPL,R0
   \   000066   F583         MOV     DPH,A
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   12....       LCALL   ?L_MOV_X
   \   00006D   E5..         MOV     A,?V0 + 14
   \   00006F   2A           ADD     A,R2
   \   000070   F582         MOV     DPL,A
   \   000072   E5..         MOV     A,?V0 + 15
   \   000074   3B           ADDC    A,R3
   \   000075   F583         MOV     DPH,A
   \   000077   78..         MOV     R0,#?V0 + 0
   \   000079   12....       LCALL   ?L_SUB_X
   \   00007C   AA..         MOV     R2,?V0 + 0
   \   00007E   AB..         MOV     R3,?V0 + 1
   \   000080   AC..         MOV     R4,?V0 + 2
   \   000082   AD..         MOV     R5,?V0 + 3
   \   000084   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000087   12....       LCALL   ?L_TO_FLT
   \   00008A   90....       MOV     DPTR,#__Constant_37800000
   \   00008D   78..         MOV     R0,#?V0 + 0
   \   00008F   12....       LCALL   ?L_MOV_X
   \   000092   78..         MOV     R0,#?V0 + 4
   \   000094   79..         MOV     R1,#?V0 + 0
   \   000096   12....       LCALL   ?FLT_MUL
   1982                  if (tmp[jj]) {
   \   000099   85..82       MOV     DPL,?XSP + 0
   \   00009C   85..83       MOV     DPH,?XSP + 1
   \   00009F   E582         MOV     A,DPL
   \   0000A1   2E           ADD     A,R6
   \   0000A2   FA           MOV     R2,A
   \   0000A3   E583         MOV     A,DPH
   \   0000A5   3F           ADDC    A,R7
   \   0000A6   FB           MOV     R3,A
   \   0000A7   8A82         MOV     DPL,R2
   \   0000A9   8B83         MOV     DPH,R3
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   6060         JZ      ??gyro_self_test_3
   1983                      st_shift = 3275.f / test.gyro_sens;
   \   0000AE   90....       MOV     DPTR,#__Constant_41c80000
   \   0000B1   78..         MOV     R0,#?V0 + 0
   \   0000B3   12....       LCALL   ?L_MOV_X
   \   0000B6   800F         SJMP    ??gyro_self_test_4
   1984                      while (--tmp[jj])
   1985                          st_shift *= 1.046f;
   \                     ??gyro_self_test_5:
   \   0000B8   90....       MOV     DPTR,#__Constant_3f85e354
   \   0000BB   78..         MOV     R0,#?V0 + 8
   \   0000BD   12....       LCALL   ?L_MOV_X
   \   0000C0   78..         MOV     R0,#?V0 + 0
   \   0000C2   79..         MOV     R1,#?V0 + 8
   \   0000C4   12....       LCALL   ?FLT_MUL
   \                     ??gyro_self_test_4:
   \   0000C7   8A82         MOV     DPL,R2
   \   0000C9   8B83         MOV     DPH,R3
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   14           DEC     A
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   70E8         JNZ     ??gyro_self_test_5
   1986                      st_shift_var = st_shift_cust / st_shift - 1.f;
   1987                      if (fabs(st_shift_var) > test.max_gyro_var)
   \   0000D0   78..         MOV     R0,#?V0 + 4
   \   0000D2   79..         MOV     R1,#?V0 + 0
   \   0000D4   12....       LCALL   ?FLT_DIV
   \   0000D7   90....       MOV     DPTR,#__Constant_bf800000
   \   0000DA   78..         MOV     R0,#?V0 + 0
   \   0000DC   12....       LCALL   ?L_MOV_X
   \   0000DF   78..         MOV     R0,#?V0 + 4
   \   0000E1   79..         MOV     R1,#?V0 + 0
   \   0000E3   12....       LCALL   ?FLT_ADD
   \   0000E6   E5..         MOV     A,?V0 + 7
   \   0000E8   C2E7         CLR     0xE0 /* A   */.7
   \   0000EA   F5..         MOV     ?V0 + 7,A
   \   0000EC   90....       MOV     DPTR,#__Constant_3e0f5c2a
   \   0000EF   78..         MOV     R0,#?V0 + 0
   \   0000F1   12....       LCALL   ?L_MOV_X
   \   0000F4   78..         MOV     R0,#?V0 + 4
   \   0000F6   79..         MOV     R1,#?V0 + 0
   \   0000F8   12....       LCALL   ?FLT_GE
   \   0000FB   5033         JNC     ??gyro_self_test_6
   1988                          result |= 1 << jj;
   \                     ??gyro_self_test_7:
   \   0000FD   75..01       MOV     ?V0 + 0,#0x1
   \   000100   75..00       MOV     ?V0 + 1,#0x0
   \   000103   EE           MOV     A,R6
   \   000104   78..         MOV     R0,#?V0 + 0
   \   000106   12....       LCALL   ?S_SHL
   \   000109   12....       LCALL   ?Subroutine70 & 0xFFFF
   1989                  } else if ((st_shift_cust < test.min_dps) ||
   \                     ??CrossCallReturnLabel_105:
   \   00010C   8022         SJMP    ??gyro_self_test_6
   1990                      (st_shift_cust > test.max_dps))
   \                     ??gyro_self_test_3:
   \   00010E   90....       MOV     DPTR,#__Constant_41200000
   \   000111   78..         MOV     R0,#?V0 + 0
   \   000113   12....       LCALL   ?L_MOV_X
   \   000116   78..         MOV     R0,#?V0 + 4
   \   000118   79..         MOV     R1,#?V0 + 0
   \   00011A   12....       LCALL   ?FLT_LT
   \   00011D   40DE         JC      ??gyro_self_test_7
   \   00011F   90....       MOV     DPTR,#__Constant_42d20001
   \   000122   78..         MOV     R0,#?V0 + 0
   \   000124   12....       LCALL   ?L_MOV_X
   \   000127   78..         MOV     R0,#?V0 + 4
   \   000129   79..         MOV     R1,#?V0 + 0
   \   00012B   12....       LCALL   ?FLT_GE
   \   00012E   40CD         JC      ??gyro_self_test_7
   1991                      result |= 1 << jj;
   1992              }
   \                     ??gyro_self_test_6:
   \   000130   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000133   5003         JNC     $+5
   \   000135   02....       LJMP    ??gyro_self_test_2 & 0xFFFF
   1993              return result;
   \   000138   AA..         MOV     R2,?V0 + 12
   \   00013A   AB..         MOV     R3,?V0 + 13
   \                     ??gyro_self_test_1:
   \   00013C   7405         MOV     A,#0x5
   \   00013E   02....       LJMP    ?Subroutine6 & 0xFFFF
   1994          }
   1995          
   1996          #ifdef AK89xx_SECONDARY
   1997          static int compass_self_test(void)
   1998          {
   1999              unsigned char tmp[6];
   2000              unsigned char tries = 10;
   2001              int result = 0x07;
   2002              short data;
   2003          
   2004              mpu_set_bypass(1);
   2005          
   2006              tmp[0] = AKM_POWER_DOWN;
   2007              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2008                  return 0x07;
   2009              tmp[0] = AKM_BIT_SELF_TEST;
   2010              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
   2011                  goto AKM_restore;
   2012              tmp[0] = AKM_MODE_SELF_TEST;
   2013              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2014                  goto AKM_restore;
   2015          
   2016              do {
   2017                  delay_ms(10);
   2018                  if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
   2019                      goto AKM_restore;
   2020                  if (tmp[0] & AKM_DATA_READY)
   2021                      break;
   2022              } while (tries--);
   2023              if (!(tmp[0] & AKM_DATA_READY))
   2024                  goto AKM_restore;
   2025          
   2026              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
   2027                  goto AKM_restore;
   2028          
   2029              result = 0;
   2030              data = (short)(tmp[1] << 8) | tmp[0];
   2031              if ((data > 100) || (data < -100))
   2032                  result |= 0x01;
   2033              data = (short)(tmp[3] << 8) | tmp[2];
   2034              if ((data > 100) || (data < -100))
   2035                  result |= 0x02;
   2036              data = (short)(tmp[5] << 8) | tmp[4];
   2037              if ((data > -300) || (data < -1000))
   2038                  result |= 0x04;
   2039          
   2040          AKM_restore:
   2041              tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
   2042              i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
   2043              tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
   2044              i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
   2045              mpu_set_bypass(0);
   2046              return result;
   2047          }
   2048          #endif
   2049          #endif
   2050          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2051          static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
   \                     get_st_biases:
   2052          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV     A,#-0x1f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740F         MOV     A,#0xf
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000012   740D         MOV     A,#0xd
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   EC           MOV     A,R4
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   ED           MOV     A,R5
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   E9           MOV     A,R1
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   F0           MOVX    @DPTR,A
   2053              unsigned char data[MAX_PACKET_LENGTH];
   2054              unsigned char packet_count, ii;
   2055              unsigned short fifo_count;
   2056          
   2057              data[0] = 0x01;
   \   000024   7401         MOV     A,#0x1
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   7401         MOV     A,#0x1
   \   00002B   F0           MOVX    @DPTR,A
   2058              data[1] = 0;
   \   00002C   04           INC     A
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
   2059              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \   000032                ; Setup parameters for call to function MPU_Write_Len
   \   000032   04           INC     A
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000039   6007         JZ      ??get_st_biases_0
   2060                  return -1;
   \                     ??get_st_biases_1:
   \   00003B   7AFF         MOV     R2,#-0x1
   \   00003D   7BFF         MOV     R3,#-0x1
   \   00003F   02....       LJMP    ??get_st_biases_2 & 0xFFFF
   2061              delay_ms(200);
   \                     ??get_st_biases_0:
   \   000042                ; Setup parameters for call to function delay_ms
   \   000042   90....       MOV     DPTR,#__Constant_c8
   \   000045   12....       LCALL   ?XLOAD_R2345
   \   000048   12....       LCALL   ??delay_ms?relay
   2062              data[0] = 0;
   \   00004B   7401         MOV     A,#0x1
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   12....       LCALL   ?Subroutine51 & 0xFFFF
   2063              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \                     ??CrossCallReturnLabel_257:
   \   000053   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000056   70E3         JNZ     ??get_st_biases_1
   2064                  return -1;
   2065              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   000058                ; Setup parameters for call to function MPU_Write_Len
   \   000058   7401         MOV     A,#0x1
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000060   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000063   70D6         JNZ     ??get_st_biases_1
   2066                  return -1;
   2067              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \   000065                ; Setup parameters for call to function MPU_Write_Len
   \   000065   7401         MOV     A,#0x1
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   AC82         MOV     R4,DPL
   \   00006C   AD83         MOV     R5,DPH
   \   00006E   7B01         MOV     R3,#0x1
   \   000070   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000073   70C6         JNZ     ??get_st_biases_1
   2068                  return -1;
   2069              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   \   000075                ; Setup parameters for call to function MPU_Write_Len
   \   000075   7401         MOV     A,#0x1
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   AC82         MOV     R4,DPL
   \   00007C   AD83         MOV     R5,DPH
   \   00007E   7B01         MOV     R3,#0x1
   \   000080   90....       MOV     DPTR,#st
   \   000083   E0           MOVX    A,@DPTR
   \   000084   2417         ADD     A,#0x17
   \   000086   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000089   70B0         JNZ     ??get_st_biases_1
   2070                  return -1;
   2071              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   00008B                ; Setup parameters for call to function MPU_Write_Len
   \   00008B   7401         MOV     A,#0x1
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   000093   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   000096   70A3         JNZ     ??get_st_biases_1
   2072                  return -1;
   2073              data[0] = BIT_FIFO_RST | BIT_DMP_RST;
   \   000098   7401         MOV     A,#0x1
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   12....       LCALL   ?Subroutine34 & 0xFFFF
   2074              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \                     ??CrossCallReturnLabel_172:
   \   0000A0   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   0000A3   7096         JNZ     ??get_st_biases_1
   2075                  return -1;
   2076              delay_ms(15);
   \   0000A5                ; Setup parameters for call to function delay_ms
   \   0000A5   90....       MOV     DPTR,#__Constant_f
   \   0000A8   12....       LCALL   ?XLOAD_R2345
   \   0000AB   12....       LCALL   ??delay_ms?relay
   2077              data[0] = st.test->reg_lpf;
   \   0000AE   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   0000B1   A3           INC     DPTR
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   C0E0         PUSH    A
   \   0000B5   7401         MOV     A,#0x1
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   D0E0         POP     A
   \   0000BC   12....       LCALL   ?Subroutine35 & 0xFFFF
   2078              if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \                     ??CrossCallReturnLabel_217:
   \   0000BF   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   0000C2   6003         JZ      $+5
   \   0000C4   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2079                  return -1;
   2080              data[0] = st.test->reg_rate_div;
   \   0000C7   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   C0E0         PUSH    A
   \   0000CD   7401         MOV     A,#0x1
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   D0E0         POP     A
   \   0000D4   12....       LCALL   ?Subroutine36 & 0xFFFF
   2081              if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
   \                     ??CrossCallReturnLabel_211:
   \   0000D7   A3           INC     DPTR
   \   0000D8   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   0000DB   6003         JZ      $+5
   \   0000DD   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   \   0000E0   90....       MOV     DPTR,#st + 33
   \   0000E3   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   0000E6   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0000E9   600E         JZ      ??get_st_biases_3
   2082                  return -1;
   2083              if (hw_test)
   2084                  data[0] = st.test->reg_gyro_fsr | 0xE0;
   \   0000EB   74E0         MOV     A,#-0x20
   \   0000ED   48           ORL     A,R0
   \   0000EE   C0E0         PUSH    A
   \   0000F0   7401         MOV     A,#0x1
   \   0000F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F5   D0E0         POP     A
   \   0000F7   8006         SJMP    ??get_st_biases_4
   2085              else
   2086                  data[0] = st.test->reg_gyro_fsr;
   \                     ??get_st_biases_3:
   \   0000F9   7401         MOV     A,#0x1
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   E8           MOV     A,R0
   \                     ??get_st_biases_4:
   \   0000FF   F0           MOVX    @DPTR,A
   2087              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
   \   000100                ; Setup parameters for call to function MPU_Write_Len
   \   000100   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000103   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   000106   6003         JZ      $+5
   \   000108   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2088                  return -1;
   2089          
   2090              if (hw_test)
   \   00010B   85..82       MOV     DPL,?XSP + 0
   \   00010E   85..83       MOV     DPH,?XSP + 1
   \   000111   E0           MOVX    A,@DPTR
   \   000112   6013         JZ      ??get_st_biases_5
   2091                  data[0] = st.test->reg_accel_fsr | 0xE0;
   \   000114   90....       MOV     DPTR,#st + 33
   \   000117   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00011A   44E0         ORL     A,#0xe0
   \   00011C   C0E0         PUSH    A
   \   00011E   7401         MOV     A,#0x1
   \   000120   12....       LCALL   ?XSTACK_DISP0_8
   \   000123   D0E0         POP     A
   \   000125   8007         SJMP    ??get_st_biases_6
   2092              else
   2093                  data[0] = test.reg_accel_fsr;
   \                     ??get_st_biases_5:
   \   000127   7401         MOV     A,#0x1
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   7418         MOV     A,#0x18
   \                     ??get_st_biases_6:
   \   00012E   12....       LCALL   ?Subroutine17 & 0xFFFF
   2094              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??CrossCallReturnLabel_236:
   \   000131   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000134   6003         JZ      $+5
   \   000136   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2095                  return -1;
   2096              if (hw_test)
   \   000139   85..82       MOV     DPL,?XSP + 0
   \   00013C   85..83       MOV     DPH,?XSP + 1
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   6009         JZ      ??get_st_biases_7
   2097                  delay_ms(200);
   \   000142                ; Setup parameters for call to function delay_ms
   \   000142   90....       MOV     DPTR,#__Constant_c8
   \   000145   12....       LCALL   ?XLOAD_R2345
   \   000148   12....       LCALL   ??delay_ms?relay
   2098          
   2099              /* Fill FIFO for test.wait_ms milliseconds. */
   2100              data[0] = BIT_FIFO_EN;
   \                     ??get_st_biases_7:
   \   00014B   7401         MOV     A,#0x1
   \   00014D   12....       LCALL   ?XSTACK_DISP0_8
   \   000150   7440         MOV     A,#0x40
   \   000152   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   2101              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \                     ??CrossCallReturnLabel_177:
   \   000155   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   000158   6003         JZ      $+5
   \   00015A   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2102                  return -1;
   2103          
   2104              data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
   \   00015D   7401         MOV     A,#0x1
   \   00015F   12....       LCALL   ?XSTACK_DISP0_8
   \   000162   7478         MOV     A,#0x78
   \   000164   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   2105              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??CrossCallReturnLabel_223:
   \   000167   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   00016A   6003         JZ      $+5
   \   00016C   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2106                  return -1;
   2107              delay_ms(test.wait_ms);
   \   00016F                ; Setup parameters for call to function delay_ms
   \   00016F   90....       MOV     DPTR,#__Constant_32
   \   000172   12....       LCALL   ?XLOAD_R2345
   \   000175   12....       LCALL   ??delay_ms?relay
   2108              data[0] = 0;
   \   000178   7401         MOV     A,#0x1
   \   00017A   12....       LCALL   ?XSTACK_DISP0_8
   \   00017D   12....       LCALL   ?Subroutine33 & 0xFFFF
   2109              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??CrossCallReturnLabel_222:
   \   000180   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000183   6003         JZ      $+5
   \   000185   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2110                  return -1;
   2111          
   2112              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \   000188                ; Setup parameters for call to function MPU_Read_Len
   \   000188   7401         MOV     A,#0x1
   \   00018A   12....       LCALL   ?XSTACK_DISP0_8
   \   00018D   12....       LCALL   ??Subroutine115_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000190   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000193   6003         JZ      $+5
   \   000195   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2113                  return -1;
   2114          
   2115              fifo_count = (data[0] << 8) | data[1];
   2116              packet_count = fifo_count / MAX_PACKET_LENGTH;
   \   000198   7401         MOV     A,#0x1
   \   00019A   12....       LCALL   ?XSTACK_DISP0_8
   \   00019D   E0           MOVX    A,@DPTR
   \   00019E   F9           MOV     R1,A
   \   00019F   7402         MOV     A,#0x2
   \   0001A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A4   E0           MOVX    A,@DPTR
   \   0001A5   F8           MOV     R0,A
   \   0001A6   7A0C         MOV     R2,#0xc
   \   0001A8   7B00         MOV     R3,#0x0
   \   0001AA   12....       LCALL   ?US_DIV_MOD
   \   0001AD   E8           MOV     A,R0
   \   0001AE   F5..         MOV     ?V0 + 0,A
   2117              gyro[0] = gyro[1] = gyro[2] = 0;
   \   0001B0   740F         MOV     A,#0xf
   \   0001B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B5   E0           MOVX    A,@DPTR
   \   0001B6   2408         ADD     A,#0x8
   \   0001B8   F5..         MOV     ?V0 + 14,A
   \   0001BA   A3           INC     DPTR
   \   0001BB   E0           MOVX    A,@DPTR
   \   0001BC   3400         ADDC    A,#0x0
   \   0001BE   F5..         MOV     ?V0 + 15,A
   \   0001C0   90....       MOV     DPTR,#__Constant_0
   \   0001C3   12....       LCALL   ?XLOAD_R2345
   \   0001C6   85..82       MOV     DPL,?V0 + 14
   \   0001C9   85..83       MOV     DPH,?V0 + 15
   \   0001CC   12....       LCALL   ?XSTORE_R2345
   \   0001CF   740F         MOV     A,#0xf
   \   0001D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D4   E0           MOVX    A,@DPTR
   \   0001D5   2404         ADD     A,#0x4
   \   0001D7   F5..         MOV     ?V0 + 12,A
   \   0001D9   A3           INC     DPTR
   \   0001DA   E0           MOVX    A,@DPTR
   \   0001DB   3400         ADDC    A,#0x0
   \   0001DD   F5..         MOV     ?V0 + 13,A
   \   0001DF   90....       MOV     DPTR,#__Constant_0
   \   0001E2   12....       LCALL   ?XLOAD_R2345
   \   0001E5   85..82       MOV     DPL,?V0 + 12
   \   0001E8   85..83       MOV     DPH,?V0 + 13
   \   0001EB   12....       LCALL   ?XSTORE_R2345
   \   0001EE   90....       MOV     DPTR,#__Constant_0
   \   0001F1   12....       LCALL   ?XLOAD_R2345
   \   0001F4   740F         MOV     A,#0xf
   \   0001F6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F9   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   0001FC   12....       LCALL   ?XSTORE_R2345
   2118              accel[0] = accel[1] = accel[2] = 0;
   \   0001FF   740D         MOV     A,#0xd
   \   000201   12....       LCALL   ?XSTACK_DISP0_8
   \   000204   E0           MOVX    A,@DPTR
   \   000205   2408         ADD     A,#0x8
   \   000207   FE           MOV     R6,A
   \   000208   A3           INC     DPTR
   \   000209   E0           MOVX    A,@DPTR
   \   00020A   3400         ADDC    A,#0x0
   \   00020C   FF           MOV     R7,A
   \   00020D   90....       MOV     DPTR,#__Constant_0
   \   000210   12....       LCALL   ?XLOAD_R2345
   \   000213   8E82         MOV     DPL,R6
   \   000215   8F83         MOV     DPH,R7
   \   000217   12....       LCALL   ?XSTORE_R2345
   \   00021A   740D         MOV     A,#0xd
   \   00021C   12....       LCALL   ?XSTACK_DISP0_8
   \   00021F   E0           MOVX    A,@DPTR
   \   000220   2404         ADD     A,#0x4
   \   000222   F8           MOV     R0,A
   \   000223   A3           INC     DPTR
   \   000224   E0           MOVX    A,@DPTR
   \   000225   3400         ADDC    A,#0x0
   \   000227   F9           MOV     R1,A
   \   000228   7411         MOV     A,#0x11
   \   00022A   12....       LCALL   ?XSTACK_DISP0_8
   \   00022D   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000230   90....       MOV     DPTR,#__Constant_0
   \   000233   12....       LCALL   ?XLOAD_R2345
   \   000236   7411         MOV     A,#0x11
   \   000238   12....       LCALL   ?XSTACK_DISP0_8
   \   00023B   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   00023E   12....       LCALL   ?XSTORE_R2345
   \   000241   90....       MOV     DPTR,#__Constant_0
   \   000244   12....       LCALL   ?XLOAD_R2345
   \   000247   740D         MOV     A,#0xd
   \   000249   12....       LCALL   ?XSTACK_DISP0_8
   \   00024C   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   00024F   12....       LCALL   ?XSTORE_R2345
   2119          
   2120              for (ii = 0; ii < packet_count; ii++) {
   \   000252   75..00       MOV     ?V0 + 1,#0x0
   \   000255   02....       LJMP    ??get_st_biases_8 & 0xFFFF
   2121                  short accel_cur[3], gyro_cur[3];
   2122                  if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
   \                     ??get_st_biases_9:
   \   000258                ; Setup parameters for call to function MPU_Read_Len
   \   000258   7401         MOV     A,#0x1
   \   00025A   12....       LCALL   ?XSTACK_DISP0_8
   \   00025D   AC82         MOV     R4,DPL
   \   00025F   AD83         MOV     R5,DPH
   \   000261   7B0C         MOV     R3,#0xc
   \   000263   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000266   6003         JZ      $+5
   \   000268   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2123                      return -1;
   2124                  accel_cur[0] = ((short)data[0] << 8) | data[1];
   \   00026B   7401         MOV     A,#0x1
   \   00026D   12....       LCALL   ?XSTACK_DISP0_8
   \   000270   E0           MOVX    A,@DPTR
   \   000271   F9           MOV     R1,A
   \   000272   7402         MOV     A,#0x2
   \   000274   12....       LCALL   ?XSTACK_DISP0_8
   \   000277   E0           MOVX    A,@DPTR
   \   000278   F8           MOV     R0,A
   \   000279   7419         MOV     A,#0x19
   \   00027B   12....       LCALL   ?XSTACK_DISP0_8
   \   00027E   12....       LCALL   ?Subroutine59 & 0xFFFF
   2125                  accel_cur[1] = ((short)data[2] << 8) | data[3];
   \                     ??CrossCallReturnLabel_169:
   \   000281   7403         MOV     A,#0x3
   \   000283   12....       LCALL   ?XSTACK_DISP0_8
   \   000286   E0           MOVX    A,@DPTR
   \   000287   F9           MOV     R1,A
   \   000288   7404         MOV     A,#0x4
   \   00028A   12....       LCALL   ?XSTACK_DISP0_8
   \   00028D   E0           MOVX    A,@DPTR
   \   00028E   FC           MOV     R4,A
   \   00028F   E9           MOV     A,R1
   \   000290   FD           MOV     R5,A
   \   000291   741B         MOV     A,#0x1b
   \   000293   12....       LCALL   ?XSTACK_DISP0_8
   \   000296   EC           MOV     A,R4
   \   000297   F0           MOVX    @DPTR,A
   \   000298   A3           INC     DPTR
   \   000299   ED           MOV     A,R5
   \   00029A   F0           MOVX    @DPTR,A
   2126                  accel_cur[2] = ((short)data[4] << 8) | data[5];
   \   00029B   7405         MOV     A,#0x5
   \   00029D   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A0   E0           MOVX    A,@DPTR
   \   0002A1   F9           MOV     R1,A
   \   0002A2   7406         MOV     A,#0x6
   \   0002A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A7   E0           MOVX    A,@DPTR
   \   0002A8   FA           MOV     R2,A
   \   0002A9   E9           MOV     A,R1
   \   0002AA   FB           MOV     R3,A
   \   0002AB   741D         MOV     A,#0x1d
   \   0002AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B0   12....       LCALL   ?Subroutine94 & 0xFFFF
   2127                  accel[0] += (long)accel_cur[0];
   \                     ??CrossCallReturnLabel_141:
   \   0002B3   7419         MOV     A,#0x19
   \   0002B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B8   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0002BB   740D         MOV     A,#0xd
   \   0002BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C0   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0002C3   12....       LCALL   ?L_ADD_TO_X
   2128                  accel[1] += (long)accel_cur[1];
   \   0002C6   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   0002C9   7411         MOV     A,#0x11
   \   0002CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CE   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0002D1   12....       LCALL   ?L_ADD_TO_X
   2129                  accel[2] += (long)accel_cur[2];
   \   0002D4   8A..         MOV     ?V0 + 4,R2
   \   0002D6   EB           MOV     A,R3
   \   0002D7   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   0002DA   8E82         MOV     DPL,R6
   \   0002DC   8F83         MOV     DPH,R7
   \   0002DE   78..         MOV     R0,#?V0 + 4
   \   0002E0   12....       LCALL   ?L_ADD_TO_X
   2130                  gyro_cur[0] = (((short)data[6] << 8) | data[7]);
   \   0002E3   7407         MOV     A,#0x7
   \   0002E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E8   E0           MOVX    A,@DPTR
   \   0002E9   F9           MOV     R1,A
   \   0002EA   7408         MOV     A,#0x8
   \   0002EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002EF   E0           MOVX    A,@DPTR
   \   0002F0   F8           MOV     R0,A
   \   0002F1   7413         MOV     A,#0x13
   \   0002F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F6   12....       LCALL   ?Subroutine59 & 0xFFFF
   2131                  gyro_cur[1] = (((short)data[8] << 8) | data[9]);
   \                     ??CrossCallReturnLabel_170:
   \   0002F9   7409         MOV     A,#0x9
   \   0002FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002FE   E0           MOVX    A,@DPTR
   \   0002FF   F9           MOV     R1,A
   \   000300   740A         MOV     A,#0xa
   \   000302   12....       LCALL   ?XSTACK_DISP0_8
   \   000305   E0           MOVX    A,@DPTR
   \   000306   FC           MOV     R4,A
   \   000307   E9           MOV     A,R1
   \   000308   FD           MOV     R5,A
   \   000309   7415         MOV     A,#0x15
   \   00030B   12....       LCALL   ?XSTACK_DISP0_8
   \   00030E   EC           MOV     A,R4
   \   00030F   F0           MOVX    @DPTR,A
   \   000310   A3           INC     DPTR
   \   000311   ED           MOV     A,R5
   \   000312   F0           MOVX    @DPTR,A
   2132                  gyro_cur[2] = (((short)data[10] << 8) | data[11]);
   \   000313   740B         MOV     A,#0xb
   \   000315   12....       LCALL   ?XSTACK_DISP0_8
   \   000318   E0           MOVX    A,@DPTR
   \   000319   F9           MOV     R1,A
   \   00031A   740C         MOV     A,#0xc
   \   00031C   12....       LCALL   ?XSTACK_DISP0_8
   \   00031F   E0           MOVX    A,@DPTR
   \   000320   FA           MOV     R2,A
   \   000321   E9           MOV     A,R1
   \   000322   FB           MOV     R3,A
   \   000323   7417         MOV     A,#0x17
   \   000325   12....       LCALL   ?XSTACK_DISP0_8
   \   000328   12....       LCALL   ?Subroutine94 & 0xFFFF
   2133                  gyro[0] += (long)gyro_cur[0];
   \                     ??CrossCallReturnLabel_142:
   \   00032B   7413         MOV     A,#0x13
   \   00032D   12....       LCALL   ?XSTACK_DISP0_8
   \   000330   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000333   740F         MOV     A,#0xf
   \   000335   12....       LCALL   ?XSTACK_DISP0_8
   \   000338   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00033B   12....       LCALL   ?L_ADD_TO_X
   2134                  gyro[1] += (long)gyro_cur[1];
   \   00033E   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000341   85..82       MOV     DPL,?V0 + 12
   \   000344   85..83       MOV     DPH,?V0 + 13
   \   000347   78..         MOV     R0,#?V0 + 4
   \   000349   12....       LCALL   ?L_ADD_TO_X
   2135                  gyro[2] += (long)gyro_cur[2];
   \   00034C   8A..         MOV     ?V0 + 4,R2
   \   00034E   EB           MOV     A,R3
   \   00034F   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   2136              }
   \                     ??CrossCallReturnLabel_207:
   \   000352   85..82       MOV     DPL,?V0 + 14
   \   000355   85..83       MOV     DPH,?V0 + 15
   \   000358   78..         MOV     R0,#?V0 + 4
   \   00035A   12....       LCALL   ?L_ADD_TO_X
   \   00035D   05..         INC     ?V0 + 1
   \                     ??get_st_biases_8:
   \   00035F   E5..         MOV     A,?V0 + 1
   \   000361   C3           CLR     C
   \   000362   95..         SUBB    A,?V0 + 0
   \   000364   5003         JNC     $+5
   \   000366   02....       LJMP    ??get_st_biases_9 & 0xFFFF
   2137          #ifdef EMPL_NO_64BIT
   2138              gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
   2139              gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
   2140              gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
   2141              if (has_accel) {
   2142                  accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
   2143                      packet_count);
   2144                  accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
   2145                      packet_count);
   2146                  accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
   2147                      packet_count);
   2148                  /* Don't remove gravity! */
   2149                  accel[2] -= 65536L;
   2150              }
   2151          #else
   2152              gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
   \   000369   E5..         MOV     A,?V0 + 0
   \   00036B   F5..         MOV     ?V0 + 4,A
   \   00036D   E4           CLR     A
   \   00036E   F5..         MOV     ?V0 + 5,A
   \   000370   F5..         MOV     ?V0 + 6,A
   \   000372   F5..         MOV     ?V0 + 7,A
   \   000374   740F         MOV     A,#0xf
   \   000376   12....       LCALL   ?XSTACK_DISP0_8
   \   000379   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00037C   12....       LCALL   ?L_MOV_X
   \   00037F   7410         MOV     A,#0x10
   \   000381   78..         MOV     R0,#?V0 + 0
   \   000383   12....       LCALL   ?L_SHL
   \   000386   90....       MOV     DPTR,#__Constant_83
   \   000389   78..         MOV     R0,#?V0 + 8
   \   00038B   12....       LCALL   ?L_MOV_X
   \   00038E   78..         MOV     R0,#?V0 + 0
   \   000390   79..         MOV     R1,#?V0 + 8
   \   000392   12....       LCALL   ?UL_DIV_MOD
   \   000395   85....       MOV     ?V0 + 8,?V0 + 4
   \   000398   85....       MOV     ?V0 + 9,?V0 + 5
   \   00039B   85....       MOV     ?V0 + 10,?V0 + 6
   \   00039E   85....       MOV     ?V0 + 11,?V0 + 7
   \   0003A1   78..         MOV     R0,#?V0 + 0
   \   0003A3   79..         MOV     R1,#?V0 + 8
   \   0003A5   12....       LCALL   ?UL_DIV_MOD
   \   0003A8   740F         MOV     A,#0xf
   \   0003AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0003AD   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0003B0   12....       LCALL   ?L_MOV_TO_X
   2153              gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
   \   0003B3   85..82       MOV     DPL,?V0 + 12
   \   0003B6   85..83       MOV     DPH,?V0 + 13
   \   0003B9   78..         MOV     R0,#?V0 + 0
   \   0003BB   12....       LCALL   ?L_MOV_X
   \   0003BE   7410         MOV     A,#0x10
   \   0003C0   78..         MOV     R0,#?V0 + 0
   \   0003C2   12....       LCALL   ?L_SHL
   \   0003C5   90....       MOV     DPTR,#__Constant_83
   \   0003C8   78..         MOV     R0,#?V0 + 8
   \   0003CA   12....       LCALL   ?L_MOV_X
   \   0003CD   78..         MOV     R0,#?V0 + 0
   \   0003CF   79..         MOV     R1,#?V0 + 8
   \   0003D1   12....       LCALL   ?UL_DIV_MOD
   \   0003D4   85....       MOV     ?V0 + 8,?V0 + 4
   \   0003D7   85....       MOV     ?V0 + 9,?V0 + 5
   \   0003DA   85....       MOV     ?V0 + 10,?V0 + 6
   \   0003DD   85....       MOV     ?V0 + 11,?V0 + 7
   \   0003E0   78..         MOV     R0,#?V0 + 0
   \   0003E2   79..         MOV     R1,#?V0 + 8
   \   0003E4   12....       LCALL   ?UL_DIV_MOD
   \   0003E7   85..82       MOV     DPL,?V0 + 12
   \   0003EA   85..83       MOV     DPH,?V0 + 13
   \   0003ED   78..         MOV     R0,#?V0 + 0
   \   0003EF   12....       LCALL   ?L_MOV_TO_X
   2154              gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
   \   0003F2   85..82       MOV     DPL,?V0 + 14
   \   0003F5   85..83       MOV     DPH,?V0 + 15
   \   0003F8   78..         MOV     R0,#?V0 + 0
   \   0003FA   12....       LCALL   ?L_MOV_X
   \   0003FD   7410         MOV     A,#0x10
   \   0003FF   78..         MOV     R0,#?V0 + 0
   \   000401   12....       LCALL   ?L_SHL
   \   000404   90....       MOV     DPTR,#__Constant_83
   \   000407   78..         MOV     R0,#?V0 + 8
   \   000409   12....       LCALL   ?L_MOV_X
   \   00040C   78..         MOV     R0,#?V0 + 0
   \   00040E   79..         MOV     R1,#?V0 + 8
   \   000410   12....       LCALL   ?UL_DIV_MOD
   \   000413   85....       MOV     ?V0 + 8,?V0 + 4
   \   000416   85....       MOV     ?V0 + 9,?V0 + 5
   \   000419   85....       MOV     ?V0 + 10,?V0 + 6
   \   00041C   85....       MOV     ?V0 + 11,?V0 + 7
   \   00041F   78..         MOV     R0,#?V0 + 0
   \   000421   79..         MOV     R1,#?V0 + 8
   \   000423   12....       LCALL   ?UL_DIV_MOD
   \   000426   85..82       MOV     DPL,?V0 + 14
   \   000429   85..83       MOV     DPH,?V0 + 15
   \   00042C   78..         MOV     R0,#?V0 + 0
   \   00042E   12....       LCALL   ?L_MOV_TO_X
   2155              accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
   2156                  packet_count);
   \   000431   740D         MOV     A,#0xd
   \   000433   12....       LCALL   ?XSTACK_DISP0_8
   \   000436   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000439   12....       LCALL   ?L_MOV_X
   \   00043C   7410         MOV     A,#0x10
   \   00043E   78..         MOV     R0,#?V0 + 8
   \   000440   12....       LCALL   ?L_SHL
   \   000443   740B         MOV     A,#0xb
   \   000445   78..         MOV     R0,#?V0 + 8
   \   000447   12....       LCALL   ?UL_SHR
   \   00044A   85....       MOV     ?V0 + 0,?V0 + 4
   \   00044D   F5..         MOV     ?V0 + 1,A
   \   00044F   F5..         MOV     ?V0 + 2,A
   \   000451   F5..         MOV     ?V0 + 3,A
   \   000453   78..         MOV     R0,#?V0 + 8
   \   000455   79..         MOV     R1,#?V0 + 0
   \   000457   12....       LCALL   ?UL_DIV_MOD
   \   00045A   740D         MOV     A,#0xd
   \   00045C   12....       LCALL   ?XSTACK_DISP0_8
   \   00045F   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000462   12....       LCALL   ?L_MOV_TO_X
   2157              accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
   2158                  packet_count);
   \   000465   7411         MOV     A,#0x11
   \   000467   12....       LCALL   ?XSTACK_DISP0_8
   \   00046A   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00046D   12....       LCALL   ?L_MOV_X
   \   000470   7410         MOV     A,#0x10
   \   000472   78..         MOV     R0,#?V0 + 8
   \   000474   12....       LCALL   ?L_SHL
   \   000477   740B         MOV     A,#0xb
   \   000479   78..         MOV     R0,#?V0 + 8
   \   00047B   12....       LCALL   ?UL_SHR
   \   00047E   85....       MOV     ?V0 + 0,?V0 + 4
   \   000481   F5..         MOV     ?V0 + 1,A
   \   000483   F5..         MOV     ?V0 + 2,A
   \   000485   F5..         MOV     ?V0 + 3,A
   \   000487   78..         MOV     R0,#?V0 + 8
   \   000489   79..         MOV     R1,#?V0 + 0
   \   00048B   12....       LCALL   ?UL_DIV_MOD
   \   00048E   7411         MOV     A,#0x11
   \   000490   12....       LCALL   ?XSTACK_DISP0_8
   \   000493   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000496   12....       LCALL   ?L_MOV_TO_X
   2159              accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
   2160                  packet_count);
   \   000499   8E82         MOV     DPL,R6
   \   00049B   8F83         MOV     DPH,R7
   \   00049D   78..         MOV     R0,#?V0 + 0
   \   00049F   12....       LCALL   ?L_MOV_X
   \   0004A2   7410         MOV     A,#0x10
   \   0004A4   78..         MOV     R0,#?V0 + 0
   \   0004A6   12....       LCALL   ?L_SHL
   \   0004A9   740B         MOV     A,#0xb
   \   0004AB   78..         MOV     R0,#?V0 + 0
   \   0004AD   12....       LCALL   ?UL_SHR
   \   0004B0   78..         MOV     R0,#?V0 + 0
   \   0004B2   79..         MOV     R1,#?V0 + 4
   \   0004B4   12....       LCALL   ?UL_DIV_MOD
   \   0004B7   8E82         MOV     DPL,R6
   \   0004B9   8F83         MOV     DPH,R7
   \   0004BB   78..         MOV     R0,#?V0 + 0
   \   0004BD   12....       LCALL   ?L_MOV_TO_X
   2161              /* Don't remove gravity! */
   2162              if (accel[2] > 0L)
   \   0004C0   90....       MOV     DPTR,#__Constant_1
   \   0004C3   78..         MOV     R0,#?V0 + 0
   \   0004C5   12....       LCALL   ?L_MOV_X
   \   0004C8   8F83         MOV     DPH,R7
   \   0004CA   8E82         MOV     DPL,R6
   \   0004CC   78..         MOV     R0,#?V0 + 0
   \   0004CE   12....       LCALL   ?SL_GT_X
   \   0004D1   4005         JC      ??get_st_biases_10
   2163                  accel[2] -= 65536L;
   \   0004D3   90....       MOV     DPTR,#__Constant_ffff0000
   \   0004D6   8003         SJMP    ??get_st_biases_11
   2164              else
   2165                  accel[2] += 65536L;
   \                     ??get_st_biases_10:
   \   0004D8   90....       MOV     DPTR,#__Constant_10000
   \                     ??get_st_biases_11:
   \   0004DB   78..         MOV     R0,#?V0 + 0
   \   0004DD   12....       LCALL   ?L_MOV_X
   \   0004E0   8E82         MOV     DPL,R6
   \   0004E2   8F83         MOV     DPH,R7
   \   0004E4   78..         MOV     R0,#?V0 + 0
   \   0004E6   12....       LCALL   ?L_ADD_TO_X
   2166          #endif
   2167          
   2168              return 0;
   \   0004E9   7A00         MOV     R2,#0x0
   \   0004EB   7B00         MOV     R3,#0x0
   \                     ??get_st_biases_2:
   \   0004ED   741F         MOV     A,#0x1f
   \   0004EF                REQUIRE ?Subroutine6
   \   0004EF                ; // Fall through to label ?Subroutine6
   2169          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   8C..         MOV     ?V0 + 4,R4
   \   000002   ED           MOV     A,R5
   \   000003                REQUIRE ??Subroutine123_0
   \   000003                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                REQUIRE ??Subroutine125_0
   \   000001                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003   78..         MOV     R0,#?V0 + 8
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                REQUIRE ??Subroutine130_0
   \   000001                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   90....       MOV     DPTR,#st + 33
   \   000003                REQUIRE ??Subroutine131_0
   \   000003                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000003   78..         MOV     R0,#?V0 + 0
   \   000005   22           RET
   2170          
   2171          /**
   2172           *  @brief      Trigger gyro/accel/compass self-test.
   2173           *  On success/error, the self-test returns a mask representing the sensor(s)
   2174           *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
   2175           *  a zero (0) indicates a failure.
   2176           *
   2177           *  \n The mask is defined as follows:
   2178           *  \n Bit 0:   Gyro.
   2179           *  \n Bit 1:   Accel.
   2180           *  \n Bit 2:   Compass.
   2181           *
   2182           *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
   2183           *  this function can still be used to obtain the accel and gyro biases.
   2184           *
   2185           *  \n This function must be called with the device either face-up or face-down
   2186           *  (z-axis is parallel to gravity).
   2187           *  @param[out] gyro        Gyro biases in q16 format.
   2188           *  @param[out] accel       Accel biases (if applicable) in q16 format.
   2189           *  @return     Result mask (see above).
   2190           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2191          int mpu_run_self_test(long *gyro, long *accel)
   \                     mpu_run_self_test:
   2192          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   2193          #ifdef MPU6050
   2194              const unsigned char tries = 2;
   2195              long gyro_st[3], accel_st[3];
   2196              unsigned char accel_result, gyro_result;
   2197          #ifdef AK89xx_SECONDARY
   2198              unsigned char compass_result;
   2199          #endif
   2200              int ii;
   2201          #endif
   2202              int result;
   2203              unsigned char accel_fsr, fifo_sensors, sensors_on;
   2204              unsigned short gyro_fsr, sample_rate, lpf;
   2205              unsigned char dmp_was_on;
   2206          
   2207              if (st.chip_cfg.dmp_on) {
   \   000012   90....       MOV     DPTR,#st + 29
   \   000015   E0           MOVX    A,@DPTR
   \   000016   600A         JZ      ??mpu_run_self_test_0
   2208                  mpu_set_dmp_state(0);
   \   000018                ; Setup parameters for call to function mpu_set_dmp_state
   \   000018   7900         MOV     R1,#0x0
   \   00001A   12....       LCALL   ??mpu_set_dmp_state?relay
   2209                  dmp_was_on = 1;
   \   00001D   75..01       MOV     ?V0 + 0,#0x1
   \   000020   8003         SJMP    ??mpu_run_self_test_1
   2210              } else
   2211                  dmp_was_on = 0;
   \                     ??mpu_run_self_test_0:
   \   000022   75..00       MOV     ?V0 + 0,#0x0
   2212          
   2213              /* Get initial settings. */
   2214              mpu_get_gyro_fsr(&gyro_fsr);
   \                     ??mpu_run_self_test_1:
   \   000025                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000025   7406         MOV     A,#0x6
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   AA82         MOV     R2,DPL
   \   00002C   AB83         MOV     R3,DPH
   \   00002E   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2215              mpu_get_accel_fsr(&accel_fsr);
   \   000031                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000031   7401         MOV     A,#0x1
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   12....       LCALL   ??mpu_get_accel_fsr?relay
   2216              mpu_get_lpf(&lpf);
   \   00003D                ; Setup parameters for call to function mpu_get_lpf
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   AA82         MOV     R2,DPL
   \   000044   AB83         MOV     R3,DPH
   \   000046   12....       LCALL   ??mpu_get_lpf?relay
   2217              mpu_get_sample_rate(&sample_rate);
   \   000049                ; Setup parameters for call to function mpu_get_sample_rate
   \   000049   7404         MOV     A,#0x4
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   AA82         MOV     R2,DPL
   \   000050   AB83         MOV     R3,DPH
   \   000052   12....       LCALL   ??mpu_get_sample_rate?relay
   2218              sensors_on = st.chip_cfg.sensors;
   \   000055   90....       MOV     DPTR,#st + 6
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5..         MOV     ?V0 + 1,A
   2219              mpu_get_fifo_config(&fifo_sensors);
   \   00005B                ; Setup parameters for call to function mpu_get_fifo_config
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   ??mpu_get_fifo_config?relay
   2220          
   2221              /* For older chips, the self-test will be different. */
   2222          #if defined MPU6050
   2223              for (ii = 0; ii < tries; ii++)
   \   000068   7E00         MOV     R6,#0x0
   \   00006A   7F00         MOV     R7,#0x0
   2224                  if (!get_st_biases(gyro, accel, 0))
   \                     ??mpu_run_self_test_2:
   \   00006C                ; Setup parameters for call to function get_st_biases
   \   00006C   7900         MOV     R1,#0x0
   \   00006E   AC..         MOV     R4,?V0 + 2
   \   000070   AD..         MOV     R5,?V0 + 3
   \   000072   AA..         MOV     R2,?V0 + 4
   \   000074   AB..         MOV     R3,?V0 + 5
   \   000076   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000079   6005         JZ      ??mpu_run_self_test_3
   \   00007B   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00007E   40EC         JC      ??mpu_run_self_test_2
   2225                      break;
   2226              if (ii == tries) {
   \                     ??mpu_run_self_test_3:
   \   000080   7402         MOV     A,#0x2
   \   000082   6E           XRL     A,R6
   \   000083   7001         JNZ     ??mpu_run_self_test_4
   \   000085   EF           MOV     A,R7
   \                     ??mpu_run_self_test_4:
   \   000086   7004         JNZ     ??mpu_run_self_test_5
   2227                  /* If we reach this point, we most likely encountered an I2C error.
   2228                   * We'll just report an error for all three sensors.
   2229                   */
   2230                  result = 0;
   \                     ??mpu_run_self_test_6:
   \   000088   7E00         MOV     R6,#0x0
   2231                  goto restore;
   \   00008A   805B         SJMP    ??mpu_run_self_test_7
   2232              }
   2233              for (ii = 0; ii < tries; ii++)
   \                     ??mpu_run_self_test_5:
   \   00008C   7E00         MOV     R6,#0x0
   \   00008E   7F00         MOV     R7,#0x0
   2234                  if (!get_st_biases(gyro_st, accel_st, 1))
   \                     ??mpu_run_self_test_8:
   \   000090                ; Setup parameters for call to function get_st_biases
   \   000090   7901         MOV     R1,#0x1
   \   000092   7408         MOV     A,#0x8
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   AC82         MOV     R4,DPL
   \   000099   AD83         MOV     R5,DPH
   \   00009B   7414         MOV     A,#0x14
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   0000A7   6005         JZ      ??mpu_run_self_test_9
   \   0000A9   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0000AC   40E2         JC      ??mpu_run_self_test_8
   2235                      break;
   2236              if (ii == tries) {
   \                     ??mpu_run_self_test_9:
   \   0000AE   7402         MOV     A,#0x2
   \   0000B0   6E           XRL     A,R6
   \   0000B1   7001         JNZ     ??mpu_run_self_test_10
   \   0000B3   EF           MOV     A,R7
   \                     ??mpu_run_self_test_10:
   \   0000B4   60D2         JZ      ??mpu_run_self_test_6
   2237                  /* Again, probably an I2C error. */
   2238                  result = 0;
   2239                  goto restore;
   2240              }
   2241              accel_result = accel_self_test(accel, accel_st);
   \   0000B6                ; Setup parameters for call to function accel_self_test
   \   0000B6   7408         MOV     A,#0x8
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   AC82         MOV     R4,DPL
   \   0000BD   AD83         MOV     R5,DPH
   \   0000BF   AA..         MOV     R2,?V0 + 2
   \   0000C1   AB..         MOV     R3,?V0 + 3
   \   0000C3   12....       LCALL   ??accel_self_test?relay
   \   0000C6   EA           MOV     A,R2
   \   0000C7   F5..         MOV     ?V0 + 2,A
   2242              gyro_result = gyro_self_test(gyro, gyro_st);
   \   0000C9                ; Setup parameters for call to function gyro_self_test
   \   0000C9   7414         MOV     A,#0x14
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   AC82         MOV     R4,DPL
   \   0000D0   AD83         MOV     R5,DPH
   \   0000D2   AA..         MOV     R2,?V0 + 4
   \   0000D4   AB..         MOV     R3,?V0 + 5
   \   0000D6   12....       LCALL   ??gyro_self_test?relay
   2243          
   2244              result = 0;
   \   0000D9   7E00         MOV     R6,#0x0
   2245              if (!gyro_result)
   \   0000DB   EA           MOV     A,R2
   \   0000DC   7001         JNZ     ??mpu_run_self_test_11
   2246                  result |= 0x01;
   \   0000DE   0E           INC     R6
   2247              if (!accel_result)
   \                     ??mpu_run_self_test_11:
   \   0000DF   E5..         MOV     A,?V0 + 2
   \   0000E1   7004         JNZ     ??mpu_run_self_test_7
   2248                  result |= 0x02;
   \   0000E3   7402         MOV     A,#0x2
   \   0000E5   4E           ORL     A,R6
   \   0000E6   FE           MOV     R6,A
   2249          
   2250          #ifdef AK89xx_SECONDARY
   2251              compass_result = compass_self_test();
   2252              if (!compass_result)
   2253                  result |= 0x04;
   2254          #endif
   2255          restore:
   2256          #elif defined MPU6500
   2257              /* For now, this function will return a "pass" result for all three sensors
   2258               * for compatibility with current test applications.
   2259               */
   2260              get_st_biases(gyro, accel, 0);
   2261              result = 0x7;
   2262          #endif
   2263              /* Set to invalid values to ensure no I2C writes are skipped. */
   2264              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_run_self_test_7:
   \   0000E7   12....       LCALL   ?Subroutine52 & 0xFFFF
   2265              st.chip_cfg.accel_fsr = 0xFF;
   2266              st.chip_cfg.lpf = 0xFF;
   2267              st.chip_cfg.sample_rate = 0xFFFF;
   2268              st.chip_cfg.sensors = 0xFF;
   2269              st.chip_cfg.fifo_enable = 0xFF;
   2270              st.chip_cfg.clk_src = INV_CLK_PLL;
   2271              mpu_set_gyro_fsr(gyro_fsr);
   \                     ??CrossCallReturnLabel_72:
   \   0000EA                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   0000EA   7406         MOV     A,#0x6
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   12....       LCALL   ?Subroutine48 & 0xFFFF
   2272              mpu_set_accel_fsr(accel_fsr);
   \                     ??CrossCallReturnLabel_66:
   \   0000F2                ; Setup parameters for call to function mpu_set_accel_fsr
   \   0000F2   7401         MOV     A,#0x1
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   F9           MOV     R1,A
   \   0000F9   12....       LCALL   ??mpu_set_accel_fsr?relay
   2273              mpu_set_lpf(lpf);
   \   0000FC                ; Setup parameters for call to function mpu_set_lpf
   \   0000FC   7402         MOV     A,#0x2
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   12....       LCALL   ?Subroutine49 & 0xFFFF
   2274              mpu_set_sample_rate(sample_rate);
   \                     ??CrossCallReturnLabel_68:
   \   000104                ; Setup parameters for call to function mpu_set_sample_rate
   \   000104   7404         MOV     A,#0x4
   \   000106   12....       LCALL   ?XSTACK_DISP0_8
   \   000109   12....       LCALL   ?Subroutine37 & 0xFFFF
   2275              mpu_set_sensors(sensors_on);
   \                     ??CrossCallReturnLabel_36:
   \   00010C                ; Setup parameters for call to function mpu_set_sensors
   \   00010C   A9..         MOV     R1,?V0 + 1
   \   00010E   12....       LCALL   ??mpu_set_sensors?relay
   2276              mpu_configure_fifo(fifo_sensors);
   \   000111                ; Setup parameters for call to function mpu_configure_fifo
   \   000111   85..82       MOV     DPL,?XSP + 0
   \   000114   85..83       MOV     DPH,?XSP + 1
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F9           MOV     R1,A
   \   000119   12....       LCALL   ??mpu_configure_fifo?relay
   2277          
   2278              if (dmp_was_on)
   \   00011C   E5..         MOV     A,?V0 + 0
   \   00011E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000120   5005         JNC     ??mpu_run_self_test_12
   2279                  mpu_set_dmp_state(1);
   \   000122                ; Setup parameters for call to function mpu_set_dmp_state
   \   000122   7901         MOV     R1,#0x1
   \   000124   12....       LCALL   ??mpu_set_dmp_state?relay
   2280          
   2281              return result;
   \                     ??mpu_run_self_test_12:
   \   000127   EE           MOV     A,R6
   \   000128   FA           MOV     R2,A
   \   000129   7B00         MOV     R3,#0x0
   \   00012B   7420         MOV     A,#0x20
   \   00012D   80..         SJMP    ??Subroutine133_0
   2282          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   12....       LCALL   ??get_st_biases?relay
   \   000003   8B..         MOV     ?V0 + 7,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000003   9402         SUBB    A,#0x2
   \   000005   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000003   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   90....       MOV     DPTR,#st + 4
   \   000003   74FF         MOV     A,#-0x1
   \   000005   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000008   90....       MOV     DPTR,#st + 6
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   90....       MOV     DPTR,#st + 11
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   90....       MOV     DPTR,#st + 8
   \   000013   7401         MOV     A,#0x1
   \   000015   F0           MOVX    @DPTR,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000003   12....       LCALL   ??mpu_set_lpf?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000003   12....       LCALL   ??mpu_set_gyro_fsr?relay
   \   000006   22           RET
   2283          
   2284          /**
   2285           *  @brief      Write to the DMP memory.
   2286           *  This function prevents I2C writes past the bank boundaries. The DMP memory
   2287           *  is only accessible when the chip is awake.
   2288           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2289           *  @param[in]  length      Number of bytes to write.
   2290           *  @param[in]  data        Bytes to write to memory.
   2291           *  @return     0 if successful.
   2292           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2293          int mpu_write_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_write_mem:
   2294                  unsigned char *data)
   2295          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740E         MOV     A,#0xe
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   12....       LCALL   ?Subroutine43 & 0xFFFF
   2296              unsigned char tmp[2];
   2297          
   2298              if (!data)
   \                     ??CrossCallReturnLabel_50:
   \   000016   7006         JNZ     ??mpu_write_mem_0
   2299                  return -1;
   \                     ??mpu_write_mem_1:
   \   000018   7AFF         MOV     R2,#-0x1
   \   00001A   7BFF         MOV     R3,#-0x1
   \   00001C   804B         SJMP    ??mpu_write_mem_2
   2300              if (!st.chip_cfg.sensors)
   \                     ??mpu_write_mem_0:
   \   00001E   90....       MOV     DPTR,#st + 6
   \   000021   E0           MOVX    A,@DPTR
   \   000022   60F4         JZ      ??mpu_write_mem_1
   2301                  return -1;
   2302          
   2303              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   000024   EB           MOV     A,R3
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   F0           MOVX    @DPTR,A
   2304              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   00002C   7401         MOV     A,#0x1
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine26 & 0xFFFF
   2305          
   2306              /* Check bank boundaries. */
   2307              if (tmp[1] + length > st.hw->bank_size)
   \                     ??CrossCallReturnLabel_23:
   \   000034   C082         PUSH    DPL
   \   000036   C083         PUSH    DPH
   \   000038   7401         MOV     A,#0x1
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   2E           ADD     A,R6
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   3F           ADDC    A,R7
   \   000042   FB           MOV     R3,A
   \   000043   D083         POP     DPH
   \   000045   D082         POP     DPL
   \   000047   C3           CLR     C
   \   000048   E0           MOVX    A,@DPTR
   \   000049   9A           SUBB    A,R2
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   9B           SUBB    A,R3
   \   00004D   40C9         JC      ??mpu_write_mem_1
   2308                  return -1;
   2309          
   2310              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   00004F                ; Setup parameters for call to function MPU_Write_Len
   \   00004F   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000052   70C4         JNZ     ??mpu_write_mem_1
   2311                  return -1;
   2312              if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
   \   000054                ; Setup parameters for call to function MPU_Write_Len
   \   000054   AC..         MOV     R4,?V0 + 0
   \   000056   AD..         MOV     R5,?V0 + 1
   \   000058   EE           MOV     A,R6
   \   000059   FB           MOV     R3,A
   \   00005A   90....       MOV     DPTR,#st
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2415         ADD     A,#0x15
   \   000060   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000063   70B3         JNZ     ??mpu_write_mem_1
   2313                  return -1;
   2314              return 0;
   \   000065   7A00         MOV     R2,#0x0
   \   000067   7B00         MOV     R3,#0x0
   \                     ??mpu_write_mem_2:
   \   000069                REQUIRE ?Subroutine5
   \   000069                ; // Fall through to label ?Subroutine5
   2315          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7402         MOV     A,#0x2
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine134_0
   \   000005                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000003   E5..         MOV     A,?V0 + 0
   \   000005   45..         ORL     A,?V0 + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   7B02         MOV     R3,#0x2
   \   00000C   90....       MOV     DPTR,#st
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   2418         ADD     A,#0x18
   \   000012   F5..         MOV     ?V0 + 2,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   3400         ADDC    A,#0x0
   \   000018   85..82       MOV     DPL,?V0 + 2
   \   00001B   F583         MOV     DPH,A
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   FA           MOV     R2,A
   \   00001F   8882         MOV     DPL,R0
   \   000021   8983         MOV     DPH,R1
   \   000023   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000026   E9           MOV     A,R1
   \   000027   22           RET
   2316          
   2317          /**
   2318           *  @brief      Read from the DMP memory.
   2319           *  This function prevents I2C reads past the bank boundaries. The DMP memory
   2320           *  is only accessible when the chip is awake.
   2321           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2322           *  @param[in]  length      Number of bytes to read.
   2323           *  @param[out] data        Bytes read from memory.
   2324           *  @return     0 if successful.
   2325           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2326          int mpu_read_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_read_mem:
   2327                  unsigned char *data)
   2328          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740E         MOV     A,#0xe
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   12....       LCALL   ?Subroutine43 & 0xFFFF
   2329              unsigned char tmp[2];
   2330          
   2331              if (!data)
   \                     ??CrossCallReturnLabel_51:
   \   000016   7006         JNZ     ??mpu_read_mem_0
   2332                  return -1;
   \                     ??mpu_read_mem_1:
   \   000018   7AFF         MOV     R2,#-0x1
   \   00001A   7BFF         MOV     R3,#-0x1
   \   00001C   804B         SJMP    ??mpu_read_mem_2
   2333              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_mem_0:
   \   00001E   90....       MOV     DPTR,#st + 6
   \   000021   E0           MOVX    A,@DPTR
   \   000022   60F4         JZ      ??mpu_read_mem_1
   2334                  return -1;
   2335          
   2336              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   000024   EB           MOV     A,R3
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   F0           MOVX    @DPTR,A
   2337              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   00002C   7401         MOV     A,#0x1
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine26 & 0xFFFF
   2338          
   2339              /* Check bank boundaries. */
   2340              if (tmp[1] + length > st.hw->bank_size)
   \                     ??CrossCallReturnLabel_24:
   \   000034   C082         PUSH    DPL
   \   000036   C083         PUSH    DPH
   \   000038   7401         MOV     A,#0x1
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   2E           ADD     A,R6
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   3F           ADDC    A,R7
   \   000042   FB           MOV     R3,A
   \   000043   D083         POP     DPH
   \   000045   D082         POP     DPL
   \   000047   C3           CLR     C
   \   000048   E0           MOVX    A,@DPTR
   \   000049   9A           SUBB    A,R2
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   9B           SUBB    A,R3
   \   00004D   40C9         JC      ??mpu_read_mem_1
   2341                  return -1;
   2342          
   2343              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   00004F                ; Setup parameters for call to function MPU_Write_Len
   \   00004F   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000052   70C4         JNZ     ??mpu_read_mem_1
   2344                  return -1;
   2345              if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
   \   000054                ; Setup parameters for call to function MPU_Read_Len
   \   000054   AC..         MOV     R4,?V0 + 0
   \   000056   AD..         MOV     R5,?V0 + 1
   \   000058   EE           MOV     A,R6
   \   000059   FB           MOV     R3,A
   \   00005A   90....       MOV     DPTR,#st
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2415         ADD     A,#0x15
   \   000060   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000063   70B3         JNZ     ??mpu_read_mem_1
   2346                  return -1;
   2347              return 0;
   \   000065   7A00         MOV     R2,#0x0
   \   000067   7B00         MOV     R3,#0x0
   \                     ??mpu_read_mem_2:
   \   000069   80..         SJMP    ?Subroutine5
   2348          }
   2349          
   2350          /**
   2351           *  @brief      Load and verify DMP image.
   2352           *  @param[in]  length      Length of DMP image.
   2353           *  @param[in]  firmware    DMP code.
   2354           *  @param[in]  start_addr  Starting address of DMP code memory.
   2355           *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
   2356           *  @return     0 if successful.
   2357           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2358          int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
   \                     mpu_load_firmware:
   2359              unsigned short start_addr, unsigned short sample_rate)
   2360          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   \   000012   7428         MOV     A,#0x28
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   00001A   742A         MOV     A,#0x2a
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 6,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 7,A
   2361              unsigned short ii;
   2362              unsigned short this_write;
   2363              /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
   2364          #define LOAD_CHUNK  (16)
   2365              unsigned char cur[LOAD_CHUNK], tmp[2];
   2366          
   2367              if (st.chip_cfg.dmp_loaded)
   \   000026   90....       MOV     DPTR,#st + 30
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6007         JZ      ??mpu_load_firmware_0
   2368                  /* DMP should only be loaded once. */
   2369                  return -1;
   \                     ??mpu_load_firmware_1:
   \   00002C   7AFF         MOV     R2,#-0x1
   \                     ??mpu_load_firmware_2:
   \   00002E   7BFF         MOV     R3,#-0x1
   \   000030   02....       LJMP    ??CrossCallReturnLabel_254 & 0xFFFF
   2370          
   2371              if (!firmware)
   \                     ??mpu_load_firmware_0:
   \   000033   EC           MOV     A,R4
   \   000034   45..         ORL     A,?V0 + 5
   \   000036   60F4         JZ      ??mpu_load_firmware_1
   2372                  return -1;
   2373              for (ii = 0; ii < length; ii += this_write) {
   \   000038   7E00         MOV     R6,#0x0
   \   00003A   7F00         MOV     R7,#0x0
   \   00003C   8008         SJMP    ??mpu_load_firmware_3
   \                     ??mpu_load_firmware_4:
   \   00003E   EE           MOV     A,R6
   \   00003F   25..         ADD     A,?V0 + 10
   \   000041   FE           MOV     R6,A
   \   000042   EF           MOV     A,R7
   \   000043   35..         ADDC    A,?V0 + 11
   \   000045   FF           MOV     R7,A
   \                     ??mpu_load_firmware_3:
   \   000046   C3           CLR     C
   \   000047   EE           MOV     A,R6
   \   000048   95..         SUBB    A,?V0 + 2
   \   00004A   EF           MOV     A,R7
   \   00004B   95..         SUBB    A,?V0 + 3
   \   00004D   4003         JC      $+5
   \   00004F   02....       LJMP    ??mpu_load_firmware_5 & 0xFFFF
   2374                  this_write = min(LOAD_CHUNK, length - ii);
   \   000052   E5..         MOV     A,?V0 + 2
   \   000054   C3           CLR     C
   \   000055   9E           SUBB    A,R6
   \   000056   F8           MOV     R0,A
   \   000057   E5..         MOV     A,?V0 + 3
   \   000059   9F           SUBB    A,R7
   \   00005A   F9           MOV     R1,A
   \   00005B   C3           CLR     C
   \   00005C   E8           MOV     A,R0
   \   00005D   9411         SUBB    A,#0x11
   \   00005F   E9           MOV     A,R1
   \   000060   9400         SUBB    A,#0x0
   \   000062   4008         JC      ??mpu_load_firmware_6
   \   000064   75..10       MOV     ?V0 + 10,#0x10
   \   000067   75..00       MOV     ?V0 + 11,#0x0
   \   00006A   8004         SJMP    ??mpu_load_firmware_7
   \                     ??mpu_load_firmware_6:
   \   00006C   88..         MOV     ?V0 + 10,R0
   \   00006E   89..         MOV     ?V0 + 11,R1
   2375                  if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
   \                     ??mpu_load_firmware_7:
   \   000070   E5..         MOV     A,?V0 + 4
   \   000072   2E           ADD     A,R6
   \   000073   F5..         MOV     ?V0 + 12,A
   \   000075   E5..         MOV     A,?V0 + 5
   \   000077   3F           ADDC    A,R7
   \   000078   F5..         MOV     ?V0 + 13,A
   \   00007A                ; Setup parameters for call to function mpu_write_mem
   \   00007A   78..         MOV     R0,#?V0 + 12
   \   00007C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007F   AC..         MOV     R4,?V0 + 10
   \   000081   AD..         MOV     R5,?V0 + 11
   \   000083   EE           MOV     A,R6
   \   000084   FA           MOV     R2,A
   \   000085   EF           MOV     A,R7
   \   000086   FB           MOV     R3,A
   \   000087   12....       LCALL   ??mpu_write_mem?relay
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   8B..         MOV     ?V0 + 9,R3
   \   000091   EA           MOV     A,R2
   \   000092   45..         ORL     A,?V0 + 9
   \   000094   7096         JNZ     ??mpu_load_firmware_1
   2376                      return -1;
   2377                  if (mpu_read_mem(ii, this_write, cur))
   \   000096                ; Setup parameters for call to function mpu_read_mem
   \   000096   7402         MOV     A,#0x2
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   8582..       MOV     ?V0 + 8,DPL
   \   00009E   8583..       MOV     ?V0 + 9,DPH
   \   0000A1   78..         MOV     R0,#?V0 + 8
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A6   AC..         MOV     R4,?V0 + 10
   \   0000A8   AD..         MOV     R5,?V0 + 11
   \   0000AA   EE           MOV     A,R6
   \   0000AB   FA           MOV     R2,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   FB           MOV     R3,A
   \   0000AE   12....       LCALL   ??mpu_read_mem?relay
   \   0000B1   7402         MOV     A,#0x2
   \   0000B3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B6   8B..         MOV     ?V0 + 9,R3
   \   0000B8   EA           MOV     A,R2
   \   0000B9   45..         ORL     A,?V0 + 9
   \   0000BB   6003         JZ      $+5
   \   0000BD   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2378                      return -1;
   2379                  if (memcmp(firmware+ii, cur, this_write))
   \   0000C0                ; Setup parameters for call to function memcmp
   \   0000C0   78..         MOV     R0,#?V0 + 10
   \   0000C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C5   7404         MOV     A,#0x4
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   AC82         MOV     R4,DPL
   \   0000CC   AD83         MOV     R5,DPH
   \   0000CE   AA..         MOV     R2,?V0 + 12
   \   0000D0   AB..         MOV     R3,?V0 + 13
   \   0000D2   12....       LCALL   ??memcmp?relay
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DA   8B..         MOV     ?V0 + 9,R3
   \   0000DC   EA           MOV     A,R2
   \   0000DD   45..         ORL     A,?V0 + 9
   \   0000DF   7003         JNZ     $+5
   \   0000E1   02....       LJMP    ??mpu_load_firmware_4 & 0xFFFF
   2380                      return -2;
   \   0000E4   7AFE         MOV     R2,#-0x2
   \   0000E6   02....       LJMP    ??mpu_load_firmware_2 & 0xFFFF
   2381              }
   2382          
   2383              /* Set program start address. */
   2384              tmp[0] = start_addr >> 8;
   \                     ??mpu_load_firmware_5:
   \   0000E9   85..82       MOV     DPL,?XSP + 0
   \   0000EC   85..83       MOV     DPH,?XSP + 1
   \   0000EF   E5..         MOV     A,?V0 + 1
   \   0000F1   F0           MOVX    @DPTR,A
   2385              tmp[1] = start_addr & 0xFF;
   \   0000F2   7401         MOV     A,#0x1
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E5..         MOV     A,?V0 + 0
   \   0000F9   12....       LCALL   ?Subroutine54 & 0xFFFF
   2386              if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
   \                     ??CrossCallReturnLabel_74:
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   241A         ADD     A,#0x1a
   \   0000FF   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000102   6003         JZ      $+5
   \   000104   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2387                  return -1;
   2388          
   2389              st.chip_cfg.dmp_loaded = 1;
   \   000107   90....       MOV     DPTR,#st + 30
   \   00010A   7401         MOV     A,#0x1
   \   00010C   F0           MOVX    @DPTR,A
   2390              st.chip_cfg.dmp_sample_rate = sample_rate;
   \   00010D   A3           INC     DPTR
   \   00010E   E5..         MOV     A,?V0 + 6
   \   000110   F0           MOVX    @DPTR,A
   \   000111   A3           INC     DPTR
   \   000112   E5..         MOV     A,?V0 + 7
   \   000114   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   2391              return 0;
   \                     ??CrossCallReturnLabel_254:
   \   000117   7412         MOV     A,#0x12
   \   000119   02....       LJMP    ?Subroutine7 & 0xFFFF
   2392          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000003   7B02         MOV     R3,#0x2
   \   000005   90....       MOV     DPTR,#st
   \   000008   22           RET
   2393          
   2394          /**
   2395           *  @brief      Enable/disable DMP support.
   2396           *  @param[in]  enable  1 to turn on the DMP.
   2397           *  @return     0 if successful.
   2398           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2399          int mpu_set_dmp_state(unsigned char enable)
   \                     mpu_set_dmp_state:
   2400          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2401              unsigned char tmp;
   2402              if (st.chip_cfg.dmp_on == enable)
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   7007         JNZ     ??mpu_set_dmp_state_0
   2403                  return 0;
   \                     ??mpu_set_dmp_state_1:
   \   000013   7A00         MOV     R2,#0x0
   \   000015   7B00         MOV     R3,#0x0
   \                     ??mpu_set_dmp_state_2:
   \   000017   02....       LJMP    ?Subroutine0 & 0xFFFF
   2404          
   2405              if (enable) {
   \                     ??mpu_set_dmp_state_0:
   \   00001A   EE           MOV     A,R6
   \   00001B   6030         JZ      ??mpu_set_dmp_state_3
   2406                  if (!st.chip_cfg.dmp_loaded)
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   7006         JNZ     ??mpu_set_dmp_state_4
   2407                      return -1;
   \   000021   7AFF         MOV     R2,#-0x1
   \   000023   7BFF         MOV     R3,#-0x1
   \   000025   80F0         SJMP    ??mpu_set_dmp_state_2
   2408                  /* Disable data ready interrupt. */
   2409                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_4:
   \   000027                ; Setup parameters for call to function set_int_enable
   \   000027   7900         MOV     R1,#0x0
   \   000029   12....       LCALL   ??set_int_enable?relay
   2410                  /* Disable bypass mode. */
   2411                  mpu_set_bypass(0);
   \   00002C                ; Setup parameters for call to function mpu_set_bypass
   \   00002C   7900         MOV     R1,#0x0
   \   00002E   12....       LCALL   ??mpu_set_bypass?relay
   2412                  /* Keep constant sample rate, FIFO rate controlled by DMP. */
   2413                  mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
   \   000031                ; Setup parameters for call to function mpu_set_sample_rate
   \   000031   90....       MOV     DPTR,#st + 31
   \   000034   12....       LCALL   ?Subroutine37 & 0xFFFF
   2414                  /* Remove FIFO elements. */
   2415                  tmp = 0;
   \                     ??CrossCallReturnLabel_37:
   \   000037   85..82       MOV     DPL,?XSP + 0
   \   00003A   85..83       MOV     DPH,?XSP + 1
   \   00003D   E4           CLR     A
   \   00003E   12....       LCALL   ?Subroutine29 & 0xFFFF
   2416                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2417                  st.chip_cfg.dmp_on = 1;
   \                     ??CrossCallReturnLabel_27:
   \   000041   7401         MOV     A,#0x1
   \   000043   F0           MOVX    @DPTR,A
   2418                  /* Enable DMP interrupt. */
   2419                  set_int_enable(1);
   \   000044                ; Setup parameters for call to function set_int_enable
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   ??set_int_enable?relay
   2420                  mpu_reset_fifo();
   \   000048                ; Setup parameters for call to function mpu_reset_fifo
   \                     ??mpu_set_dmp_state_5:
   \   000048   12....       LCALL   ??mpu_reset_fifo?relay
   \   00004B   80C6         SJMP    ??mpu_set_dmp_state_1
   2421              } else {
   2422                  /* Disable DMP interrupt. */
   2423                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_3:
   \   00004D                ; Setup parameters for call to function set_int_enable
   \   00004D   7900         MOV     R1,#0x0
   \   00004F   12....       LCALL   ??set_int_enable?relay
   2424                  /* Restore FIFO settings. */
   2425                  tmp = st.chip_cfg.fifo_enable;
   \   000052   90....       MOV     DPTR,#st + 11
   \   000055   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000058   12....       LCALL   ?Subroutine29 & 0xFFFF
   2426                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2427                  st.chip_cfg.dmp_on = 0;
   \                     ??CrossCallReturnLabel_28:
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
   2428                  mpu_reset_fifo();
   \   00005D                ; Setup parameters for call to function mpu_reset_fifo
   \   00005D   80E9         SJMP    ??mpu_set_dmp_state_5
   2429              }
   2430              return 0;
   2431          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   7A23         MOV     R2,#0x23
   \   000005   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000008   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   00000B   90....       MOV     DPTR,#st + 29
   \   00000E   22           RET
   2432          
   2433          /**
   2434           *  @brief      Get DMP state.
   2435           *  @param[out] enabled 1 if enabled.
   2436           *  @return     0 if successful.
   2437           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2438          int mpu_get_dmp_state(unsigned char *enabled)
   \                     mpu_get_dmp_state:
   2439          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2440              enabled[0] = st.chip_cfg.dmp_on;
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   02....       LJMP    ?Subroutine3 & 0xFFFF
   2441              return 0;
   2442          }
   2443          
   2444          
   2445          /* This initialization is similar to the one in ak8975.c. */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2446          int setup_compass(void)
   \                     setup_compass:
   2447          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2448          #ifdef AK89xx_SECONDARY
   2449              unsigned char data[4], akm_addr;
   2450          
   2451              mpu_set_bypass(1);
   2452          
   2453              /* Find compass. Possible addresses range from 0x0C to 0x0F. */
   2454              for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
   2455                  int result;
   2456                  result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
   2457                  if (!result && (data[0] == AKM_WHOAMI))
   2458                      break;
   2459              }
   2460          
   2461              if (akm_addr > 0x0F) {
   2462                  /* TODO: Handle this case in all compass-related functions. */
   2463                  log_e("Compass not found.\n");
   2464                  return -1;
   2465              }
   2466          
   2467              st.chip_cfg.compass_addr = akm_addr;
   2468          
   2469              data[0] = AKM_POWER_DOWN;
   2470              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2471                  return -1;
   2472              delay_ms(1);
   2473          
   2474              data[0] = AKM_FUSE_ROM_ACCESS;
   2475              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2476                  return -1;
   2477              delay_ms(1);
   2478          
   2479              /* Get sensitivity adjustment data from fuse ROM. */
   2480              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
   2481                  return -1;
   2482              st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
   2483              st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
   2484              st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
   2485          
   2486              data[0] = AKM_POWER_DOWN;
   2487              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2488                  return -1;
   2489              delay_ms(1);
   2490          
   2491              mpu_set_bypass(0);
   2492          
   2493              /* Set up master mode, master clock, and ES bit. */
   2494              data[0] = 0x40;
   2495              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   2496                  return -1;
   2497          
   2498              /* Slave 0 reads from AKM data registers. */
   2499              data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
   2500              if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
   2501                  return -1;
   2502          
   2503              /* Compass reads start at this register. */
   2504              data[0] = AKM_REG_ST1;
   2505              if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
   2506                  return -1;
   2507          
   2508              /* Enable slave 0, 8-byte reads. */
   2509              data[0] = BIT_SLAVE_EN | 8;
   2510              if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
   2511                  return -1;
   2512          
   2513              /* Slave 1 changes AKM measurement mode. */
   2514              data[0] = st.chip_cfg.compass_addr;
   2515              if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
   2516                  return -1;
   2517          
   2518              /* AKM measurement mode register. */
   2519              data[0] = AKM_REG_CNTL;
   2520              if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
   2521                  return -1;
   2522          
   2523              /* Enable slave 1, 1-byte writes. */
   2524              data[0] = BIT_SLAVE_EN | 1;
   2525              if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
   2526                  return -1;
   2527          
   2528              /* Set slave 1 data. */
   2529              data[0] = AKM_SINGLE_MEASUREMENT;
   2530              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
   2531                  return -1;
   2532          
   2533              /* Trigger slave 0 and slave 1 actions at each sample. */
   2534              data[0] = 0x03;
   2535              if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
   2536                  return -1;
   2537          
   2538          #ifdef MPU9150
   2539              /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
   2540              data[0] = BIT_I2C_MST_VDDIO;
   2541              if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
   2542                  return -1;
   2543          #endif
   2544          
   2545              return 0;
   2546          #else
   2547              return -1;
   \   000000   80..         SJMP    ?Subroutine4
   2548          #endif
   2549          }
   2550          
   2551          /**
   2552           *  @brief      Read raw compass data.
   2553           *  @param[out] data        Raw data in hardware units.
   2554           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   2555           *  @return     0 if successful.
   2556           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2557          int mpu_get_compass_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_compass_reg:
   2558          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2559          #ifdef AK89xx_SECONDARY
   2560              unsigned char tmp[9];
   2561          
   2562              if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   2563                  return -1;
   2564          
   2565          #ifdef AK89xx_BYPASS
   2566              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
   2567                  return -1;
   2568              tmp[8] = AKM_SINGLE_MEASUREMENT;
   2569              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
   2570                  return -1;
   2571          #else
   2572              if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
   2573                  return -1;
   2574          #endif
   2575          
   2576          #if defined AK8975_SECONDARY
   2577              /* AK8975 doesn't have the overrun error bit. */
   2578              if (!(tmp[0] & AKM_DATA_READY))
   2579                  return -2;
   2580              if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
   2581                  return -3;
   2582          #elif defined AK8963_SECONDARY
   2583              /* AK8963 doesn't have the data read error bit. */
   2584              if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
   2585                  return -2;
   2586              if (tmp[7] & AKM_OVERFLOW)
   2587                  return -3;
   2588          #endif
   2589              data[0] = (tmp[2] << 8) | tmp[1];
   2590              data[1] = (tmp[4] << 8) | tmp[3];
   2591              data[2] = (tmp[6] << 8) | tmp[5];
   2592          
   2593              data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
   2594              data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
   2595              data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
   2596          
   2597              if (timestamp)
   2598                  get_ms(timestamp);
   2599              return 0;
   2600          #else
   2601              return -1;
   \   000000                REQUIRE ?Subroutine4
   \   000000                ; // Fall through to label ?Subroutine4
   2602          #endif
   2603          }
   2604          
   2605          /**
   2606           *  @brief      Get the compass full-scale range.
   2607           *  @param[out] fsr Current full-scale range.
   2608           *  @return     0 if successful.
   2609           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2610          int mpu_get_compass_fsr(unsigned short *fsr)
   \                     mpu_get_compass_fsr:
   2611          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2612          #ifdef AK89xx_SECONDARY
   2613              fsr[0] = st.hw->compass_fsr;
   2614              return 0;
   2615          #else
   2616              return -1;
   \   000000   80..         SJMP    ?Subroutine4
   2617          #endif
   2618          }
   2619          
   2620          /**
   2621           *  @brief      Enters LP accel motion interrupt mode.
   2622           *  The behavior of this feature is very different between the MPU6050 and the
   2623           *  MPU6500. Each chip's version of this feature is explained below.
   2624           *
   2625           *  \n MPU6050:
   2626           *  \n When this mode is first enabled, the hardware captures a single accel
   2627           *  sample, and subsequent samples are compared with this one to determine if
   2628           *  the device is in motion. Therefore, whenever this "locked" sample needs to
   2629           *  be changed, this function must be called again.
   2630           *
   2631           *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
   2632           *  increments.
   2633           *
   2634           *  \n Low-power accel mode supports the following frequencies:
   2635           *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
   2636           *
   2637           *  \n MPU6500:
   2638           *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
   2639           *  sample. The hardware monitors the accel data and detects any large change
   2640           *  over a short period of time.
   2641           *
   2642           *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
   2643           *  increments.
   2644           *
   2645           *  \n MPU6500 Low-power accel mode supports the following frequencies:
   2646           *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
   2647           *
   2648           *  \n\n NOTES:
   2649           *  \n The driver will round down @e thresh to the nearest supported value if
   2650           *  an unsupported threshold is selected.
   2651           *  \n To select a fractional wake-up frequency, round down the value passed to
   2652           *  @e lpa_freq.
   2653           *  \n The MPU6500 does not support a delay parameter. If this function is used
   2654           *  for the MPU6500, the value passed to @e time will be ignored.
   2655           *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
   2656           *  the previous configuration.
   2657           *
   2658           *  @param[in]  thresh      Motion threshold in mg.
   2659           *  @param[in]  time        Duration in milliseconds that the accel data must
   2660           *                          exceed @e thresh before motion is reported.
   2661           *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
   2662           *  @return     0 if successful.
   2663           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2664          int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
   \                     mpu_lp_motion_interrupt:
   2665              unsigned char lpa_freq)
   2666          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
   2667              unsigned char data[3];
   2668          
   2669              if (lpa_freq) {
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??mpu_lp_motion_interrupt_0 & 0xFFFF
   2670                  unsigned char thresh_hw;
   2671          
   2672          #if defined MPU6050
   2673                  /* TODO: Make these const/#defines. */
   2674                  /* 1LSb = 32mg. */
   2675                  if (thresh > 8160)
   \   000013   C3           CLR     C
   \   000014   EA           MOV     A,R2
   \   000015   94E1         SUBB    A,#-0x1f
   \   000017   EB           MOV     A,R3
   \   000018   941F         SUBB    A,#0x1f
   \   00001A   4005         JC      ??mpu_lp_motion_interrupt_1
   2676                      thresh_hw = 255;
   \   00001C   75..FF       MOV     ?V0 + 0,#-0x1
   \   00001F   8019         SJMP    ??mpu_lp_motion_interrupt_2
   2677                  else if (thresh < 32)
   \                     ??mpu_lp_motion_interrupt_1:
   \   000021   C3           CLR     C
   \   000022   EA           MOV     A,R2
   \   000023   9420         SUBB    A,#0x20
   \   000025   EB           MOV     A,R3
   \   000026   9400         SUBB    A,#0x0
   \   000028   5005         JNC     ??mpu_lp_motion_interrupt_3
   2678                      thresh_hw = 1;
   \   00002A   75..01       MOV     ?V0 + 0,#0x1
   \   00002D   800B         SJMP    ??mpu_lp_motion_interrupt_2
   2679                  else
   2680                      thresh_hw = thresh >> 5;
   \                     ??mpu_lp_motion_interrupt_3:
   \   00002F   8A..         MOV     ?V0 + 0,R2
   \   000031   8B..         MOV     ?V0 + 1,R3
   \   000033   7405         MOV     A,#0x5
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?US_SHR
   2681          #elif defined MPU6500
   2682                  /* 1LSb = 4mg. */
   2683                  if (thresh > 1020)
   2684                      thresh_hw = 255;
   2685                  else if (thresh < 4)
   2686                      thresh_hw = 1;
   2687                  else
   2688                      thresh_hw = thresh >> 2;
   2689          #endif
   2690          
   2691                  if (!time)
   \                     ??mpu_lp_motion_interrupt_2:
   \   00003A   EF           MOV     A,R7
   \   00003B   7002         JNZ     ??mpu_lp_motion_interrupt_4
   2692                      /* Minimum duration must be 1ms. */
   2693                      time = 1;
   \   00003D   7F01         MOV     R7,#0x1
   2694          
   2695          #if defined MPU6050
   2696                  if (lpa_freq > 40)
   \                     ??mpu_lp_motion_interrupt_4:
   \   00003F   EE           MOV     A,R6
   \   000040   C3           CLR     C
   \   000041   9429         SUBB    A,#0x29
   \   000043   4007         JC      ??mpu_lp_motion_interrupt_5
   2697          #elif defined MPU6500
   2698                  if (lpa_freq > 640)
   2699          #endif
   2700                      /* At this point, the chip has not been re-configured, so the
   2701                       * function can safely exit.
   2702                       */
   2703                      return -1;
   \                     ??mpu_lp_motion_interrupt_6:
   \   000045   7AFF         MOV     R2,#-0x1
   \   000047   7BFF         MOV     R3,#-0x1
   \   000049   02....       LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
   2704          
   2705                  if (!st.chip_cfg.int_motion_only) {
   \                     ??mpu_lp_motion_interrupt_5:
   \   00004C   90....       MOV     DPTR,#st + 16
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   7042         JNZ     ??mpu_lp_motion_interrupt_8
   2706                      /* Store current settings for later. */
   2707                      if (st.chip_cfg.dmp_on) {
   \   000052   90....       MOV     DPTR,#st + 29
   \   000055   E0           MOVX    A,@DPTR
   \   000056   600C         JZ      ??mpu_lp_motion_interrupt_9
   2708                          mpu_set_dmp_state(0);
   \   000058                ; Setup parameters for call to function mpu_set_dmp_state
   \   000058   7900         MOV     R1,#0x0
   \   00005A   12....       LCALL   ??mpu_set_dmp_state?relay
   2709                          st.chip_cfg.cache.dmp_on = 1;
   \   00005D   90....       MOV     DPTR,#st + 26
   \   000060   7401         MOV     A,#0x1
   \   000062   8004         SJMP    ??mpu_lp_motion_interrupt_10
   2710                      } else
   2711                          st.chip_cfg.cache.dmp_on = 0;
   \                     ??mpu_lp_motion_interrupt_9:
   \   000064   90....       MOV     DPTR,#st + 26
   \   000067   E4           CLR     A
   \                     ??mpu_lp_motion_interrupt_10:
   \   000068   F0           MOVX    @DPTR,A
   2712                      mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
   \   000069                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000069   7A..         MOV     R2,#(st + 17) & 0xff
   \   00006B   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   00006D   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2713                      mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
   \   000070                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000070   7A..         MOV     R2,#(st + 19) & 0xff
   \   000072   7B..         MOV     R3,#((st + 19) >> 8) & 0xff
   \   000074   12....       LCALL   ??mpu_get_accel_fsr?relay
   2714                      mpu_get_lpf(&st.chip_cfg.cache.lpf);
   \   000077                ; Setup parameters for call to function mpu_get_lpf
   \   000077   7A..         MOV     R2,#(st + 20) & 0xff
   \   000079   7B..         MOV     R3,#((st + 20) >> 8) & 0xff
   \   00007B   12....       LCALL   ??mpu_get_lpf?relay
   2715                      mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
   \   00007E                ; Setup parameters for call to function mpu_get_sample_rate
   \   00007E   7A..         MOV     R2,#(st + 22) & 0xff
   \   000080   7B..         MOV     R3,#((st + 22) >> 8) & 0xff
   \   000082   12....       LCALL   ??mpu_get_sample_rate?relay
   2716                      st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
   \   000085   90....       MOV     DPTR,#st + 6
   \   000088   E0           MOVX    A,@DPTR
   \   000089   90....       MOV     DPTR,#st + 24
   \   00008C   F0           MOVX    @DPTR,A
   2717                      mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
   \   00008D                ; Setup parameters for call to function mpu_get_fifo_config
   \   00008D   7A..         MOV     R2,#(st + 25) & 0xff
   \   00008F   7B..         MOV     R3,#((st + 25) >> 8) & 0xff
   \   000091   12....       LCALL   ??mpu_get_fifo_config?relay
   2718                  }
   2719          
   2720          #ifdef MPU6050
   2721                  /* Disable hardware interrupts for now. */
   2722                  set_int_enable(0);
   \                     ??mpu_lp_motion_interrupt_8:
   \   000094                ; Setup parameters for call to function set_int_enable
   \   000094   7900         MOV     R1,#0x0
   \   000096   12....       LCALL   ??set_int_enable?relay
   2723          
   2724                  /* Enter full-power accel-only mode. */
   2725                  mpu_lp_accel_mode(0);
   \   000099                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000099   7900         MOV     R1,#0x0
   \   00009B   12....       LCALL   ??mpu_lp_accel_mode?relay
   2726          
   2727                  /* Override current LPF (and HPF) settings to obtain a valid accel
   2728                   * reading.
   2729                   */
   2730                  data[0] = INV_FILTER_256HZ_NOLPF2;
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   E4           CLR     A
   \   0000A5   12....       LCALL   ?Subroutine35 & 0xFFFF
   2731                  if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \                     ??CrossCallReturnLabel_218:
   \   0000A8   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   0000AB   7098         JNZ     ??mpu_lp_motion_interrupt_6
   2732                      return -1;
   2733          
   2734                  /* NOTE: Digital high pass filter should be configured here. Since this
   2735                   * driver doesn't modify those bits anywhere, they should already be
   2736                   * cleared by default.
   2737                   */
   2738          
   2739                  /* Configure the device to send motion interrupts. */
   2740                  /* Enable motion interrupt. */
   2741                  data[0] = BIT_MOT_INT_EN;
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   7440         MOV     A,#0x40
   \   0000B5   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   2742                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \                     ??CrossCallReturnLabel_262:
   \   0000B8   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   0000BB   6003         JZ      $+5
   \   0000BD   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2743                      goto lp_int_restore;
   2744          
   2745                  /* Set motion interrupt parameters. */
   2746                  data[0] = thresh_hw;
   \   0000C0   85..82       MOV     DPL,?XSP + 0
   \   0000C3   85..83       MOV     DPH,?XSP + 1
   \   0000C6   E5..         MOV     A,?V0 + 0
   \   0000C8   F0           MOVX    @DPTR,A
   2747                  data[1] = time;
   \   0000C9   7401         MOV     A,#0x1
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   EF           MOV     A,R7
   \   0000CF   12....       LCALL   ?Subroutine54 & 0xFFFF
   2748                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
   \                     ??CrossCallReturnLabel_75:
   \   0000D2   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   0000D5   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   0000D8   6003         JZ      $+5
   \   0000DA   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2749                      goto lp_int_restore;
   2750          
   2751                  /* Force hardware to "lock" current accel sample. */
   2752                  delay_ms(5);
   \   0000DD                ; Setup parameters for call to function delay_ms
   \   0000DD   90....       MOV     DPTR,#__Constant_5
   \   0000E0   12....       LCALL   ?XLOAD_R2345
   \   0000E3   12....       LCALL   ??delay_ms?relay
   2753                  data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
   \   0000E6   90....       MOV     DPTR,#st + 5
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   33           RLC     A
   \   0000EB   33           RLC     A
   \   0000EC   33           RLC     A
   \   0000ED   54F8         ANL     A,#0xf8
   \   0000EF   4407         ORL     A,#0x7
   \   0000F1   85..82       MOV     DPL,?XSP + 0
   \   0000F4   85..83       MOV     DPH,?XSP + 1
   \   0000F7   12....       LCALL   ?Subroutine17 & 0xFFFF
   2754                  if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??CrossCallReturnLabel_237:
   \   0000FA   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   0000FD   7075         JNZ     ??mpu_lp_motion_interrupt_11
   2755                      goto lp_int_restore;
   2756          
   2757                  /* Set up LP accel mode. */
   2758                  data[0] = BIT_LPA_CYCLE;
   \   0000FF   85..82       MOV     DPL,?XSP + 0
   \   000102   85..83       MOV     DPH,?XSP + 1
   \   000105   7420         MOV     A,#0x20
   \   000107   F0           MOVX    @DPTR,A
   2759                  if (lpa_freq == 1)
   \   000108   7401         MOV     A,#0x1
   \   00010A   6E           XRL     A,R6
   \   00010B   7008         JNZ     ??mpu_lp_motion_interrupt_12
   2760                      data[1] = INV_LPA_1_25HZ;
   \   00010D   7401         MOV     A,#0x1
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   E4           CLR     A
   \   000113   8023         SJMP    ??mpu_lp_motion_interrupt_13
   2761                  else if (lpa_freq <= 5)
   \                     ??mpu_lp_motion_interrupt_12:
   \   000115   EE           MOV     A,R6
   \   000116   C3           CLR     C
   \   000117   9406         SUBB    A,#0x6
   \   000119   5009         JNC     ??mpu_lp_motion_interrupt_14
   2762                      data[1] = INV_LPA_5HZ;
   \   00011B   7401         MOV     A,#0x1
   \   00011D   12....       LCALL   ?XSTACK_DISP0_8
   \   000120   7401         MOV     A,#0x1
   \   000122   8014         SJMP    ??mpu_lp_motion_interrupt_13
   2763                  else if (lpa_freq <= 20)
   \                     ??mpu_lp_motion_interrupt_14:
   \   000124   EE           MOV     A,R6
   \   000125   C3           CLR     C
   \   000126   9415         SUBB    A,#0x15
   \   000128   7401         MOV     A,#0x1
   \   00012A   5007         JNC     ??mpu_lp_motion_interrupt_15
   2764                      data[1] = INV_LPA_20HZ;
   \   00012C   12....       LCALL   ?XSTACK_DISP0_8
   \   00012F   7402         MOV     A,#0x2
   \   000131   8005         SJMP    ??mpu_lp_motion_interrupt_13
   2765                  else
   2766                      data[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_motion_interrupt_15:
   \   000133   12....       LCALL   ?XSTACK_DISP0_8
   \   000136   7403         MOV     A,#0x3
   \                     ??mpu_lp_motion_interrupt_13:
   \   000138   F0           MOVX    @DPTR,A
   2767                  data[1] = (data[1] << 6) | BIT_STBY_XYZG;
   \   000139   7401         MOV     A,#0x1
   \   00013B   12....       LCALL   ?XSTACK_DISP0_8
   \   00013E   12....       LCALL   ?Subroutine11 & 0xFFFF
   2768                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \                     ??CrossCallReturnLabel_276:
   \   000141   7031         JNZ     ??mpu_lp_motion_interrupt_11
   2769                      goto lp_int_restore;
   2770          
   2771                  st.chip_cfg.int_motion_only = 1;
   \   000143   90....       MOV     DPTR,#st + 16
   \   000146   7401         MOV     A,#0x1
   \   000148   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   2772                  return 0;
   2773          #elif defined MPU6500
   2774                  /* Disable hardware interrupts. */
   2775                  set_int_enable(0);
   2776          
   2777                  /* Enter full-power accel-only mode, no FIFO/DMP. */
   2778                  data[0] = 0;
   2779                  data[1] = 0;
   2780                  data[2] = BIT_STBY_XYZG;
   2781                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
   2782                      goto lp_int_restore;
   2783          
   2784                  /* Set motion threshold. */
   2785                  data[0] = thresh_hw;
   2786                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
   2787                      goto lp_int_restore;
   2788          
   2789                  /* Set wake frequency. */
   2790                  if (lpa_freq == 1)
   2791                      data[0] = INV_LPA_1_25HZ;
   2792                  else if (lpa_freq == 2)
   2793                      data[0] = INV_LPA_2_5HZ;
   2794                  else if (lpa_freq <= 5)
   2795                      data[0] = INV_LPA_5HZ;
   2796                  else if (lpa_freq <= 10)
   2797                      data[0] = INV_LPA_10HZ;
   2798                  else if (lpa_freq <= 20)
   2799                      data[0] = INV_LPA_20HZ;
   2800                  else if (lpa_freq <= 40)
   2801                      data[0] = INV_LPA_40HZ;
   2802                  else if (lpa_freq <= 80)
   2803                      data[0] = INV_LPA_80HZ;
   2804                  else if (lpa_freq <= 160)
   2805                      data[0] = INV_LPA_160HZ;
   2806                  else if (lpa_freq <= 320)
   2807                      data[0] = INV_LPA_320HZ;
   2808                  else
   2809                      data[0] = INV_LPA_640HZ;
   2810                  if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
   2811                      goto lp_int_restore;
   2812          
   2813                  /* Enable motion interrupt (MPU6500 version). */
   2814                  data[0] = BITS_WOM_EN;
   2815                  if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2816                      goto lp_int_restore;
   2817          
   2818                  /* Enable cycle mode. */
   2819                  data[0] = BIT_LPA_CYCLE;
   2820                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   2821                      goto lp_int_restore;
   2822          
   2823                  /* Enable interrupt. */
   2824                  data[0] = BIT_MOT_INT_EN;
   2825                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   2826                      goto lp_int_restore;
   2827          
   2828                  st.chip_cfg.int_motion_only = 1;
   2829                  return 0;
   2830          #endif
   2831              } else {
   \                     ??CrossCallReturnLabel_255:
   \   00014B   8066         SJMP    ??mpu_lp_motion_interrupt_7
   2832                  /* Don't "restore" the previous state if no state has been saved. */
   2833                  int ii;
   2834                  char *cache_ptr = (char*)&st.chip_cfg.cache;
   2835                  for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
   \                     ??mpu_lp_motion_interrupt_0:
   \   00014D   7800         MOV     R0,#0x0
   \   00014F   7900         MOV     R1,#0x0
   2836                      if (cache_ptr[ii] != 0)
   \                     ??mpu_lp_motion_interrupt_16:
   \   000151   74..         MOV     A,#(st + 17) & 0xff
   \   000153   28           ADD     A,R0
   \   000154   F582         MOV     DPL,A
   \   000156   74..         MOV     A,#((st + 17) >> 8) & 0xff
   \   000158   39           ADDC    A,R1
   \   000159   F583         MOV     DPH,A
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   7016         JNZ     ??mpu_lp_motion_interrupt_11
   2837                          goto lp_int_restore;
   2838                  }
   \   00015E   E8           MOV     A,R0
   \   00015F   2401         ADD     A,#0x1
   \   000161   08           INC     R0
   \   000162   E9           MOV     A,R1
   \   000163   3400         ADDC    A,#0x0
   \   000165   F9           MOV     R1,A
   \   000166   C3           CLR     C
   \   000167   E8           MOV     A,R0
   \   000168   940A         SUBB    A,#0xa
   \   00016A   E9           MOV     A,R1
   \   00016B   9400         SUBB    A,#0x0
   \   00016D   4003         JC      $+5
   \   00016F   02....       LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
   \   000172   80DD         SJMP    ??mpu_lp_motion_interrupt_16
   2839                  /* If we reach this point, motion interrupt mode hasn't been used yet. */
   2840                  return -1;
   2841              }
   2842          lp_int_restore:
   2843              /* Set to invalid values to ensure no I2C writes are skipped. */
   2844              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_lp_motion_interrupt_11:
   \   000174   12....       LCALL   ?Subroutine52 & 0xFFFF
   2845              st.chip_cfg.accel_fsr = 0xFF;
   2846              st.chip_cfg.lpf = 0xFF;
   2847              st.chip_cfg.sample_rate = 0xFFFF;
   2848              st.chip_cfg.sensors = 0xFF;
   2849              st.chip_cfg.fifo_enable = 0xFF;
   2850              st.chip_cfg.clk_src = INV_CLK_PLL;
   2851              mpu_set_sensors(st.chip_cfg.cache.sensors_on);
   \                     ??CrossCallReturnLabel_73:
   \   000177                ; Setup parameters for call to function mpu_set_sensors
   \   000177   90....       MOV     DPTR,#st + 24
   \   00017A   E0           MOVX    A,@DPTR
   \   00017B   F9           MOV     R1,A
   \   00017C   12....       LCALL   ??mpu_set_sensors?relay
   2852              mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
   \   00017F                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   00017F   90....       MOV     DPTR,#st + 17
   \   000182   12....       LCALL   ?Subroutine48 & 0xFFFF
   2853              mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
   \                     ??CrossCallReturnLabel_67:
   \   000185                ; Setup parameters for call to function mpu_set_accel_fsr
   \   000185   90....       MOV     DPTR,#st + 19
   \   000188   E0           MOVX    A,@DPTR
   \   000189   F9           MOV     R1,A
   \   00018A   12....       LCALL   ??mpu_set_accel_fsr?relay
   2854              mpu_set_lpf(st.chip_cfg.cache.lpf);
   \   00018D                ; Setup parameters for call to function mpu_set_lpf
   \   00018D   90....       MOV     DPTR,#st + 20
   \   000190   12....       LCALL   ?Subroutine49 & 0xFFFF
   2855              mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
   \                     ??CrossCallReturnLabel_69:
   \   000193                ; Setup parameters for call to function mpu_set_sample_rate
   \   000193   90....       MOV     DPTR,#st + 22
   \   000196   12....       LCALL   ?Subroutine37 & 0xFFFF
   2856              mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
   \                     ??CrossCallReturnLabel_38:
   \   000199                ; Setup parameters for call to function mpu_configure_fifo
   \   000199   90....       MOV     DPTR,#st + 25
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   F9           MOV     R1,A
   \   00019E   12....       LCALL   ??mpu_configure_fifo?relay
   2857          
   2858              if (st.chip_cfg.cache.dmp_on)
   \   0001A1   90....       MOV     DPTR,#st + 26
   \   0001A4   E0           MOVX    A,@DPTR
   \   0001A5   6005         JZ      ??mpu_lp_motion_interrupt_17
   2859                  mpu_set_dmp_state(1);
   \   0001A7                ; Setup parameters for call to function mpu_set_dmp_state
   \   0001A7   7901         MOV     R1,#0x1
   \   0001A9   12....       LCALL   ??mpu_set_dmp_state?relay
   2860          
   2861          #ifdef MPU6500
   2862              /* Disable motion interrupt (MPU6500 version). */
   2863              data[0] = 0;
   2864              if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2865                  goto lp_int_restore;
   2866          #endif
   2867          
   2868              st.chip_cfg.int_motion_only = 0;
   \                     ??mpu_lp_motion_interrupt_17:
   \   0001AC   90....       MOV     DPTR,#st + 16
   \   0001AF   E4           CLR     A
   \   0001B0   F0           MOVX    @DPTR,A
   2869              return 0;
   \   0001B1   FA           MOV     R2,A
   \   0001B2   FB           MOV     R3,A
   \                     ??mpu_lp_motion_interrupt_7:
   \   0001B3   7403         MOV     A,#0x3
   \   0001B5   02....       LJMP    ??Subroutine103_0 & 0xFFFF
   2870          }
   2871          
   2872          //q30格式,long转float时的除数.
   2873          #define q30  1073741824.0f
   2874          
   2875          //陀螺仪方向设置

   \                                 In  segment XDATA_I, align 1, keep-with-next
   2876          static signed char gyro_orientation[9] = { 1, 0, 0,
   \                     gyro_orientation:
   \   000000                DS 9
   \   000009                REQUIRE `?<Initializer for gyro_orientation>`
   \   000009                REQUIRE __INIT_XDATA_I
   2877                                                     0, 1, 0,
   2878                                                     0, 0, 1};
   2879          //MPU6050自测试
   2880          //返回值:0,正常
   2881          //    其他,失败

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2882          u8 run_self_test(void)
   \                     run_self_test:
   2883          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2884            int result;
   2885            //char test_packet[4] = {0};
   2886            long gyro[3], accel[3]; 
   2887            result = mpu_run_self_test(gyro, accel);
   2888            if (result == 0x3) 
   \   00000A                ; Setup parameters for call to function mpu_run_self_test
   \   00000A   7412         MOV     A,#0x12
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   7406         MOV     A,#0x6
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??mpu_run_self_test?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   7403         MOV     A,#0x3
   \   000023   65..         XRL     A,?V0 + 0
   \   000025   7001         JNZ     ??run_self_test_0
   \   000027   EB           MOV     A,R3
   \                     ??run_self_test_0:
   \   000028   6003         JZ      $+5
   \   00002A   02....       LJMP    ??run_self_test_1 & 0xFFFF
   2889            {
   2890                /* Test passed. We can trust the gyro data here, so let's push it down
   2891                * to the DMP.
   2892                */
   2893                float sens;
   2894                unsigned short accel_sens;
   2895                mpu_get_gyro_sens(&sens);
   \   00002D                ; Setup parameters for call to function mpu_get_gyro_sens
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   AA82         MOV     R2,DPL
   \   000034   AB83         MOV     R3,DPH
   \   000036   12....       LCALL   ??mpu_get_gyro_sens?relay
   2896                gyro[0] = (long)(gyro[0] * sens);
   \   000039   7406         MOV     A,#0x6
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?L_MOV_X
   \   000043   78..         MOV     R0,#?V0 + 0
   \   000045   12....       LCALL   ?L_TO_FLT
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   78..         MOV     R0,#?V0 + 4
   \   00004F   12....       LCALL   ?L_MOV_X
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   79..         MOV     R1,#?V0 + 4
   \   000056   12....       LCALL   ?FLT_MUL
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?FLT_TO_L
   \   00005E   7406         MOV     A,#0x6
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_MOV_TO_X
   2897                gyro[1] = (long)(gyro[1] * sens);
   \   000068   740A         MOV     A,#0xa
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 0
   \   000074   12....       LCALL   ?L_TO_FLT
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   78..         MOV     R0,#?V0 + 4
   \   00007E   12....       LCALL   ?L_MOV_X
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   79..         MOV     R1,#?V0 + 4
   \   000085   12....       LCALL   ?FLT_MUL
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?FLT_TO_L
   \   00008D   740A         MOV     A,#0xa
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?L_MOV_TO_X
   2898                gyro[2] = (long)(gyro[2] * sens);
   \   000097   740E         MOV     A,#0xe
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?L_MOV_X
   \   0000A1   78..         MOV     R0,#?V0 + 0
   \   0000A3   12....       LCALL   ?L_TO_FLT
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?L_MOV_X
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   79..         MOV     R1,#?V0 + 4
   \   0000B4   12....       LCALL   ?FLT_MUL
   \   0000B7   78..         MOV     R0,#?V0 + 0
   \   0000B9   12....       LCALL   ?FLT_TO_L
   \   0000BC   740E         MOV     A,#0xe
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   78..         MOV     R0,#?V0 + 0
   \   0000C3   12....       LCALL   ?L_MOV_TO_X
   2899                dmp_set_gyro_bias(gyro);
   \   0000C6                ; Setup parameters for call to function dmp_set_gyro_bias
   \   0000C6   7406         MOV     A,#0x6
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   AA82         MOV     R2,DPL
   \   0000CD   AB83         MOV     R3,DPH
   \   0000CF   12....       LCALL   ??dmp_set_gyro_bias?relay
   2900                mpu_get_accel_sens(&accel_sens);
   \   0000D2                ; Setup parameters for call to function mpu_get_accel_sens
   \   0000D2   85..82       MOV     DPL,?XSP + 0
   \   0000D5   85..83       MOV     DPH,?XSP + 1
   \   0000D8   AA82         MOV     R2,DPL
   \   0000DA   AB83         MOV     R3,DPH
   \   0000DC   12....       LCALL   ??mpu_get_accel_sens?relay
   2901                accel_sens=0;
   \   0000DF   85..82       MOV     DPL,?XSP + 0
   \   0000E2   85..83       MOV     DPH,?XSP + 1
   \   0000E5   E4           CLR     A
   \   0000E6   F0           MOVX    @DPTR,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   F0           MOVX    @DPTR,A
   2902                accel[0] *= accel_sens;
   \   0000E9   90....       MOV     DPTR,#__Constant_0
   \   0000EC   12....       LCALL   ?XLOAD_R2345
   \   0000EF   7412         MOV     A,#0x12
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   12....       LCALL   ?XSTORE_R2345
   2903                accel[1] *= accel_sens;
   \   0000F7   90....       MOV     DPTR,#__Constant_0
   \   0000FA   12....       LCALL   ?XLOAD_R2345
   \   0000FD   7416         MOV     A,#0x16
   \   0000FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000102   12....       LCALL   ?XSTORE_R2345
   2904                accel[2] *= accel_sens;
   \   000105   90....       MOV     DPTR,#__Constant_0
   \   000108   12....       LCALL   ?XLOAD_R2345
   \   00010B   741A         MOV     A,#0x1a
   \   00010D   12....       LCALL   ?XSTACK_DISP0_8
   \   000110   12....       LCALL   ?XSTORE_R2345
   2905                dmp_set_accel_bias(accel);
   \   000113                ; Setup parameters for call to function dmp_set_accel_bias
   \   000113   7412         MOV     A,#0x12
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   AA82         MOV     R2,DPL
   \   00011A   AB83         MOV     R3,DPH
   \   00011C   12....       LCALL   ??dmp_set_accel_bias?relay
   2906                return 0;
   \   00011F   7900         MOV     R1,#0x0
   \   000121   8002         SJMP    ??run_self_test_2
   2907            }else return 1;
   \                     ??run_self_test_1:
   \   000123   7901         MOV     R1,#0x1
   \                     ??run_self_test_2:
   \   000125   741E         MOV     A,#0x1e
   \   000127   02....       LJMP    ??Subroutine133_0 & 0xFFFF
   2908          }
   2909          //陀螺仪方向控制

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2910          unsigned short inv_orientation_matrix_to_scalar(
   \                     inv_orientation_matrix_to_scalar:
   2911              const signed char *mtx)
   2912          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2913              unsigned short scalar; 
   2914              /*
   2915                 XYZ  010_001_000 Identity Matrix
   2916                 XZY  001_010_000
   2917                 YXZ  010_000_001
   2918                 YZX  000_010_001
   2919                 ZXY  001_000_010
   2920                 ZYX  000_001_010
   2921               */
   2922          
   2923              scalar = inv_row_2_scale(mtx);
   \   000009                ; Setup parameters for call to function inv_row_2_scale
   \   000009   12....       LCALL   ??inv_row_2_scale?relay
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   2924              scalar |= inv_row_2_scale(mtx + 3) << 3;
   \   000010                ; Setup parameters for call to function inv_row_2_scale
   \   000010   EE           MOV     A,R6
   \   000011   2403         ADD     A,#0x3
   \   000013   12....       LCALL   ?Subroutine62 & 0xFFFF
   2925              scalar |= inv_row_2_scale(mtx + 6) << 6;
   2926          
   2927          
   2928              return scalar;
   \                     ??CrossCallReturnLabel_87:
   \   000016   7403         MOV     A,#0x3
   \   000018   78..         MOV     R0,#?V0 + 2
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   E5..         MOV     A,?V0 + 0
   \   00001F   45..         ORL     A,?V0 + 2
   \   000021   F5..         MOV     ?V0 + 0,A
   \   000023   E5..         MOV     A,?V0 + 1
   \   000025   45..         ORL     A,?V0 + 3
   \   000027   F5..         MOV     ?V0 + 1,A
   \   000029                ; Setup parameters for call to function inv_row_2_scale
   \   000029   EE           MOV     A,R6
   \   00002A   2406         ADD     A,#0x6
   \   00002C   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00002F   7406         MOV     A,#0x6
   \   000031   78..         MOV     R0,#?V0 + 2
   \   000033   12....       LCALL   ?S_SHL
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   45..         ORL     A,?V0 + 2
   \   00003A   FA           MOV     R2,A
   \   00003B   E5..         MOV     A,?V0 + 1
   \   00003D   45..         ORL     A,?V0 + 3
   \   00003F   FB           MOV     R3,A
   \   000040   7F06         MOV     R7,#0x6
   \   000042   02....       LJMP    ?BANKED_LEAVE_XDATA
   2929          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   FA           MOV     R2,A
   \   000001   EF           MOV     A,R7
   \   000002   3400         ADDC    A,#0x0
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??inv_row_2_scale?relay
   \   000008   8A..         MOV     ?V0 + 2,R2
   \   00000A   8B..         MOV     ?V0 + 3,R3
   \   00000C   22           RET
   2930          //方向转换

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2931          unsigned short inv_row_2_scale(const signed char *row)
   \                     inv_row_2_scale:
   2932          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2933              unsigned short b;
   2934          
   2935              if (row[0] > 0)
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   00000B   4004         JC      ??inv_row_2_scale_0
   2936                  b = 0;
   \   00000D   7A00         MOV     R2,#0x0
   \   00000F   8034         SJMP    ??inv_row_2_scale_1
   2937              else if (row[0] < 0)
   \                     ??inv_row_2_scale_0:
   \   000011   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000014   5004         JNC     ??inv_row_2_scale_2
   2938                  b = 4;
   \   000016   7A04         MOV     R2,#0x4
   \   000018   802B         SJMP    ??inv_row_2_scale_1
   2939              else if (row[1] > 0)
   \                     ??inv_row_2_scale_2:
   \   00001A   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   00001D   4004         JC      ??inv_row_2_scale_3
   2940                  b = 1;
   \   00001F   7A01         MOV     R2,#0x1
   \   000021   8022         SJMP    ??inv_row_2_scale_1
   2941              else if (row[1] < 0)
   \                     ??inv_row_2_scale_3:
   \   000023   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000026   5004         JNC     ??inv_row_2_scale_4
   2942                  b = 5;
   \   000028   7A05         MOV     R2,#0x5
   \   00002A   8019         SJMP    ??inv_row_2_scale_1
   2943              else if (row[2] > 0)
   \                     ??inv_row_2_scale_4:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   A3           INC     DPTR
   \   000031   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000034   4004         JC      ??inv_row_2_scale_5
   2944                  b = 2;
   \   000036   7A02         MOV     R2,#0x2
   \   000038   800B         SJMP    ??inv_row_2_scale_1
   2945              else if (row[2] < 0)
   \                     ??inv_row_2_scale_5:
   \   00003A   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00003D   5004         JNC     ??inv_row_2_scale_6
   2946                  b = 6;
   \   00003F   7A06         MOV     R2,#0x6
   \   000041   8002         SJMP    ??inv_row_2_scale_1
   2947              else
   2948                  b = 7;      // error
   \                     ??inv_row_2_scale_6:
   \   000043   7A07         MOV     R2,#0x7
   \                     ??inv_row_2_scale_1:
   \   000045   02....       LJMP    ??Subroutine120_0 & 0xFFFF
   2949              return b;
   2950          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   E8           MOV     A,R0
   \   000001   C3           CLR     C
   \   000002   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine142_0
   \   000001                ; // Fall through to label ??Subroutine142_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine142_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   C3           CLR     C
   \   000003   9401         SUBB    A,#0x1
   \   000005   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000007   65D0         XRL     A,PSW
   \   000009   33           RLC     A
   \   00000A   22           RET
   2951          //空函数,未用到.

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2952          void mget_ms(unsigned long *time)
   \                     mget_ms:
   2953          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2954          
   2955          }
   \   000000   02....       LJMP    ?BRET
   2956          //mpu6050,dmp初始化
   2957          //返回值:0,正常
   2958          //    其他,失败

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2959          u8 mpu_dmp_init(void)
   \                     mpu_dmp_init:
   2960          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2961            u8 res=0;
   2962            MPU_IIC_Init(); 	//初始化MPU_IIC总线
   \   000005                ; Setup parameters for call to function MPU_IIC_Init
   \   000005   12....       LCALL   ??MPU_IIC_Init?relay
   2963            if(mpu_init()==0)	//初始化MPU6050
   \   000008                ; Setup parameters for call to function mpu_init
   \   000008   12....       LCALL   ??mpu_init?relay
   \   00000B   8B..         MOV     ?V0 + 1,R3
   \   00000D   EA           MOV     A,R2
   \   00000E   45..         ORL     A,?V0 + 1
   \   000010   706D         JNZ     ??mpu_dmp_init_0
   2964            {	 
   2965                res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);    //设置所需要的传感器
   2966                if(res)return 1; 
   \   000012                ; Setup parameters for call to function mpu_set_sensors
   \   000012   7978         MOV     R1,#0x78
   \   000014   12....       LCALL   ??mpu_set_sensors?relay
   \   000017   EA           MOV     A,R2
   \   000018   6004         JZ      ??mpu_dmp_init_1
   \   00001A   7901         MOV     R1,#0x1
   \   00001C   8063         SJMP    ??mpu_dmp_init_2
   2967                res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL); //设置FIFO
   2968                if(res)return 2; 
   \                     ??mpu_dmp_init_1:
   \   00001E                ; Setup parameters for call to function mpu_configure_fifo
   \   00001E   7978         MOV     R1,#0x78
   \   000020   12....       LCALL   ??mpu_configure_fifo?relay
   \   000023   EA           MOV     A,R2
   \   000024   6004         JZ      ??mpu_dmp_init_3
   \   000026   7902         MOV     R1,#0x2
   \   000028   8057         SJMP    ??mpu_dmp_init_2
   2969                res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	          //设置采样率
   2970                if(res)return 3; 
   \                     ??mpu_dmp_init_3:
   \   00002A                ; Setup parameters for call to function mpu_set_sample_rate
   \   00002A   7A64         MOV     R2,#0x64
   \   00002C   7B00         MOV     R3,#0x0
   \   00002E   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000031   EA           MOV     A,R2
   \   000032   6004         JZ      ??mpu_dmp_init_4
   \   000034   7903         MOV     R1,#0x3
   \   000036   8049         SJMP    ??mpu_dmp_init_2
   2971                res=dmp_load_motion_driver_firmware();		  //加载dmp固件
   2972                if(res)return 4; 
   \                     ??mpu_dmp_init_4:
   \   000038                ; Setup parameters for call to function dmp_load_motion_driver_firmware
   \   000038   12....       LCALL   ??dmp_load_motion_driver_firmware?relay
   \   00003B   EA           MOV     A,R2
   \   00003C   6004         JZ      ??mpu_dmp_init_5
   \   00003E   7904         MOV     R1,#0x4
   \   000040   803F         SJMP    ??mpu_dmp_init_2
   2973                res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//设置陀螺仪方向
   2974                if(res)return 5; 
   \                     ??mpu_dmp_init_5:
   \   000042                ; Setup parameters for call to function dmp_set_orientation
   \   000042                ; Setup parameters for call to function inv_orientation_matrix_to_scalar
   \   000042   7A..         MOV     R2,#gyro_orientation & 0xff
   \   000044   7B..         MOV     R3,#(gyro_orientation >> 8) & 0xff
   \   000046   12....       LCALL   ??inv_orientation_matrix_to_scalar?relay
   \   000049   12....       LCALL   ??dmp_set_orientation?relay
   \   00004C   EA           MOV     A,R2
   \   00004D   6004         JZ      ??mpu_dmp_init_6
   \   00004F   7905         MOV     R1,#0x5
   \   000051   802E         SJMP    ??mpu_dmp_init_2
   2975                res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	          //设置dmp功能
   2976                    DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
   2977                    DMP_FEATURE_GYRO_CAL);
   2978                if(res)return 6; 
   \                     ??mpu_dmp_init_6:
   \   000053                ; Setup parameters for call to function dmp_enable_feature
   \   000053   7A73         MOV     R2,#0x73
   \   000055   7B01         MOV     R3,#0x1
   \   000057   12....       LCALL   ??dmp_enable_feature?relay
   \   00005A   EA           MOV     A,R2
   \   00005B   6004         JZ      ??mpu_dmp_init_7
   \   00005D   7906         MOV     R1,#0x6
   \   00005F   8020         SJMP    ??mpu_dmp_init_2
   2979                res=dmp_set_fifo_rate(DEFAULT_DMP_HZ);  //设置DMP输出速率(最大不超过200Hz)
   2980                if(res)return 7;   
   \                     ??mpu_dmp_init_7:
   \   000061                ; Setup parameters for call to function dmp_set_fifo_rate
   \   000061   7A64         MOV     R2,#0x64
   \   000063   7B00         MOV     R3,#0x0
   \   000065   12....       LCALL   ??dmp_set_fifo_rate?relay
   \   000068   EA           MOV     A,R2
   \   000069   6004         JZ      ??mpu_dmp_init_8
   \   00006B   7907         MOV     R1,#0x7
   \   00006D   8012         SJMP    ??mpu_dmp_init_2
   2981          //      res=run_self_test();		      //自检
   2982          //      if(res)return 8;    
   2983                res=mpu_set_dmp_state(1);	              //使能DMP
   2984                if(res)return 9;     
   \                     ??mpu_dmp_init_8:
   \   00006F                ; Setup parameters for call to function mpu_set_dmp_state
   \   00006F   7901         MOV     R1,#0x1
   \   000071   12....       LCALL   ??mpu_set_dmp_state?relay
   \   000074   EA           MOV     A,R2
   \   000075   6004         JZ      ??mpu_dmp_init_9
   \   000077   7909         MOV     R1,#0x9
   \   000079   8006         SJMP    ??mpu_dmp_init_2
   2985            }else return 10;
   2986            return 0;
   \                     ??mpu_dmp_init_9:
   \   00007B   7900         MOV     R1,#0x0
   \   00007D   8002         SJMP    ??mpu_dmp_init_2
   \                     ??mpu_dmp_init_0:
   \   00007F   790A         MOV     R1,#0xa
   \                     ??mpu_dmp_init_2:
   \   000081   02....       LJMP    ??Subroutine104_0 & 0xFFFF
   2987          }
   2988          
   2989          //得到dmp处理后的数据(注意,本函数需要比较多堆栈,局部变量有点多)
   2990          //pitch:俯仰角 精度:0.1°   范围:-90.0° <---> +90.0°
   2991          //roll:横滚角  精度:0.1°   范围:-180.0°<---> +180.0°
   2992          //yaw:航向角   精度:0.1°   范围:-180.0°<---> +180.0°
   2993          //返回值:0,正常
   2994          //    其他,失败

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2995          u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
   \                     mpu_dmp_get_data:
   2996          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 51
   \   000005   74CD         MOV     A,#-0x33
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7415         MOV     A,#0x15
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   000012   7413         MOV     A,#0x13
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   EC           MOV     A,R4
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   ED           MOV     A,R5
   \   00001B   12....       LCALL   ?Subroutine92 & 0xFFFF
   2997          	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
   2998          	unsigned long sensor_timestamp;
   2999          	short gyro[3], accel[3], sensors;
   3000          	unsigned char more;
   3001          	long quat[4]; 
   3002          	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))
   \                     ??CrossCallReturnLabel_270:
   \   00001E   8582..       MOV     ?V0 + 0,DPL
   \   000021   8583..       MOV     ?V0 + 1,DPH
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   7413         MOV     A,#0x13
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   8582..       MOV     ?V0 + 0,DPL
   \   000031   8583..       MOV     ?V0 + 1,DPH
   \   000034   78..         MOV     R0,#?V0 + 0
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   740D         MOV     A,#0xd
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   8582..       MOV     ?V0 + 0,DPL
   \   000041   8583..       MOV     ?V0 + 1,DPH
   \   000044   78..         MOV     R0,#?V0 + 0
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   741D         MOV     A,#0x1d
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   8582..       MOV     ?V0 + 0,DPL
   \   000051   8583..       MOV     ?V0 + 1,DPH
   \   000054   78..         MOV     R0,#?V0 + 0
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000059   742F         MOV     A,#0x2f
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   AC82         MOV     R4,DPL
   \   000060   AD83         MOV     R5,DPH
   \   000062   7435         MOV     A,#0x35
   \   000064   12....       LCALL   ?XSTACK_DISP0_8
   \   000067   AA82         MOV     R2,DPL
   \   000069   AB83         MOV     R3,DPH
   \   00006B   12....       LCALL   ??dmp_read_fifo?relay
   \   00006E   7408         MOV     A,#0x8
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   8B..         MOV     ?V0 + 1,R3
   \   000075   EA           MOV     A,R2
   \   000076   45..         ORL     A,?V0 + 1
   \   000078   6005         JZ      ??mpu_dmp_get_data_0
   3003                  {
   3004                    //printf("dmp_read_fifo error\r\n");
   3005                    return 1;	 //gyro
   \   00007A   7901         MOV     R1,#0x1
   \   00007C   02....       LJMP    ??mpu_dmp_get_data_1 & 0xFFFF
   3006                  }
   3007          	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
   3008          	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
   3009          	**/
   3010          	/*if (sensors & INV_XYZ_GYRO )
   3011          	send_packet(PACKET_TYPE_GYRO, gyro);
   3012          	if (sensors & INV_XYZ_ACCEL)
   3013          	send_packet(PACKET_TYPE_ACCEL, accel); */
   3014          	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
   3015          	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
   3016          	**/
   3017          	if(sensors&INV_WXYZ_QUAT) 
   \                     ??mpu_dmp_get_data_0:
   \   00007F   7411         MOV     A,#0x11
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   5401         ANL     A,#0x1
   \   000088   7003         JNZ     $+5
   \   00008A   02....       LJMP    ??mpu_dmp_get_data_2 & 0xFFFF
   3018          	{
   3019          		q0 = quat[0] / q30;	//q30格式转换为浮点数
   \   00008D   7417         MOV     A,#0x17
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?L_MOV_X
   \   000097   78..         MOV     R0,#?V0 + 0
   \   000099   12....       LCALL   ?L_TO_FLT
   \   00009C   90....       MOV     DPTR,#__Constant_30800000
   \   00009F   78..         MOV     R0,#?V0 + 4
   \   0000A1   12....       LCALL   ?L_MOV_X
   \   0000A4   78..         MOV     R0,#?V0 + 0
   \   0000A6   79..         MOV     R1,#?V0 + 4
   \   0000A8   12....       LCALL   ?FLT_MUL
   \   0000AB   7409         MOV     A,#0x9
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   12....       LCALL   ?L_MOV_TO_X
   3020          		q1 = quat[1] / q30;
   \   0000B5   741B         MOV     A,#0x1b
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   78..         MOV     R0,#?V0 + 0
   \   0000BC   12....       LCALL   ?L_MOV_X
   \   0000BF   78..         MOV     R0,#?V0 + 0
   \   0000C1   12....       LCALL   ?L_TO_FLT
   \   0000C4   90....       MOV     DPTR,#__Constant_30800000
   \   0000C7   78..         MOV     R0,#?V0 + 4
   \   0000C9   12....       LCALL   ?L_MOV_X
   \   0000CC   78..         MOV     R0,#?V0 + 0
   \   0000CE   79..         MOV     R1,#?V0 + 4
   \   0000D0   12....       LCALL   ?FLT_MUL
   \   0000D3   7405         MOV     A,#0x5
   \   0000D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D8   78..         MOV     R0,#?V0 + 0
   \   0000DA   12....       LCALL   ?L_MOV_TO_X
   3021          		q2 = quat[2] / q30;
   \   0000DD   741F         MOV     A,#0x1f
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   78..         MOV     R0,#?V0 + 0
   \   0000E4   12....       LCALL   ?L_MOV_X
   \   0000E7   78..         MOV     R0,#?V0 + 0
   \   0000E9   12....       LCALL   ?L_TO_FLT
   \   0000EC   90....       MOV     DPTR,#__Constant_30800000
   \   0000EF   78..         MOV     R0,#?V0 + 4
   \   0000F1   12....       LCALL   ?L_MOV_X
   \   0000F4   78..         MOV     R0,#?V0 + 0
   \   0000F6   79..         MOV     R1,#?V0 + 4
   \   0000F8   12....       LCALL   ?FLT_MUL
   \   0000FB   7401         MOV     A,#0x1
   \   0000FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000100   78..         MOV     R0,#?V0 + 0
   \   000102   12....       LCALL   ?L_MOV_TO_X
   3022          		q3 = quat[3] / q30; 
   \   000105   7423         MOV     A,#0x23
   \   000107   12....       LCALL   ?XSTACK_DISP0_8
   \   00010A   78..         MOV     R0,#?V0 + 0
   \   00010C   12....       LCALL   ?L_MOV_X
   \   00010F   78..         MOV     R0,#?V0 + 0
   \   000111   12....       LCALL   ?L_TO_FLT
   \   000114   90....       MOV     DPTR,#__Constant_30800000
   \   000117   78..         MOV     R0,#?V0 + 4
   \   000119   12....       LCALL   ?L_MOV_X
   \   00011C   78..         MOV     R0,#?V0 + 0
   \   00011E   79..         MOV     R1,#?V0 + 4
   \   000120   12....       LCALL   ?FLT_MUL
   \   000123   740D         MOV     A,#0xd
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   78..         MOV     R0,#?V0 + 0
   \   00012A   12....       LCALL   ?L_MOV_TO_X
   3023          		//计算得到俯仰角/横滚角/航向角
   3024          		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
   \   00012D   7409         MOV     A,#0x9
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   78..         MOV     R0,#?V0 + 4
   \   000134   12....       LCALL   ?L_MOV_X
   \   000137   90....       MOV     DPTR,#__Constant_40000000
   \   00013A   78..         MOV     R0,#?V0 + 0
   \   00013C   12....       LCALL   ?L_MOV_X
   \   00013F   78..         MOV     R0,#?V0 + 4
   \   000141   79..         MOV     R1,#?V0 + 0
   \   000143   12....       LCALL   ?FLT_MUL
   \   000146   7405         MOV     A,#0x5
   \   000148   12....       LCALL   ?XSTACK_DISP0_8
   \   00014B   78..         MOV     R0,#?V0 + 12
   \   00014D   12....       LCALL   ?L_MOV_X
   \   000150   90....       MOV     DPTR,#__Constant_c0000000
   \   000153   78..         MOV     R0,#?V0 + 0
   \   000155   12....       LCALL   ?L_MOV_X
   \   000158   78..         MOV     R0,#?V0 + 12
   \   00015A   79..         MOV     R1,#?V0 + 0
   \   00015C   12....       LCALL   ?FLT_MUL
   \   00015F                ; Setup parameters for call to function asin
   \   00015F   85....       MOV     ?V0 + 0,?V0 + 12
   \   000162   85....       MOV     ?V0 + 1,?V0 + 13
   \   000165   85....       MOV     ?V0 + 2,?V0 + 14
   \   000168   85....       MOV     ?V0 + 3,?V0 + 15
   \   00016B   740D         MOV     A,#0xd
   \   00016D   12....       LCALL   ?XSTACK_DISP0_8
   \   000170   78..         MOV     R0,#?V0 + 8
   \   000172   12....       LCALL   ?L_MOV_X
   \   000175   78..         MOV     R0,#?V0 + 0
   \   000177   79..         MOV     R1,#?V0 + 8
   \   000179   12....       LCALL   ?FLT_MUL
   \   00017C   C0..         PUSH    ?V0 + 0
   \   00017E   C0..         PUSH    ?V0 + 1
   \   000180   C0..         PUSH    ?V0 + 2
   \   000182   C0..         PUSH    ?V0 + 3
   \   000184   85....       MOV     ?V0 + 0,?V0 + 4
   \   000187   85....       MOV     ?V0 + 1,?V0 + 5
   \   00018A   85....       MOV     ?V0 + 2,?V0 + 6
   \   00018D   85....       MOV     ?V0 + 3,?V0 + 7
   \   000190   7401         MOV     A,#0x1
   \   000192   12....       LCALL   ?XSTACK_DISP0_8
   \   000195   78..         MOV     R0,#?V0 + 8
   \   000197   12....       LCALL   ?L_MOV_X
   \   00019A   78..         MOV     R0,#?V0 + 0
   \   00019C   79..         MOV     R1,#?V0 + 8
   \   00019E   12....       LCALL   ?FLT_MUL
   \   0001A1   D0..         POP     ?V0 + 11
   \   0001A3   D0..         POP     ?V0 + 10
   \   0001A5   D0..         POP     ?V0 + 9
   \   0001A7   D0..         POP     ?V0 + 8
   \   0001A9   78..         MOV     R0,#?V0 + 8
   \   0001AB   79..         MOV     R1,#?V0 + 0
   \   0001AD   12....       LCALL   ?FLT_ADD
   \   0001B0   AA..         MOV     R2,?V0 + 8
   \   0001B2   AB..         MOV     R3,?V0 + 9
   \   0001B4   AC..         MOV     R4,?V0 + 10
   \   0001B6   AD..         MOV     R5,?V0 + 11
   \   0001B8   12....       LCALL   ??asin?relay
   \   0001BB   8A..         MOV     ?V0 + 0,R2
   \   0001BD   8B..         MOV     ?V0 + 1,R3
   \   0001BF   8C..         MOV     ?V0 + 2,R4
   \   0001C1   8D..         MOV     ?V0 + 3,R5
   \   0001C3   90....       MOV     DPTR,#__Constant_42653333
   \   0001C6   78..         MOV     R0,#?V0 + 8
   \   0001C8   12....       LCALL   ?L_MOV_X
   \   0001CB   78..         MOV     R0,#?V0 + 0
   \   0001CD   79..         MOV     R1,#?V0 + 8
   \   0001CF   12....       LCALL   ?FLT_MUL
   \   0001D2   7415         MOV     A,#0x15
   \   0001D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D7   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0001DA   12....       LCALL   ?L_MOV_TO_X
   3025          		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
   \   0001DD   7401         MOV     A,#0x1
   \   0001DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E2   78..         MOV     R0,#?V0 + 8
   \   0001E4   12....       LCALL   ?L_MOV_X
   \   0001E7   90....       MOV     DPTR,#__Constant_40000000
   \   0001EA   78..         MOV     R0,#?V0 + 0
   \   0001EC   12....       LCALL   ?L_MOV_X
   \   0001EF   78..         MOV     R0,#?V0 + 8
   \   0001F1   79..         MOV     R1,#?V0 + 0
   \   0001F3   12....       LCALL   ?FLT_MUL
   \   0001F6                ; Setup parameters for call to function atan2
   \   0001F6   7405         MOV     A,#0x5
   \   0001F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FB   78..         MOV     R0,#?V0 + 0
   \   0001FD   12....       LCALL   ?L_MOV_X
   \   000200   78..         MOV     R0,#?V0 + 12
   \   000202   79..         MOV     R1,#?V0 + 0
   \   000204   12....       LCALL   ?FLT_MUL
   \   000207   C0..         PUSH    ?V0 + 12
   \   000209   C0..         PUSH    ?V0 + 13
   \   00020B   C0..         PUSH    ?V0 + 14
   \   00020D   C0..         PUSH    ?V0 + 15
   \   00020F   85....       MOV     ?V0 + 0,?V0 + 8
   \   000212   85....       MOV     ?V0 + 1,?V0 + 9
   \   000215   85....       MOV     ?V0 + 2,?V0 + 10
   \   000218   85....       MOV     ?V0 + 3,?V0 + 11
   \   00021B   7401         MOV     A,#0x1
   \   00021D   12....       LCALL   ?XSTACK_DISP0_8
   \   000220   78..         MOV     R0,#?V0 + 12
   \   000222   12....       LCALL   ?L_MOV_X
   \   000225   78..         MOV     R0,#?V0 + 0
   \   000227   79..         MOV     R1,#?V0 + 12
   \   000229   12....       LCALL   ?FLT_MUL
   \   00022C   D0..         POP     ?V0 + 15
   \   00022E   D0..         POP     ?V0 + 14
   \   000230   D0..         POP     ?V0 + 13
   \   000232   D0..         POP     ?V0 + 12
   \   000234   78..         MOV     R0,#?V0 + 12
   \   000236   79..         MOV     R1,#?V0 + 0
   \   000238   12....       LCALL   ?FLT_SUB
   \   00023B   90....       MOV     DPTR,#__Constant_3f800000
   \   00023E   78..         MOV     R0,#?V0 + 0
   \   000240   12....       LCALL   ?L_MOV_X
   \   000243   78..         MOV     R0,#?V0 + 12
   \   000245   79..         MOV     R1,#?V0 + 0
   \   000247   12....       LCALL   ?FLT_ADD
   \   00024A   78..         MOV     R0,#?V0 + 12
   \   00024C   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00024F   7411         MOV     A,#0x11
   \   000251   12....       LCALL   ?XSTACK_DISP0_8
   \   000254   78..         MOV     R0,#?V0 + 0
   \   000256   12....       LCALL   ?L_MOV_X
   \   000259   78..         MOV     R0,#?V0 + 8
   \   00025B   79..         MOV     R1,#?V0 + 0
   \   00025D   12....       LCALL   ?FLT_MUL
   \   000260   7409         MOV     A,#0x9
   \   000262   12....       LCALL   ?XSTACK_DISP0_8
   \   000265   78..         MOV     R0,#?V0 + 0
   \   000267   12....       LCALL   ?L_MOV_X
   \   00026A   78..         MOV     R0,#?V0 + 4
   \   00026C   79..         MOV     R1,#?V0 + 0
   \   00026E   12....       LCALL   ?FLT_MUL
   \   000271   78..         MOV     R0,#?V0 + 8
   \   000273   79..         MOV     R1,#?V0 + 4
   \   000275   12....       LCALL   ?FLT_ADD
   \   000278   AA..         MOV     R2,?V0 + 8
   \   00027A   AB..         MOV     R3,?V0 + 9
   \   00027C   AC..         MOV     R4,?V0 + 10
   \   00027E   AD..         MOV     R5,?V0 + 11
   \   000280   12....       LCALL   ??atan2?relay
   \   000283   7404         MOV     A,#0x4
   \   000285   12....       LCALL   ?DEALLOC_XSTACK8
   \   000288   8A..         MOV     ?V0 + 0,R2
   \   00028A   8B..         MOV     ?V0 + 1,R3
   \   00028C   8C..         MOV     ?V0 + 2,R4
   \   00028E   8D..         MOV     ?V0 + 3,R5
   \   000290   90....       MOV     DPTR,#__Constant_42653333
   \   000293   78..         MOV     R0,#?V0 + 4
   \   000295   12....       LCALL   ?L_MOV_X
   \   000298   78..         MOV     R0,#?V0 + 0
   \   00029A   79..         MOV     R1,#?V0 + 4
   \   00029C   12....       LCALL   ?FLT_MUL
   \   00029F   7413         MOV     A,#0x13
   \   0002A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A4   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0002A7   12....       LCALL   ?L_MOV_TO_X
   3026          		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
   \   0002AA                ; Setup parameters for call to function atan2
   \   0002AA   7409         MOV     A,#0x9
   \   0002AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AF   78..         MOV     R0,#?V0 + 0
   \   0002B1   12....       LCALL   ?L_MOV_X
   \   0002B4   7409         MOV     A,#0x9
   \   0002B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B9   78..         MOV     R0,#?V0 + 4
   \   0002BB   12....       LCALL   ?L_MOV_X
   \   0002BE   78..         MOV     R0,#?V0 + 0
   \   0002C0   79..         MOV     R1,#?V0 + 4
   \   0002C2   12....       LCALL   ?FLT_MUL
   \   0002C5   7405         MOV     A,#0x5
   \   0002C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CA   78..         MOV     R0,#?V0 + 4
   \   0002CC   12....       LCALL   ?L_MOV_X
   \   0002CF   7405         MOV     A,#0x5
   \   0002D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D4   78..         MOV     R0,#?V0 + 8
   \   0002D6   12....       LCALL   ?L_MOV_X
   \   0002D9   78..         MOV     R0,#?V0 + 4
   \   0002DB   79..         MOV     R1,#?V0 + 8
   \   0002DD   12....       LCALL   ?FLT_MUL
   \   0002E0   78..         MOV     R0,#?V0 + 0
   \   0002E2   79..         MOV     R1,#?V0 + 4
   \   0002E4   12....       LCALL   ?FLT_ADD
   \   0002E7   7401         MOV     A,#0x1
   \   0002E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002EC   78..         MOV     R0,#?V0 + 4
   \   0002EE   12....       LCALL   ?L_MOV_X
   \   0002F1   7401         MOV     A,#0x1
   \   0002F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F6   78..         MOV     R0,#?V0 + 8
   \   0002F8   12....       LCALL   ?L_MOV_X
   \   0002FB   78..         MOV     R0,#?V0 + 4
   \   0002FD   79..         MOV     R1,#?V0 + 8
   \   0002FF   12....       LCALL   ?FLT_MUL
   \   000302   78..         MOV     R0,#?V0 + 0
   \   000304   79..         MOV     R1,#?V0 + 4
   \   000306   12....       LCALL   ?FLT_SUB
   \   000309   740D         MOV     A,#0xd
   \   00030B   12....       LCALL   ?XSTACK_DISP0_8
   \   00030E   78..         MOV     R0,#?V0 + 4
   \   000310   12....       LCALL   ?L_MOV_X
   \   000313   740D         MOV     A,#0xd
   \   000315   12....       LCALL   ?XSTACK_DISP0_8
   \   000318   78..         MOV     R0,#?V0 + 8
   \   00031A   12....       LCALL   ?L_MOV_X
   \   00031D   78..         MOV     R0,#?V0 + 4
   \   00031F   79..         MOV     R1,#?V0 + 8
   \   000321   12....       LCALL   ?FLT_MUL
   \   000324   78..         MOV     R0,#?V0 + 0
   \   000326   79..         MOV     R1,#?V0 + 4
   \   000328   12....       LCALL   ?FLT_SUB
   \   00032B   78..         MOV     R0,#?V0 + 0
   \   00032D   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000330   7409         MOV     A,#0x9
   \   000332   12....       LCALL   ?XSTACK_DISP0_8
   \   000335   78..         MOV     R0,#?V0 + 0
   \   000337   12....       LCALL   ?L_MOV_X
   \   00033A   7405         MOV     A,#0x5
   \   00033C   12....       LCALL   ?XSTACK_DISP0_8
   \   00033F   78..         MOV     R0,#?V0 + 4
   \   000341   12....       LCALL   ?L_MOV_X
   \   000344   78..         MOV     R0,#?V0 + 0
   \   000346   79..         MOV     R1,#?V0 + 4
   \   000348   12....       LCALL   ?FLT_MUL
   \   00034B   740D         MOV     A,#0xd
   \   00034D   12....       LCALL   ?XSTACK_DISP0_8
   \   000350   78..         MOV     R0,#?V0 + 4
   \   000352   12....       LCALL   ?L_MOV_X
   \   000355   7411         MOV     A,#0x11
   \   000357   12....       LCALL   ?XSTACK_DISP0_8
   \   00035A   78..         MOV     R0,#?V0 + 8
   \   00035C   12....       LCALL   ?L_MOV_X
   \   00035F   78..         MOV     R0,#?V0 + 4
   \   000361   79..         MOV     R1,#?V0 + 8
   \   000363   12....       LCALL   ?FLT_MUL
   \   000366   78..         MOV     R0,#?V0 + 0
   \   000368   79..         MOV     R1,#?V0 + 4
   \   00036A   12....       LCALL   ?FLT_ADD
   \   00036D   90....       MOV     DPTR,#__Constant_40000000
   \   000370   78..         MOV     R0,#?V0 + 4
   \   000372   12....       LCALL   ?L_MOV_X
   \   000375   78..         MOV     R0,#?V0 + 0
   \   000377   79..         MOV     R1,#?V0 + 4
   \   000379   12....       LCALL   ?FLT_MUL
   \   00037C   AA..         MOV     R2,?V0 + 0
   \   00037E   AB..         MOV     R3,?V0 + 1
   \   000380   AC..         MOV     R4,?V0 + 2
   \   000382   AD..         MOV     R5,?V0 + 3
   \   000384   12....       LCALL   ??atan2?relay
   \   000387   7404         MOV     A,#0x4
   \   000389   12....       LCALL   ?DEALLOC_XSTACK8
   \   00038C   8A..         MOV     ?V0 + 0,R2
   \   00038E   8B..         MOV     ?V0 + 1,R3
   \   000390   8C..         MOV     ?V0 + 2,R4
   \   000392   8D..         MOV     ?V0 + 3,R5
   \   000394   90....       MOV     DPTR,#__Constant_42653333
   \   000397   78..         MOV     R0,#?V0 + 4
   \   000399   12....       LCALL   ?L_MOV_X
   \   00039C   78..         MOV     R0,#?V0 + 0
   \   00039E   79..         MOV     R1,#?V0 + 4
   \   0003A0   12....       LCALL   ?FLT_MUL
   \   0003A3   744B         MOV     A,#0x4b
   \   0003A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A8   12....       LCALL   ?Subroutine15 & 0xFFFF
   3027          	}
   \                     ??CrossCallReturnLabel_4:
   \   0003AB   12....       LCALL   ?L_MOV_TO_X
   3028                  else 
   3029                  {
   3030                    return 2;
   3031                  }
   3032          	return 0;
   \   0003AE   7900         MOV     R1,#0x0
   \   0003B0   8002         SJMP    ??mpu_dmp_get_data_1
   \                     ??mpu_dmp_get_data_2:
   \   0003B2   7902         MOV     R1,#0x2
   \                     ??mpu_dmp_get_data_1:
   \   0003B4   7433         MOV     A,#0x33
   \   0003B6   02....       LJMP    ?Subroutine6 & 0xFFFF
   3033          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for st>`:
   \   000000   ....         DW reg
   \   000002   ....         DW hw
   \   000004   00           DB 0
   \   000005   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00000D   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000015   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001D   00000000     DB 0, 0, 0, 0
   \   000021   ....         DW test

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gyro_orientation>`:
   \   000000   01           DB 1
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   01           DB 1
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   01           DB 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??set_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    set_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reg_dump?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reg_dump

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_accel_mode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_accel_mode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_temperature?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_temperature

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_bias?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_bias

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reset_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reset_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_fifo_config?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_fifo_config

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_configure_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_configure_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_power_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_power_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sensors?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sensors

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_int_status?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_int_status

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo_stream?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo_stream

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_bypass?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_bypass

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_level?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_level

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_latched?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_latched

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_accel_prod_shift?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_accel_prod_shift

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??accel_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    accel_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gyro_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gyro_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_st_biases?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_st_biases

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_write_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_write_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_load_firmware?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_load_firmware

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??setup_compass?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    setup_compass

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_motion_interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_motion_interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_orientation_matrix_to_scalar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_orientation_matrix_to_scalar

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_row_2_scale?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_row_2_scale

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mget_ms?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mget_ms

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_dmp_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_dmp_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_dmp_get_data?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_dmp_get_data

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%#5x: %#5x\\r\\n">`:
   \   000000   25233578     DB "%#5x: %#5x\015\012"
   \            3A202523
   \            35780D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Unsupported software ...">`:
   \   000000   556E7375     DB "Unsupported software product rev %d.\012"
   \            70706F72
   \            74656420
   \            736F6674
   \            77617265
   \            2070726F
   \            64756374
   \            20726576
   \            2025642E
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Product ID read as 0 ...">`:
   \   000000   50726F64     DB 50H, 72H, 6FH, 64H, 75H, 63H, 74H, 20H
   \            75637420
   \   000008   49442072     DB 49H, 44H, 20H, 72H, 65H, 61H, 64H, 20H
   \            65616420
   \   000010   61732030     DB 61H, 73H, 20H, 30H, 20H, 69H, 6EH, 64H
   \            20696E64
   \   000018   69636174     DB 69H, 63H, 61H, 74H, 65H, 73H, 20H, 64H
   \            65732064
   \   000020   65766963     DB 65H, 76H, 69H, 63H, 65H, 20H, 69H, 73H
   \            65206973
   \   000028   20656974     DB 20H, 65H, 69H, 74H, 68H, 65H, 72H, 20H
   \            68657220
   \   000030   696E636F     DB 69H, 6EH, 63H, 6FH, 6DH, 70H, 61H, 74H
   \            6D706174
   \   000038   69626C65     DB 69H, 62H, 6CH, 65H, 20H, 6FH, 72H, 20H
   \            206F7220
   \   000040   616E204D     DB 61H, 6EH, 20H, 4DH, 50H, 55H, 33H, 30H
   \            50553330
   \   000048   35302E0A     DB 35H, 30H, 2EH, 0AH, 0
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Half sensitivity part...">`:
   \   000000   48616C66     DB "Half sensitivity part found.\012"
   \            2073656E
   \            73697469
   \            76697479
   \            20706172
   \            7420666F
   \            756E642E
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_64:
   \   000000   64000000     DD 100

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_420c0000:
   \   000000   00000C42     DD 420C0000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_47800000:
   \   000000   00008047     DD 47800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_32:
   \   000000   32000000     DD 50

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_43030000:
   \   000000   00000343     DD 43030000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42830000:
   \   000000   00008342     DD 42830000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42033333:
   \   000000   33330342     DD 42033333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41833333:
   \   000000   33338341     DD 41833333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3:
   \   000000   03000000     DD 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3eae147b:
   \   000000   7B14AE3E     DD 3EAE147BH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f845a1d:
   \   000000   1D5A843F     DD 3F845A1DH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_37800000:
   \   000000   00008037     DD 37800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_bf800000:
   \   000000   000080BF     DD 0BF800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e0f5c2a:
   \   000000   2A5C0F3E     DD 3E0F5C2AH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e99999a:
   \   000000   9A99993E     DD 3E99999AH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f733334:
   \   000000   3433733F     DD 3F733334H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41c80000:
   \   000000   0000C841     DD 41C80000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f85e354:
   \   000000   54E3853F     DD 3F85E354H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41200000:
   \   000000   00002041     DD 41200000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42d20001:
   \   000000   0100D242     DD 42D20001H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_c8:
   \   000000   C8000000     DD 200

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_f:
   \   000000   0F000000     DD 15

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_83:
   \   000000   83000000     DD 131

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffff0000:
   \   000000   0000FFFF     DD -65536

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_10000:
   \   000000   00000100     DD 65536

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_5:
   \   000000   05000000     DD 5

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_30800000:
   \   000000   00008030     DD 30800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_40000000:
   \   000000   00000040     DD 40000000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_c0000000:
   \   000000   000000C0     DD 0C0000000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42653333:
   \   000000   33336542     DD 42653333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f800000:
   \   000000   0000803F     DD 3F800000H
   3034          
   3035          
   3036          
   3037          
   3038          
   3039          
   3040          
   3041          
   3042          
   3043          
   3044          
   3045          
   3046          
   3047          
   3048          
   3049          
   3050          
   3051          
   3052          
   3053          
   3054          
   3055          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     accel_self_test                    0      0     86
       -> get_accel_prod_shift          0      0     76
       -> labs                          0      0     76
     get_accel_prod_shift               1      0     67
       -> MPU_Read_Len                  0      0     58
     get_st_biases                      2      0    103
       -> MPU_Write_Len                 0      0    110
       -> delay_ms                      0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> delay_ms                      0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> delay_ms                      0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> delay_ms                      0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Read_Len                  0      0    110
       -> MPU_Read_Len                  0      0    110
     gyro_self_test                     0      0     77
       -> MPU_Read_Len                  0      0     58
       -> labs                          0      0     58
     inv_orientation_matrix_to_scalar
                                        0      0     24
       -> inv_row_2_scale               0      0     28
       -> inv_row_2_scale               0      0     28
       -> inv_row_2_scale               0      0     28
     inv_row_2_scale                    2      0     14
     mget_ms                            0      0      0
     mpu_configure_fifo                 0      0     60
       -> set_int_enable                0      0     24
       -> set_int_enable                0      0     24
       -> mpu_reset_fifo                0      0     24
     mpu_dmp_get_data                   4      0     85
       -> dmp_read_fifo                 0      0    166
       -> asin                          0      0    150
       -> atan2                         0      0    158
       -> atan2                         0      0    158
     mpu_dmp_init                       0      0     10
       -> MPU_IIC_Init                  0      0     20
       -> mpu_init                      0      0     20
       -> mpu_set_sensors               0      0     20
       -> mpu_configure_fifo            0      0     20
       -> mpu_set_sample_rate           0      0     20
       -> dmp_load_motion_driver_firmware
                                        0      0     20
       -> inv_orientation_matrix_to_scalar
                                        0      0     20
       -> dmp_set_orientation           0      0     20
       -> dmp_enable_feature            0      0     20
       -> dmp_set_fifo_rate             0      0     20
       -> mpu_set_dmp_state             0      0     20
     mpu_get_accel_fsr                  3      0     48
     mpu_get_accel_reg                  0      0     15
       -> MPU_Read_Len                  0      0     30
     mpu_get_accel_sens                 2      0     46
     mpu_get_compass_fsr                0      0      0
     mpu_get_compass_reg                0      0      0
     mpu_get_compass_sample_rate        2      0      0
     mpu_get_dmp_state                  3      0      0
     mpu_get_fifo_config                3      0     48
     mpu_get_gyro_fsr                   2      0     48
     mpu_get_gyro_reg                   0      0     15
       -> MPU_Read_Len                  0      0     30
     mpu_get_gyro_sens                  0      0     55
     mpu_get_int_status                 0      0     11
       -> MPU_Read_Len                  0      0     22
     mpu_get_lpf                        2      0     48
     mpu_get_power_state                2      0      0
     mpu_get_sample_rate                2      0     48
     mpu_get_temperature                0      0     18
       -> MPU_Read_Len                  0      0     36
     mpu_init                           0      0     28
       -> MPU_Write_Len                 0      0     32
       -> delay_ms                      0      0     32
       -> MPU_Write_Len                 0      0     32
       -> MPU_Read_Len                  0      0     32
       -> printf                        0      0     36
       -> MPU_Read_Len                  0      0     32
       -> printf                        0      0     32
       -> printf                        0      0     32
       -> memset                        0      0     36
       -> mpu_set_gyro_fsr              0      0     32
       -> mpu_set_accel_fsr             0      0     32
       -> mpu_set_lpf                   0      0     32
       -> mpu_set_sample_rate           0      0     32
       -> mpu_configure_fifo            0      0     32
       -> mpu_set_bypass                0      0     32
       -> mpu_set_sensors               0      0     32
     mpu_load_firmware                  1      0     46
       -> mpu_write_mem                 0      0     84
       -> mpu_read_mem                  0      0     84
       -> memcmp                        0      0     84
       -> MPU_Write_Len                 0      0     80
     mpu_lp_accel_mode                  1      0     24
       -> mpu_set_int_latched           0      0     22
       -> MPU_Write_Len                 0      0     22
       -> mpu_set_int_latched           0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> MPU_Write_Len                 0      0     22
       -> mpu_configure_fifo            0      0     22
     mpu_lp_motion_interrupt            1      0     13
       -> mpu_set_dmp_state             0      0     26
       -> mpu_get_gyro_fsr              0      0     26
       -> mpu_get_accel_fsr             0      0     26
       -> mpu_get_lpf                   0      0     26
       -> mpu_get_sample_rate           0      0     26
       -> mpu_get_fifo_config           0      0     26
       -> set_int_enable                0      0     26
       -> mpu_lp_accel_mode             0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> delay_ms                      0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> mpu_set_sensors               0      0     26
       -> mpu_set_gyro_fsr              0      0     26
       -> mpu_set_accel_fsr             0      0     26
       -> mpu_set_lpf                   0      0     26
       -> mpu_set_sample_rate           0      0     26
       -> mpu_configure_fifo            0      0     26
       -> mpu_set_dmp_state             0      0     26
     mpu_read_fifo                      1      0     42
       -> MPU_Read_Len                  0      0     72
       -> MPU_Read_Len                  0      0     72
       -> mpu_reset_fifo                0      0     72
       -> MPU_Read_Len                  0      0     72
     mpu_read_fifo_stream               1      0     20
       -> MPU_Read_Len                  0      0     36
       -> MPU_Read_Len                  0      0     36
       -> mpu_reset_fifo                0      0     36
       -> MPU_Read_Len                  0      0     36
     mpu_read_mem                       2      0     56
       -> MPU_Write_Len                 0      0     28
       -> MPU_Read_Len                  0      0     28
     mpu_read_reg                       0      0      9
       -> MPU_Read_Len                  0      0     18
     mpu_reg_dump                       0      0     15
       -> printf                        0      0     30
       -> MPU_Read_Len                  0      0     22
     mpu_reset_fifo                     2      0     37
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> delay_ms                      4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> delay_ms                      4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
     mpu_run_self_test                  0      0     94
       -> mpu_set_dmp_state             0      0     96
       -> mpu_get_gyro_fsr              0      0     96
       -> mpu_get_accel_fsr             0      0     96
       -> mpu_get_lpf                   0      0     96
       -> mpu_get_sample_rate           0      0     96
       -> mpu_get_fifo_config           0      0     96
       -> get_st_biases                 0      0     96
       -> get_st_biases                 0      0     96
       -> accel_self_test               0      0     96
       -> gyro_self_test                0      0     96
       -> mpu_set_gyro_fsr              0      0     96
       -> mpu_set_accel_fsr             0      0     96
       -> mpu_set_lpf                   0      0     96
       -> mpu_set_sample_rate           0      0     96
       -> mpu_set_sensors               0      0     96
       -> mpu_configure_fifo            0      0     96
       -> mpu_set_dmp_state             0      0     96
     mpu_set_accel_bias                 1      0     44
       -> MPU_Read_Len                  0      0     88
       -> MPU_Read_Len                  0      0     88
       -> MPU_Write_Len                 0      0     88
     mpu_set_accel_fsr                  0      0     58
       -> MPU_Write_Len                 0      0     20
     mpu_set_bypass                     0      0     26
       -> MPU_Read_Len                  0      0     20
       -> MPU_Write_Len                 0      0     20
       -> delay_ms                      0      0     20
       -> MPU_Write_Len                 0      0     20
       -> MPU_Read_Len                  0      0     20
       -> MPU_Write_Len                 0      0     20
       -> delay_ms                      0      0     20
       -> MPU_Write_Len                 0      0     20
     mpu_set_compass_sample_rate        0      0      0
     mpu_set_dmp_state                  1      0     58
       -> set_int_enable                0      0     20
       -> mpu_set_bypass                0      0     20
       -> mpu_set_sample_rate           0      0     20
       -> MPU_Write_Len                 0      0     20
       -> set_int_enable                0      0     20
       -> mpu_reset_fifo                0      0     20
       -> set_int_enable                0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_reset_fifo                0      0     20
     mpu_set_gyro_fsr                   0      0     59
       -> MPU_Write_Len                 0      0     22
     mpu_set_int_latched                0      0     21
       -> MPU_Write_Len                 0      0     20
     mpu_set_int_level                  2      0      0
     mpu_set_lpf                        2      0     49
       -> MPU_Write_Len                 4      0      2
     mpu_set_sample_rate                1      0     58
       -> mpu_lp_accel_mode             0      0     20
       -> mpu_lp_accel_mode             0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_set_lpf                   0      0     20
     mpu_set_sensors                    0      0     58
       -> MPU_Write_Len                 0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_set_int_latched           0      0     20
       -> delay_ms                      0      0     20
     mpu_write_mem                      2      0     56
       -> MPU_Write_Len                 0      0     28
       -> MPU_Write_Len                 0      0     28
     run_self_test                      0      0     46
       -> mpu_run_self_test             0      0     92
       -> mpu_get_gyro_sens             0      0     92
       -> dmp_set_gyro_bias             0      0     92
       -> mpu_get_accel_sens            0      0     92
       -> dmp_set_accel_bias            0      0     92
     set_int_enable                     0      0     23
       -> MPU_Write_Len                 0      0     20
       -> MPU_Write_Len                 0      0     20
     setup_compass                      0      0      0


   Segment part sizes:

     Function/Label                           Bytes
     --------------                           -----
     reg                                        27
     hw                                         10
     test                                       39
     st                                         35
     set_int_enable                            106
     ?Subroutine0                                2
     ??Subroutine105_0                           3
     ??Subroutine106_0                           5
     ?Subroutine101                              8
     ?Subroutine98                               4
     ?Subroutine102                              9
     ??Subroutine136_0                           7
     ?Subroutine93                               7
     ??Subroutine140_0                           3
     ??Subroutine141_0                           8
     ?Subroutine88                               4
     ?Subroutine100                             11
     ?Subroutine73                              11
     mpu_reg_dump                              109
     ?Subroutine45                              13
     ?Subroutine24                               9
     ?Subroutine1                                2
     ??Subroutine103_0                           3
     ??Subroutine104_0                           5
     ?Subroutine81                               5
     ??Subroutine117_0                           7
     ?Subroutine75                               6
     ?Subroutine99                              14
     mpu_read_reg                               65
     ?Subroutine31                               7
     ?Subroutine82                               5
     mpu_init                                  401
     ??Subroutine107_0                           3
     ??Subroutine108_0                           8
     ?Subroutine63                              10
     ?Subroutine57                               4
     ??Subroutine125_0                          15
     ??Subroutine129_0                           4
     ?Subroutine90                              14
     ??Subroutine139_0                           6
     mpu_lp_accel_mode                         163
     ?Subroutine8                                4
     ?Subroutine65                              10
     ?Subroutine11                               8
     ??Subroutine137_0                           3
     ??Subroutine138_0                           6
     ?Subroutine92                               8
     mpu_get_gyro_reg                           86
     ?Subroutine9                                4
     ?Subroutine44                              10
     ?Subroutine38                              12
     ?Subroutine28                              16
     ?Subroutine85                               6
     ?Subroutine46                              11
     mpu_get_accel_reg                          88
     mpu_get_temperature                       190
     ?Subroutine79                               8
     ?Subroutine20                              11
     ?Subroutine2                                2
     ??Subroutine133_0                           8
     mpu_set_accel_bias                        560
     ?Subroutine66                               9
     ?Subroutine59                               1
     ??Subroutine109_0                           5
     ?Subroutine55                               8
     ?Subroutine40                              12
     ?Subroutine39                               9
     ??Subroutine122_0                           7
     ?Subroutine94                               6
     ??Subroutine123_0                          10
     ??Subroutine124_0                           4
     ?Subroutine77                               3
     ?Subroutine78                               8
     ?Subroutine89                               6
     ?Subroutine91                              12
     ?Subroutine83                               6
     mpu_reset_fifo                            265
     ?Subroutine10                               8
     ?Subroutine34                               2
     ??Subroutine110_0                           1
     ??Subroutine111_0                           6
     ??Subroutine112_0                           4
     ?Subroutine76                              11
     ?Subroutine23                               3
     ??Subroutine118_0                           8
     ??Subroutine121_0                           7
     ?Subroutine33                               1
     ??Subroutine126_0                           1
     ??Subroutine127_0                           4
     ??Subroutine128_0                           7
     ?Subroutine51                               1
     mpu_get_gyro_fsr                           78
     ??Subroutine119_0                           3
     ??Subroutine120_0                           2
     mpu_set_gyro_fsr                          121
     ?Subroutine87                               6
     ??Subroutine113_0                           7
     ?Subroutine22                              14
     ?Subroutine86                              10
     ?Subroutine32                               4
     ?Subroutine74                              13
     ?Subroutine97                              10
     mpu_get_accel_fsr                          79
     mpu_set_accel_fsr                         111
     ??Subroutine130_0                           5
     mpu_get_lpf                                89
     mpu_set_lpf                               155
     ?Subroutine47                               4
     mpu_get_sample_rate                        35
     ?Subroutine58                               3
     ??Subroutine135_0                           6
     mpu_set_sample_rate                       164
     ?Subroutine84                              10
     ?Subroutine36                               3
     mpu_get_compass_sample_rate                19
     mpu_set_compass_sample_rate                 3
     ?Subroutine4                                7
     mpu_get_gyro_sens                          67
     mpu_get_accel_sens                        104
     mpu_get_fifo_config                        10
     ?Subroutine3                                5
     mpu_configure_fifo                        112
     ??Subroutine134_0                           5
     mpu_get_power_state                        22
     mpu_set_sensors                           168
     mpu_get_int_status                         64
     ?Subroutine12                               6
     mpu_read_fifo                             446
     ?Subroutine53                               2
     ??Subroutine114_0                          12
     ?Subroutine50                              10
     ?Subroutine41                              20
     ?Subroutine80                              13
     ?Subroutine13                               6
     ??Subroutine115_0                           9
     ??Subroutine116_0                           6
     ?Subroutine42                               7
     ?Subroutine19                              13
     ?Subroutine6                                8
     ?Subroutine72                               6
     mpu_read_fifo_stream                      174
     mpu_set_bypass                            260
     mpu_set_int_level                          10
     mpu_set_int_latched                       107
     get_accel_prod_shift                      264
     ?Subroutine7                                8
     ?Subroutine30                               7
     ?Subroutine14                               2
     accel_self_test                           288
     ?Subroutine68                              13
     ?Subroutine70                              13
     ?Subroutine69                              14
     ?Subroutine60                               9
     ?Subroutine56                              14
     ?Subroutine96                              11
     ?Subroutine95                               1
     ??Subroutine132_0                           8
     gyro_self_test                            321
     get_st_biases                            1263
     ?Subroutine64                               3
     ?Subroutine35                               1
     ?Subroutine25                               6
     ?Subroutine21                               6
     ?Subroutine17                               1
     ?Subroutine16                               3
     ??Subroutine131_0                           4
     ?Subroutine15                               6
     mpu_run_self_test                         303
     ?Subroutine71                               9
     ?Subroutine61                               9
     ?Subroutine37                               7
     ?Subroutine52                              23
     ?Subroutine49                               7
     ?Subroutine48                               7
     mpu_write_mem                             105
     ?Subroutine5                                5
     ?Subroutine43                               8
     ?Subroutine26                              11
     ?Subroutine18                              40
     mpu_read_mem                              107
     mpu_load_firmware                         284
     ?Subroutine54                               9
     mpu_set_dmp_state                          95
     ?Subroutine29                              15
     mpu_get_dmp_state                          10
     setup_compass                               2
     mpu_get_compass_reg                         0
     mpu_get_compass_fsr                         2
     mpu_lp_motion_interrupt                   440
     gyro_orientation                            9
     run_self_test                             298
     inv_orientation_matrix_to_scalar
                                                69
     ?Subroutine62                              13
     inv_row_2_scale                            72
     ?Subroutine67                               6
     ?Subroutine27                               1
     ??Subroutine142_0                          11
     mget_ms                                     3
     mpu_dmp_init                              132
     mpu_dmp_get_data                          953
     ?<Initializer for st>                      35
     ?<Initializer for gyro_orientation>         9
     ??set_int_enable?relay                      6
     ??mpu_reg_dump?relay                        6
     ??mpu_read_reg?relay                        6
     ??mpu_init?relay                            6
     ??mpu_lp_accel_mode?relay                   6
     ??mpu_get_gyro_reg?relay                    6
     ??mpu_get_accel_reg?relay                   6
     ??mpu_get_temperature?relay                 6
     ??mpu_set_accel_bias?relay                  6
     ??mpu_reset_fifo?relay                      6
     ??mpu_get_gyro_fsr?relay                    6
     ??mpu_set_gyro_fsr?relay                    6
     ??mpu_get_accel_fsr?relay                   6
     ??mpu_set_accel_fsr?relay                   6
     ??mpu_get_lpf?relay                         6
     ??mpu_set_lpf?relay                         6
     ??mpu_get_sample_rate?relay                 6
     ??mpu_set_sample_rate?relay                 6
     ??mpu_get_compass_sample_rate?relay         6
     ??mpu_set_compass_sample_rate?relay         6
     ??mpu_get_gyro_sens?relay                   6
     ??mpu_get_accel_sens?relay                  6
     ??mpu_get_fifo_config?relay                 6
     ??mpu_configure_fifo?relay                  6
     ??mpu_get_power_state?relay                 6
     ??mpu_set_sensors?relay                     6
     ??mpu_get_int_status?relay                  6
     ??mpu_read_fifo?relay                       6
     ??mpu_read_fifo_stream?relay                6
     ??mpu_set_bypass?relay                      6
     ??mpu_set_int_level?relay                   6
     ??mpu_set_int_latched?relay                 6
     ??get_accel_prod_shift?relay                6
     ??accel_self_test?relay                     6
     ??gyro_self_test?relay                      6
     ??get_st_biases?relay                       6
     ??mpu_run_self_test?relay                   6
     ??mpu_write_mem?relay                       6
     ??mpu_read_mem?relay                        6
     ??mpu_load_firmware?relay                   6
     ??mpu_set_dmp_state?relay                   6
     ??mpu_get_dmp_state?relay                   6
     ??setup_compass?relay                       6
     ??mpu_get_compass_reg?relay                 6
     ??mpu_get_compass_fsr?relay                 6
     ??mpu_lp_motion_interrupt?relay             6
     ??run_self_test?relay                       6
     ??inv_orientation_matrix_to_scalar?relay    6
     ??inv_row_2_scale?relay                     6
     ??mget_ms?relay                             6
     ??mpu_dmp_init?relay                        6
     ??mpu_dmp_get_data?relay                    6
     ?<Constant "%#5x: %#5x\r\n">               13
     ?<Constant "Unsupported software ...">     38
     ?<Constant "Product ID read as 0 ...">     77
     ?<Constant "Half sensitivity part...">     30
     __Constant_64                               4
     __Constant_420c0000                         4
     __Constant_47800000                         4
     __Constant_32                               4
     __Constant_43030000                         4
     __Constant_42830000                         4
     __Constant_42033333                         4
     __Constant_41833333                         4
     __Constant_3                                4
     __Constant_0                                4
     __Constant_3eae147b                         4
     __Constant_3f845a1d                         4
     __Constant_37800000                         4
     __Constant_bf800000                         4
     __Constant_3e0f5c2a                         4
     __Constant_3e99999a                         4
     __Constant_3f733334                         4
     __Constant_41c80000                         4
     __Constant_3f85e354                         4
     __Constant_41200000                         4
     __Constant_42d20001                         4
     __Constant_c8                               4
     __Constant_f                                4
     __Constant_83                               4
     __Constant_1                                4
     __Constant_ffff0000                         4
     __Constant_10000                            4
     __Constant_5                                4
     __Constant_30800000                         4
     __Constant_40000000                         4
     __Constant_c0000000                         4
     __Constant_42653333                         4
     __Constant_3f800000                         4

 
 10 507 bytes in segment BANKED_CODE
    312 bytes in segment BANK_RELAYS
     44 bytes in segment XDATA_I
     44 bytes in segment XDATA_ID
    366 bytes in segment XDATA_ROM_C
 
 10 863 bytes of CODE  memory
    234 bytes of CONST memory (+ 132 bytes shared)
     44 bytes of XDATA memory

Errors: none
Warnings: none
