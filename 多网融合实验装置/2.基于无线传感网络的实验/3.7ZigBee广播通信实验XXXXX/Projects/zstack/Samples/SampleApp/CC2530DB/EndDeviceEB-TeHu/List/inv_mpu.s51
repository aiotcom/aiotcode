///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.3.10338/W32 for 8051        02/Jan/2020  15:18:22 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ /
//                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7               /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Components\HARDWARE\MPU6050\eM /
//                          PL\inv_mpu.c                                      /
//    Command line       =  -f "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé /
//                          ×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7           /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg /
//                          " (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS)    /
//                          -f "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé /
//                          ×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7           /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cf /
//                          g" (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR  /
//                          -DDEFAULT_CHANLIST=0x00000800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFF11                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          "-DCONST=const __code" -DGENERIC=__generic        /
//                          -DRFD_RCVC_ALWAYS_ON=TRUE -DPOLL_RATE=1000        /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)  /
//                          -DREJOIN_POLL_RATE=440 "D:\OuYangDong\Project\ÊµÑ /
//                          éÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂç /
//                          µÄÊµÑé\3.7 ZigBee¹ã²¥Í¨ÐÅÊµÑé\Components\HARDWARE /
//                          \MPU6050\eMPL\inv_mpu.c" -D NWK_AUTO_POLL -D      /
//                          ZTOOL_P1 -D MT_SYS_FUNC -D MT_ZDO_FUNC -D         /
//                          LCD_SUPPORTED=DEBUG -lC                           /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\EndDeviceEB-TeHu\List\" -lA          /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\EndDeviceEB-TeHu\List\"              /
//                          --diag_suppress Pe001,Pa010 -o                    /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\EndDeviceEB-TeHu\Obj\" -e            /
//                          --no_unroll --no_inline --no_tbaa --debug         /
//                          --core=plain --dptr=16,1 --data_model=large       /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I                           /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨ /
//                          Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑ /
//                          é\3.7 ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\ /
//                          SampleApp\CC2530DB\..\SOURCE\" -I                 /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I         /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I    /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUD /
//                          E\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏ /
//                          ÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7       /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET /
//                          \CC2530EB\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\ /
//                          ¶àÍøÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3 /
//                          .7 ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sam /
//                          pleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MC /
//                          U\CCSOC\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶à /
//                          ÍøÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7 /
//                           ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sampl /
//                          eApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCL /
//                          UDE\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚ /
//                          ºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7     /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\" /
//                           -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑ /
//                          é×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7          /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ /
//                          " -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµ /
//                          Ñé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7         /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\ /
//                          " -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµ /
//                          Ñé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7         /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI /
//                          \" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊ /
//                          µÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7        /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\ /
//                          " -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµ /
//                          Ñé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7         /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ /
//                          " -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµ /
//                          Ñé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7         /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\" /
//                           -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑ /
//                          é×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7          /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I  /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\S /
//                          ADDR\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈ /
//                          ÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7    /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\S /
//                          DATA\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈ /
//                          ÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7    /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUD /
//                          E\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏ /
//                          ÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7       /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_L /
//                          EVEL\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈ /
//                          ÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7    /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LE /
//                          VEL\srf04\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\ /
//                          ¶àÍøÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3 /
//                          .7 ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sam /
//                          pleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW /
//                          _LEVEL\srf04\SINGLE_CHIP\" -I                     /
//                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°Ö /
//                          Ã\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7              /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\HARDWARE\" /
//                           -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑ /
//                          é×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7          /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\HARDWARE\M /
//                          PU6050\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍ /
//                          øÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7  /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\..\..\..\..\..\COMPONENTS\HARDWARE\M /
//                          PU6050\eMPL\" -Om                                 /
//    List file          =  D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ /
//                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7               /
//                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\Sample /
//                          App\CC2530DB\EndDeviceEB-TeHu\List\inv_mpu.s51    /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME inv_mpu

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FLT_ADD
        EXTERN ?FLT_DIV
        EXTERN ?FLT_EQ
        EXTERN ?FLT_GE
        EXTERN ?FLT_LT
        EXTERN ?FLT_MUL
        EXTERN ?FLT_SUB
        EXTERN ?FLT_TO_L
        EXTERN ?L_ADD_TO_X
        EXTERN ?L_DIV_MOD
        EXTERN ?L_MOV_TO_X
        EXTERN ?L_MOV_X
        EXTERN ?L_SHL
        EXTERN ?L_SUB_X
        EXTERN ?L_TO_FLT
        EXTERN ?PUSH_XSTACK_I_FOUR
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?SL_GT_X
        EXTERN ?SS_SHR
        EXTERN ?S_DIV_MOD
        EXTERN ?S_SHL
        EXTERN ?UL_DIV_MOD
        EXTERN ?UL_SHR
        EXTERN ?UL_TO_FLT
        EXTERN ?US_DIV_MOD
        EXTERN ?US_SHR
        EXTERN ?US_SWITCH_SPARSE
        EXTERN ?V0
        EXTERN ?XLOAD_R2345
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTORE_R2345
        EXTERN __INIT_XDATA_I

        FUNCTION ??accel_self_test?relay,0203H
        FUNCTION ??get_accel_prod_shift?relay,0203H
        FUNCTION ??get_st_biases?relay,0203H
        FUNCTION ??gyro_self_test?relay,0203H
        PUBLIC ??inv_orientation_matrix_to_scalar?relay
        FUNCTION ??inv_orientation_matrix_to_scalar?relay,0203H
        PUBLIC ??inv_row_2_scale?relay
        FUNCTION ??inv_row_2_scale?relay,0203H
        PUBLIC ??mget_ms?relay
        FUNCTION ??mget_ms?relay,0203H
        PUBLIC ??mpu_configure_fifo?relay
        FUNCTION ??mpu_configure_fifo?relay,0203H
        PUBLIC ??mpu_dmp_get_data?relay
        FUNCTION ??mpu_dmp_get_data?relay,0203H
        PUBLIC ??mpu_dmp_init?relay
        FUNCTION ??mpu_dmp_init?relay,0203H
        PUBLIC ??mpu_get_accel_fsr?relay
        FUNCTION ??mpu_get_accel_fsr?relay,0203H
        PUBLIC ??mpu_get_accel_reg?relay
        FUNCTION ??mpu_get_accel_reg?relay,0203H
        PUBLIC ??mpu_get_accel_sens?relay
        FUNCTION ??mpu_get_accel_sens?relay,0203H
        PUBLIC ??mpu_get_compass_fsr?relay
        FUNCTION ??mpu_get_compass_fsr?relay,0203H
        PUBLIC ??mpu_get_compass_reg?relay
        FUNCTION ??mpu_get_compass_reg?relay,0203H
        PUBLIC ??mpu_get_compass_sample_rate?relay
        FUNCTION ??mpu_get_compass_sample_rate?relay,0203H
        PUBLIC ??mpu_get_dmp_state?relay
        FUNCTION ??mpu_get_dmp_state?relay,0203H
        PUBLIC ??mpu_get_fifo_config?relay
        FUNCTION ??mpu_get_fifo_config?relay,0203H
        PUBLIC ??mpu_get_gyro_fsr?relay
        FUNCTION ??mpu_get_gyro_fsr?relay,0203H
        PUBLIC ??mpu_get_gyro_reg?relay
        FUNCTION ??mpu_get_gyro_reg?relay,0203H
        PUBLIC ??mpu_get_gyro_sens?relay
        FUNCTION ??mpu_get_gyro_sens?relay,0203H
        PUBLIC ??mpu_get_int_status?relay
        FUNCTION ??mpu_get_int_status?relay,0203H
        PUBLIC ??mpu_get_lpf?relay
        FUNCTION ??mpu_get_lpf?relay,0203H
        PUBLIC ??mpu_get_power_state?relay
        FUNCTION ??mpu_get_power_state?relay,0203H
        PUBLIC ??mpu_get_sample_rate?relay
        FUNCTION ??mpu_get_sample_rate?relay,0203H
        PUBLIC ??mpu_get_temperature?relay
        FUNCTION ??mpu_get_temperature?relay,0203H
        PUBLIC ??mpu_init?relay
        FUNCTION ??mpu_init?relay,0203H
        PUBLIC ??mpu_load_firmware?relay
        FUNCTION ??mpu_load_firmware?relay,0203H
        PUBLIC ??mpu_lp_accel_mode?relay
        FUNCTION ??mpu_lp_accel_mode?relay,0203H
        PUBLIC ??mpu_lp_motion_interrupt?relay
        FUNCTION ??mpu_lp_motion_interrupt?relay,0203H
        PUBLIC ??mpu_read_fifo?relay
        FUNCTION ??mpu_read_fifo?relay,0203H
        PUBLIC ??mpu_read_fifo_stream?relay
        FUNCTION ??mpu_read_fifo_stream?relay,0203H
        PUBLIC ??mpu_read_mem?relay
        FUNCTION ??mpu_read_mem?relay,0203H
        PUBLIC ??mpu_read_reg?relay
        FUNCTION ??mpu_read_reg?relay,0203H
        PUBLIC ??mpu_reg_dump?relay
        FUNCTION ??mpu_reg_dump?relay,0203H
        PUBLIC ??mpu_reset_fifo?relay
        FUNCTION ??mpu_reset_fifo?relay,0203H
        PUBLIC ??mpu_run_self_test?relay
        FUNCTION ??mpu_run_self_test?relay,0203H
        PUBLIC ??mpu_set_accel_bias?relay
        FUNCTION ??mpu_set_accel_bias?relay,0203H
        PUBLIC ??mpu_set_accel_fsr?relay
        FUNCTION ??mpu_set_accel_fsr?relay,0203H
        PUBLIC ??mpu_set_bypass?relay
        FUNCTION ??mpu_set_bypass?relay,0203H
        PUBLIC ??mpu_set_compass_sample_rate?relay
        FUNCTION ??mpu_set_compass_sample_rate?relay,0203H
        PUBLIC ??mpu_set_dmp_state?relay
        FUNCTION ??mpu_set_dmp_state?relay,0203H
        PUBLIC ??mpu_set_gyro_fsr?relay
        FUNCTION ??mpu_set_gyro_fsr?relay,0203H
        PUBLIC ??mpu_set_int_latched?relay
        FUNCTION ??mpu_set_int_latched?relay,0203H
        PUBLIC ??mpu_set_int_level?relay
        FUNCTION ??mpu_set_int_level?relay,0203H
        PUBLIC ??mpu_set_lpf?relay
        FUNCTION ??mpu_set_lpf?relay,0203H
        PUBLIC ??mpu_set_sample_rate?relay
        FUNCTION ??mpu_set_sample_rate?relay,0203H
        PUBLIC ??mpu_set_sensors?relay
        FUNCTION ??mpu_set_sensors?relay,0203H
        PUBLIC ??mpu_write_mem?relay
        FUNCTION ??mpu_write_mem?relay,0203H
        PUBLIC ??run_self_test?relay
        FUNCTION ??run_self_test?relay,0203H
        FUNCTION ??set_int_enable?relay,0203H
        PUBLIC ??setup_compass?relay
        FUNCTION ??setup_compass?relay,0203H
        PUBWEAK __Constant_0
        PUBWEAK __Constant_1
        PUBWEAK __Constant_10000
        PUBWEAK __Constant_3
        PUBWEAK __Constant_30800000
        PUBWEAK __Constant_32
        PUBWEAK __Constant_37800000
        PUBWEAK __Constant_3e0f5c2a
        PUBWEAK __Constant_3e99999a
        PUBWEAK __Constant_3eae147b
        PUBWEAK __Constant_3f733334
        PUBWEAK __Constant_3f800000
        PUBWEAK __Constant_3f845a1d
        PUBWEAK __Constant_3f85e354
        PUBWEAK __Constant_40000000
        PUBWEAK __Constant_41200000
        PUBWEAK __Constant_41833333
        PUBWEAK __Constant_41c80000
        PUBWEAK __Constant_42033333
        PUBWEAK __Constant_420c0000
        PUBWEAK __Constant_42653333
        PUBWEAK __Constant_42830000
        PUBWEAK __Constant_42d20001
        PUBWEAK __Constant_43030000
        PUBWEAK __Constant_47800000
        PUBWEAK __Constant_5
        PUBWEAK __Constant_64
        PUBWEAK __Constant_83
        PUBWEAK __Constant_bf800000
        PUBWEAK __Constant_c0000000
        PUBWEAK __Constant_c8
        PUBWEAK __Constant_f
        PUBWEAK __Constant_ffff0000
        FUNCTION accel_self_test,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 38, STACK
        FUNCTION get_accel_prod_shift,021203H
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 29, STACK
        FUNCTION get_st_biases,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 55, STACK
        FUNCTION gyro_self_test,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 29, STACK
        PUBLIC hw
        PUBLIC inv_orientation_matrix_to_scalar
        FUNCTION inv_orientation_matrix_to_scalar,021203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBLIC inv_row_2_scale
        FUNCTION inv_row_2_scale,0203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mget_ms
        FUNCTION mget_ms,0203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUBLIC mpu_configure_fifo
        FUNCTION mpu_configure_fifo,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBLIC mpu_dmp_get_data
        FUNCTION mpu_dmp_get_data,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME ISTACK, 4, STACK
        LOCFRAME XSTACK, 87, STACK
        PUBLIC mpu_dmp_init
        FUNCTION mpu_dmp_init,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_get_accel_fsr
        FUNCTION mpu_get_accel_fsr,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        PUBLIC mpu_get_accel_reg
        FUNCTION mpu_get_accel_reg,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC mpu_get_accel_sens
        FUNCTION mpu_get_accel_sens,0203H
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_compass_fsr
        FUNCTION mpu_get_compass_fsr,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC mpu_get_compass_reg
        FUNCTION mpu_get_compass_reg,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC mpu_get_compass_sample_rate
        FUNCTION mpu_get_compass_sample_rate,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_dmp_state
        FUNCTION mpu_get_dmp_state,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 3, STACK
        PUBLIC mpu_get_fifo_config
        FUNCTION mpu_get_fifo_config,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        PUBLIC mpu_get_gyro_fsr
        FUNCTION mpu_get_gyro_fsr,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_gyro_reg
        FUNCTION mpu_get_gyro_reg,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC mpu_get_gyro_sens
        FUNCTION mpu_get_gyro_sens,0203H
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        PUBLIC mpu_get_int_status
        FUNCTION mpu_get_int_status,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC mpu_get_lpf
        FUNCTION mpu_get_lpf,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_power_state
        FUNCTION mpu_get_power_state,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_sample_rate
        FUNCTION mpu_get_sample_rate,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_temperature
        FUNCTION mpu_get_temperature,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        PUBLIC mpu_init
        FUNCTION mpu_init,021203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 18, STACK
        PUBLIC mpu_load_firmware
        FUNCTION mpu_load_firmware,021203H
        ARGFRAME XSTACK, 4, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 42, STACK
        PUBLIC mpu_lp_accel_mode
        FUNCTION mpu_lp_accel_mode,021203H
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC mpu_lp_motion_interrupt
        FUNCTION mpu_lp_motion_interrupt,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 13, STACK
        PUBLIC mpu_read_fifo
        FUNCTION mpu_read_fifo,021203H
        ARGFRAME XSTACK, 6, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 36, STACK
        PUBLIC mpu_read_fifo_stream
        FUNCTION mpu_read_fifo_stream,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 18, STACK
        PUBLIC mpu_read_mem
        FUNCTION mpu_read_mem,021203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC mpu_read_reg
        FUNCTION mpu_read_reg,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC mpu_reg_dump
        FUNCTION mpu_reg_dump,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        PUBLIC mpu_reset_fifo
        FUNCTION mpu_reset_fifo,021203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 1, STACK
        PUBLIC mpu_run_self_test
        FUNCTION mpu_run_self_test,021203H
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 48, STACK
        PUBLIC mpu_set_accel_bias
        FUNCTION mpu_set_accel_bias,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 40, STACK
        PUBLIC mpu_set_accel_fsr
        FUNCTION mpu_set_accel_fsr,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_bypass
        FUNCTION mpu_set_bypass,021203H
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_compass_sample_rate
        FUNCTION mpu_set_compass_sample_rate,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC mpu_set_dmp_state
        FUNCTION mpu_set_dmp_state,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_gyro_fsr
        FUNCTION mpu_set_gyro_fsr,0a1203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 11, STACK
        PUBLIC mpu_set_int_latched
        FUNCTION mpu_set_int_latched,021203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_int_level
        FUNCTION mpu_set_int_level,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_set_lpf
        FUNCTION mpu_set_lpf,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 1, STACK
        PUBLIC mpu_set_sample_rate
        FUNCTION mpu_set_sample_rate,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_sensors
        FUNCTION mpu_set_sensors,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_write_mem
        FUNCTION mpu_write_mem,021203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC reg
        PUBLIC run_self_test
        FUNCTION run_self_test,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        FUNCTION set_int_enable,021203H
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC setup_compass
        FUNCTION setup_compass,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC test
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
MPU_Write_Len       SYMBOL "MPU_Write_Len"
printf              SYMBOL "printf"
MPU_Read_Len        SYMBOL "MPU_Read_Len"
delay_ms            SYMBOL "delay_ms"
memset              SYMBOL "memset"
labs                SYMBOL "labs"
memcmp              SYMBOL "memcmp"
dmp_set_gyro_bias   SYMBOL "dmp_set_gyro_bias"
dmp_set_accel_bias  SYMBOL "dmp_set_accel_bias"
MPU_IIC_Init        SYMBOL "MPU_IIC_Init"
dmp_load_motion_driver_firmware SYMBOL "dmp_load_motion_driver_firmware"
dmp_set_orientation SYMBOL "dmp_set_orientation"
dmp_enable_feature  SYMBOL "dmp_enable_feature"
dmp_set_fifo_rate   SYMBOL "dmp_set_fifo_rate"
dmp_read_fifo       SYMBOL "dmp_read_fifo"
asin                SYMBOL "asin"
atan2               SYMBOL "atan2"
??MPU_IIC_Init?relay SYMBOL "?relay", MPU_IIC_Init
??MPU_Read_Len?relay SYMBOL "?relay", MPU_Read_Len
??MPU_Write_Len?relay SYMBOL "?relay", MPU_Write_Len
??asin?relay        SYMBOL "?relay", asin
??atan2?relay       SYMBOL "?relay", atan2
??delay_ms?relay    SYMBOL "?relay", delay_ms
??dmp_enable_feature?relay SYMBOL "?relay", dmp_enable_feature
??dmp_load_motion_driver_firmware?relay SYMBOL "?relay", dmp_load_motion_driver_firmware
??dmp_read_fifo?relay SYMBOL "?relay", dmp_read_fifo
??dmp_set_accel_bias?relay SYMBOL "?relay", dmp_set_accel_bias
??dmp_set_fifo_rate?relay SYMBOL "?relay", dmp_set_fifo_rate
??dmp_set_gyro_bias?relay SYMBOL "?relay", dmp_set_gyro_bias
??dmp_set_orientation?relay SYMBOL "?relay", dmp_set_orientation
??labs?relay        SYMBOL "?relay", labs
??memcmp?relay      SYMBOL "?relay", memcmp
??memset?relay      SYMBOL "?relay", memset
??printf?relay      SYMBOL "?relay", printf
inv_orientation_matrix_to_scalar SYMBOL "inv_orientation_matrix_to_scalar"
??inv_orientation_matrix_to_scalar?relay SYMBOL "?relay", inv_orientation_matrix_to_scalar
inv_row_2_scale     SYMBOL "inv_row_2_scale"
??inv_row_2_scale?relay SYMBOL "?relay", inv_row_2_scale
mget_ms             SYMBOL "mget_ms"
??mget_ms?relay     SYMBOL "?relay", mget_ms
mpu_configure_fifo  SYMBOL "mpu_configure_fifo"
??mpu_configure_fifo?relay SYMBOL "?relay", mpu_configure_fifo
mpu_dmp_get_data    SYMBOL "mpu_dmp_get_data"
??mpu_dmp_get_data?relay SYMBOL "?relay", mpu_dmp_get_data
mpu_dmp_init        SYMBOL "mpu_dmp_init"
??mpu_dmp_init?relay SYMBOL "?relay", mpu_dmp_init
mpu_get_accel_fsr   SYMBOL "mpu_get_accel_fsr"
??mpu_get_accel_fsr?relay SYMBOL "?relay", mpu_get_accel_fsr
mpu_get_accel_reg   SYMBOL "mpu_get_accel_reg"
??mpu_get_accel_reg?relay SYMBOL "?relay", mpu_get_accel_reg
mpu_get_accel_sens  SYMBOL "mpu_get_accel_sens"
??mpu_get_accel_sens?relay SYMBOL "?relay", mpu_get_accel_sens
mpu_get_compass_fsr SYMBOL "mpu_get_compass_fsr"
??mpu_get_compass_fsr?relay SYMBOL "?relay", mpu_get_compass_fsr
mpu_get_compass_reg SYMBOL "mpu_get_compass_reg"
??mpu_get_compass_reg?relay SYMBOL "?relay", mpu_get_compass_reg
mpu_get_compass_sample_rate SYMBOL "mpu_get_compass_sample_rate"
??mpu_get_compass_sample_rate?relay SYMBOL "?relay", mpu_get_compass_sample_rate
mpu_get_dmp_state   SYMBOL "mpu_get_dmp_state"
??mpu_get_dmp_state?relay SYMBOL "?relay", mpu_get_dmp_state
mpu_get_fifo_config SYMBOL "mpu_get_fifo_config"
??mpu_get_fifo_config?relay SYMBOL "?relay", mpu_get_fifo_config
mpu_get_gyro_fsr    SYMBOL "mpu_get_gyro_fsr"
??mpu_get_gyro_fsr?relay SYMBOL "?relay", mpu_get_gyro_fsr
mpu_get_gyro_reg    SYMBOL "mpu_get_gyro_reg"
??mpu_get_gyro_reg?relay SYMBOL "?relay", mpu_get_gyro_reg
mpu_get_gyro_sens   SYMBOL "mpu_get_gyro_sens"
??mpu_get_gyro_sens?relay SYMBOL "?relay", mpu_get_gyro_sens
mpu_get_int_status  SYMBOL "mpu_get_int_status"
??mpu_get_int_status?relay SYMBOL "?relay", mpu_get_int_status
mpu_get_lpf         SYMBOL "mpu_get_lpf"
??mpu_get_lpf?relay SYMBOL "?relay", mpu_get_lpf
mpu_get_power_state SYMBOL "mpu_get_power_state"
??mpu_get_power_state?relay SYMBOL "?relay", mpu_get_power_state
mpu_get_sample_rate SYMBOL "mpu_get_sample_rate"
??mpu_get_sample_rate?relay SYMBOL "?relay", mpu_get_sample_rate
mpu_get_temperature SYMBOL "mpu_get_temperature"
??mpu_get_temperature?relay SYMBOL "?relay", mpu_get_temperature
mpu_init            SYMBOL "mpu_init"
??mpu_init?relay    SYMBOL "?relay", mpu_init
mpu_load_firmware   SYMBOL "mpu_load_firmware"
??mpu_load_firmware?relay SYMBOL "?relay", mpu_load_firmware
mpu_lp_accel_mode   SYMBOL "mpu_lp_accel_mode"
??mpu_lp_accel_mode?relay SYMBOL "?relay", mpu_lp_accel_mode
mpu_lp_motion_interrupt SYMBOL "mpu_lp_motion_interrupt"
??mpu_lp_motion_interrupt?relay SYMBOL "?relay", mpu_lp_motion_interrupt
mpu_read_fifo       SYMBOL "mpu_read_fifo"
??mpu_read_fifo?relay SYMBOL "?relay", mpu_read_fifo
mpu_read_fifo_stream SYMBOL "mpu_read_fifo_stream"
??mpu_read_fifo_stream?relay SYMBOL "?relay", mpu_read_fifo_stream
mpu_read_mem        SYMBOL "mpu_read_mem"
??mpu_read_mem?relay SYMBOL "?relay", mpu_read_mem
mpu_read_reg        SYMBOL "mpu_read_reg"
??mpu_read_reg?relay SYMBOL "?relay", mpu_read_reg
mpu_reg_dump        SYMBOL "mpu_reg_dump"
??mpu_reg_dump?relay SYMBOL "?relay", mpu_reg_dump
mpu_reset_fifo      SYMBOL "mpu_reset_fifo"
??mpu_reset_fifo?relay SYMBOL "?relay", mpu_reset_fifo
mpu_run_self_test   SYMBOL "mpu_run_self_test"
??mpu_run_self_test?relay SYMBOL "?relay", mpu_run_self_test
mpu_set_accel_bias  SYMBOL "mpu_set_accel_bias"
??mpu_set_accel_bias?relay SYMBOL "?relay", mpu_set_accel_bias
mpu_set_accel_fsr   SYMBOL "mpu_set_accel_fsr"
??mpu_set_accel_fsr?relay SYMBOL "?relay", mpu_set_accel_fsr
mpu_set_bypass      SYMBOL "mpu_set_bypass"
??mpu_set_bypass?relay SYMBOL "?relay", mpu_set_bypass
mpu_set_compass_sample_rate SYMBOL "mpu_set_compass_sample_rate"
??mpu_set_compass_sample_rate?relay SYMBOL "?relay", mpu_set_compass_sample_rate
mpu_set_dmp_state   SYMBOL "mpu_set_dmp_state"
??mpu_set_dmp_state?relay SYMBOL "?relay", mpu_set_dmp_state
mpu_set_gyro_fsr    SYMBOL "mpu_set_gyro_fsr"
??mpu_set_gyro_fsr?relay SYMBOL "?relay", mpu_set_gyro_fsr
mpu_set_int_latched SYMBOL "mpu_set_int_latched"
??mpu_set_int_latched?relay SYMBOL "?relay", mpu_set_int_latched
mpu_set_int_level   SYMBOL "mpu_set_int_level"
??mpu_set_int_level?relay SYMBOL "?relay", mpu_set_int_level
mpu_set_lpf         SYMBOL "mpu_set_lpf"
??mpu_set_lpf?relay SYMBOL "?relay", mpu_set_lpf
mpu_set_sample_rate SYMBOL "mpu_set_sample_rate"
??mpu_set_sample_rate?relay SYMBOL "?relay", mpu_set_sample_rate
mpu_set_sensors     SYMBOL "mpu_set_sensors"
??mpu_set_sensors?relay SYMBOL "?relay", mpu_set_sensors
mpu_write_mem       SYMBOL "mpu_write_mem"
??mpu_write_mem?relay SYMBOL "?relay", mpu_write_mem
run_self_test       SYMBOL "run_self_test"
??run_self_test?relay SYMBOL "?relay", run_self_test
setup_compass       SYMBOL "setup_compass"
??setup_compass?relay SYMBOL "?relay", setup_compass

        EXTERN MPU_Write_Len
        FUNCTION MPU_Write_Len,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN printf
        FUNCTION printf,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN MPU_Read_Len
        FUNCTION MPU_Read_Len,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN delay_ms
        FUNCTION delay_ms,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memset
        FUNCTION memset,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN labs
        FUNCTION labs,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcmp
        FUNCTION memcmp,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_set_gyro_bias
        FUNCTION dmp_set_gyro_bias,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_set_accel_bias
        FUNCTION dmp_set_accel_bias,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN MPU_IIC_Init
        FUNCTION MPU_IIC_Init,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_load_motion_driver_firmware
        FUNCTION dmp_load_motion_driver_firmware,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_set_orientation
        FUNCTION dmp_set_orientation,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_enable_feature
        FUNCTION dmp_enable_feature,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_set_fifo_rate
        FUNCTION dmp_set_fifo_rate,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_read_fifo
        FUNCTION dmp_read_fifo,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 87, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN asin
        FUNCTION asin,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 79, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN atan2
        FUNCTION atan2,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 83, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??MPU_IIC_Init?relay
        FUNCTION ??MPU_IIC_Init?relay,00H
        EXTERN ??MPU_Read_Len?relay
        FUNCTION ??MPU_Read_Len?relay,00H
        EXTERN ??MPU_Write_Len?relay
        FUNCTION ??MPU_Write_Len?relay,00H
        EXTERN ??asin?relay
        FUNCTION ??asin?relay,00H
        EXTERN ??atan2?relay
        FUNCTION ??atan2?relay,00H
        EXTERN ??delay_ms?relay
        FUNCTION ??delay_ms?relay,00H
        EXTERN ??dmp_enable_feature?relay
        FUNCTION ??dmp_enable_feature?relay,00H
        EXTERN ??dmp_load_motion_driver_firmware?relay
        FUNCTION ??dmp_load_motion_driver_firmware?relay,00H
        EXTERN ??dmp_read_fifo?relay
        FUNCTION ??dmp_read_fifo?relay,00H
        EXTERN ??dmp_set_accel_bias?relay
        FUNCTION ??dmp_set_accel_bias?relay,00H
        EXTERN ??dmp_set_fifo_rate?relay
        FUNCTION ??dmp_set_fifo_rate?relay,00H
        EXTERN ??dmp_set_gyro_bias?relay
        FUNCTION ??dmp_set_gyro_bias?relay,00H
        EXTERN ??dmp_set_orientation?relay
        FUNCTION ??dmp_set_orientation?relay,00H
        EXTERN ??labs?relay
        FUNCTION ??labs?relay,00H
        EXTERN ??memcmp?relay
        FUNCTION ??memcmp?relay,00H
        EXTERN ??memset?relay
        FUNCTION ??memset?relay,00H
        EXTERN ??printf?relay
        FUNCTION ??printf?relay,00H

// D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7 ZigBee¹ã²¥Í¨ÐÅÊµÑé\Components\HARDWARE\MPU6050\eMPL\inv_mpu.c
//    1 /*
//    2  $License:
//    3     Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
//    4     See included License.txt for License information.
//    5  $
//    6  */
//    7 /**
//    8  *  @addtogroup  DRIVERS Sensor Driver Layer
//    9  *  @brief       Hardware drivers to communicate with sensors via I2C.
//   10  *
//   11  *  @{
//   12  *      @file       inv_mpu.c
//   13  *      @brief      An I2C-based driver for Invensense gyroscopes.
//   14  *      @details    This driver currently works for the following devices:
//   15  *                  MPU6050
//   16  *                  MPU6500
//   17  *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
//   18  *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
//   19  */
//   20 #include <stdio.h>
//   21 //#include <stdint.h>
//   22 #include <stdlib.h>
//   23 #include <string.h>
//   24 #include <math.h>
//   25 #include "inv_mpu.h"
//   26 #include "inv_mpu_dmp_motion_driver.h"
//   27 #include "mpu6050.h"
//   28 #include "delay.h"
//   29 
//   30 #define MPU6050					//¶¨ÒåÎÒÃÇÊ¹ÓÃµÄ´«¸ÐÆ÷ÎªMPU6050
//   31 #define MOTION_DRIVER_TARGET_MSP430		//¶¨ÒåÇý¶¯²¿·Ö,²ÉÓÃMSP430µÄÇý¶¯(ÒÆÖ²µ½STM32F1)
//   32 
//   33 /* The following functions must be defined for this platform:
//   34  * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
//   35  *      unsigned char length, unsigned char const *data)
//   36  * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
//   37  *      unsigned char length, unsigned char *data)
//   38  * delay_ms(unsigned long num_ms)
//   39  * get_ms(unsigned long *count)
//   40  * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
//   41  * labs(long x)
//   42  * fabsf(float x)
//   43  * min(int a, int b)
//   44  */
//   45 #if defined MOTION_DRIVER_TARGET_MSP430
//   46 //#include "msp430.h"
//   47 //#include "msp430_i2c.h"
//   48 //#include "msp430_clock.h"
//   49 //#include "msp430_interrupt.h"
//   50 
//   51 #define i2c_write   MPU_Write_Len
//   52 #define i2c_read    MPU_Read_Len
//   53 #define delay_ms    delay_ms
//   54 #define get_ms      mget_ms
//   55 //static inline int reg_int_cb(struct int_param_s *int_param)
//   56 //{
//   57 //    return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
//   58 //        int_param->active_low);
//   59 //}
//   60 #define log_i 	printf	//´òÓ¡ÐÅÏ¢
//   61 #define log_e  	printf	//´òÓ¡ÐÅÏ¢
//   62 /* labs is already defined by TI's toolchain. */
//   63 /* fabs is for doubles. fabsf is for floats. */
//   64 //#define fabs  fabsf
//   65 #define min(a,b) ((a<b)?a:b)
//   66 #elif defined EMPL_TARGET_MSP430
//   67 #include "msp430.h"
//   68 #include "msp430_i2c.h"
//   69 #include "msp430_clock.h"
//   70 #include "msp430_interrupt.h"
//   71 #include "log.h"
//   72 #define i2c_write   msp430_i2c_write
//   73 #define i2c_read    msp430_i2c_read
//   74 #define delay_ms    msp430_delay_ms
//   75 #define get_ms      msp430_get_clock_ms
//   76 static inline int reg_int_cb(struct int_param_s *int_param)
//   77 {
//   78     return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
//   79         int_param->active_low);
//   80 }
//   81 #define log_i       MPL_LOGI
//   82 #define log_e       MPL_LOGE
//   83 /* labs is already defined by TI's toolchain. */
//   84 /* fabs is for doubles. fabsf is for floats. */
//   85 #define fabs   fabsf
//   86 #define min(a,b) ((a<b)?a:b)
//   87 #elif defined EMPL_TARGET_UC3L0
//   88 /* Instead of using the standard TWI driver from the ASF library, we're using
//   89  * a TWI driver that follows the slave address + register address convention.
//   90  */
//   91 #include "twi.h"
//   92 #include "delay.h"
//   93 #include "sysclk.h"
//   94 #include "log.h"
//   95 #include "sensors_xplained.h"
//   96 #include "uc3l0_clock.h"
//   97 #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
//   98 #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
//   99 /* delay_ms is a function already defined in ASF. */
//  100 #define get_ms  uc3l0_get_clock_ms
//  101 static inline int reg_int_cb(struct int_param_s *int_param)
//  102 {
//  103     sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
//  104     return 0;
//  105 }
//  106 #define log_i       MPL_LOGI
//  107 #define log_e       MPL_LOGE
//  108 /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
//  109 #define labs        abs
//  110 #define fabs(x)     (((x)>0)?(x):-(x))
//  111 #else
//  112 #error  Gyro driver is missing the system layer implementations.
//  113 #endif
//  114 
//  115 #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
//  116 #error  Which gyro are you using? Define MPUxxxx in your compiler options.
//  117 #endif
//  118 
//  119 /* Time for some messy macro work. =]
//  120  * #define MPU9150
//  121  * is equivalent to..
//  122  * #define MPU6050
//  123  * #define AK8975_SECONDARY
//  124  *
//  125  * #define MPU9250
//  126  * is equivalent to..
//  127  * #define MPU6500
//  128  * #define AK8963_SECONDARY
//  129  */
//  130 #if defined MPU9150
//  131 #ifndef MPU6050
//  132 #define MPU6050
//  133 #endif                          /* #ifndef MPU6050 */
//  134 #if defined AK8963_SECONDARY
//  135 #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
//  136 #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
//  137 #define AK8975_SECONDARY
//  138 #endif                          /* #if defined AK8963_SECONDARY */
//  139 #elif defined MPU9250           /* #if defined MPU9150 */
//  140 #ifndef MPU6500
//  141 #define MPU6500
//  142 #endif                          /* #ifndef MPU6500 */
//  143 #if defined AK8975_SECONDARY
//  144 #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
//  145 #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
//  146 #define AK8963_SECONDARY
//  147 #endif                          /* #if defined AK8975_SECONDARY */
//  148 #endif                          /* #if defined MPU9150 */
//  149 
//  150 #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
//  151 #define AK89xx_SECONDARY
//  152 #else
//  153 /* #warning "No compass = less profit for Invensense. Lame." */
//  154 #endif
//  155 
//  156 static int set_int_enable(unsigned char enable);
//  157 
//  158 /* Hardware registers needed by driver. */
//  159 struct gyro_reg_s {
//  160     unsigned char who_am_i;
//  161     unsigned char rate_div;
//  162     unsigned char lpf;
//  163     unsigned char prod_id;
//  164     unsigned char user_ctrl;
//  165     unsigned char fifo_en;
//  166     unsigned char gyro_cfg;
//  167     unsigned char accel_cfg;
//  168 //    unsigned char accel_cfg2;
//  169 //    unsigned char lp_accel_odr;
//  170     unsigned char motion_thr;
//  171     unsigned char motion_dur;
//  172     unsigned char fifo_count_h;
//  173     unsigned char fifo_r_w;
//  174     unsigned char raw_gyro;
//  175     unsigned char raw_accel;
//  176     unsigned char temp;
//  177     unsigned char int_enable;
//  178     unsigned char dmp_int_status;
//  179     unsigned char int_status;
//  180 //    unsigned char accel_intel;
//  181     unsigned char pwr_mgmt_1;
//  182     unsigned char pwr_mgmt_2;
//  183     unsigned char int_pin_cfg;
//  184     unsigned char mem_r_w;
//  185     unsigned char accel_offs;
//  186     unsigned char i2c_mst;
//  187     unsigned char bank_sel;
//  188     unsigned char mem_start_addr;
//  189     unsigned char prgm_start_h;
//  190 #if defined AK89xx_SECONDARY
//  191     unsigned char s0_addr;
//  192     unsigned char s0_reg;
//  193     unsigned char s0_ctrl;
//  194     unsigned char s1_addr;
//  195     unsigned char s1_reg;
//  196     unsigned char s1_ctrl;
//  197     unsigned char s4_ctrl;
//  198     unsigned char s0_do;
//  199     unsigned char s1_do;
//  200     unsigned char i2c_delay_ctrl;
//  201     unsigned char raw_compass;
//  202     /* The I2C_MST_VDDIO bit is in this register. */
//  203     unsigned char yg_offs_tc;
//  204 #endif
//  205 };
//  206 
//  207 /* Information specific to a particular device. */
//  208 struct hw_s {
//  209     unsigned char addr;
//  210     unsigned short max_fifo;
//  211     unsigned char num_reg;
//  212     unsigned short temp_sens;
//  213     short temp_offset;
//  214     unsigned short bank_size;
//  215 #if defined AK89xx_SECONDARY
//  216     unsigned short compass_fsr;
//  217 #endif
//  218 };
//  219 
//  220 /* When entering motion interrupt mode, the driver keeps track of the
//  221  * previous state so that it can be restored at a later time.
//  222  * TODO: This is tacky. Fix it.
//  223  */
//  224 struct motion_int_cache_s {
//  225     unsigned short gyro_fsr;
//  226     unsigned char accel_fsr;
//  227     unsigned short lpf;
//  228     unsigned short sample_rate;
//  229     unsigned char sensors_on;
//  230     unsigned char fifo_sensors;
//  231     unsigned char dmp_on;
//  232 };
//  233 
//  234 /* Cached chip configuration data.
//  235  * TODO: A lot of these can be handled with a bitmask.
//  236  */
//  237 struct chip_cfg_s {
//  238     /* Matches gyro_cfg >> 3 & 0x03 */
//  239     unsigned char gyro_fsr;
//  240     /* Matches accel_cfg >> 3 & 0x03 */
//  241     unsigned char accel_fsr;
//  242     /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
//  243     unsigned char sensors;
//  244     /* Matches config register. */
//  245     unsigned char lpf;
//  246     unsigned char clk_src;
//  247     /* Sample rate, NOT rate divider. */
//  248     unsigned short sample_rate;
//  249     /* Matches fifo_en register. */
//  250     unsigned char fifo_enable;
//  251     /* Matches int enable register. */
//  252     unsigned char int_enable;
//  253     /* 1 if devices on auxiliary I2C bus appear on the primary. */
//  254     unsigned char bypass_mode;
//  255     /* 1 if half-sensitivity.
//  256      * NOTE: This doesn't belong here, but everything else in hw_s is const,
//  257      * and this allows us to save some precious RAM.
//  258      */
//  259     unsigned char accel_half;
//  260     /* 1 if device in low-power accel-only mode. */
//  261     unsigned char lp_accel_mode;
//  262     /* 1 if interrupts are only triggered on motion events. */
//  263     unsigned char int_motion_only;
//  264     struct motion_int_cache_s cache;
//  265     /* 1 for active low interrupts. */
//  266     unsigned char active_low_int;
//  267     /* 1 for latched interrupts. */
//  268     unsigned char latched_int;
//  269     /* 1 if DMP is enabled. */
//  270     unsigned char dmp_on;
//  271     /* Ensures that DMP will only be loaded once. */
//  272     unsigned char dmp_loaded;
//  273     /* Sampling rate used when DMP is enabled. */
//  274     unsigned short dmp_sample_rate;
//  275 #ifdef AK89xx_SECONDARY
//  276     /* Compass sample rate. */
//  277     unsigned short compass_sample_rate;
//  278     unsigned char compass_addr;
//  279     short mag_sens_adj[3];
//  280 #endif
//  281 };
//  282 
//  283 /* Information for self-test. */
//  284 struct test_s {
//  285     unsigned long gyro_sens;
//  286     unsigned long accel_sens;
//  287     unsigned char reg_rate_div;
//  288     unsigned char reg_lpf;
//  289     unsigned char reg_gyro_fsr;
//  290     unsigned char reg_accel_fsr;
//  291     unsigned short wait_ms;
//  292     unsigned char packet_thresh;
//  293     float min_dps;
//  294     float max_dps;
//  295     float max_gyro_var;
//  296     float min_g;
//  297     float max_g;
//  298     float max_accel_var;
//  299 };
//  300 
//  301 /* Gyro driver state variables. */
//  302 struct gyro_state_s {
//  303     const struct gyro_reg_s *reg;
//  304     const struct hw_s *hw;
//  305     struct chip_cfg_s chip_cfg;
//  306     const struct test_s *test;
//  307 };
//  308 
//  309 /* Filter configurations. */
//  310 enum lpf_e {
//  311     INV_FILTER_256HZ_NOLPF2 = 0,
//  312     INV_FILTER_188HZ,
//  313     INV_FILTER_98HZ,
//  314     INV_FILTER_42HZ,
//  315     INV_FILTER_20HZ,
//  316     INV_FILTER_10HZ,
//  317     INV_FILTER_5HZ,
//  318     INV_FILTER_2100HZ_NOLPF,
//  319     NUM_FILTER
//  320 };
//  321 
//  322 /* Full scale ranges. */
//  323 enum gyro_fsr_e {
//  324     INV_FSR_250DPS = 0,
//  325     INV_FSR_500DPS,
//  326     INV_FSR_1000DPS,
//  327     INV_FSR_2000DPS,
//  328     NUM_GYRO_FSR
//  329 };
//  330 
//  331 /* Full scale ranges. */
//  332 enum accel_fsr_e {
//  333     INV_FSR_2G = 0,
//  334     INV_FSR_4G,
//  335     INV_FSR_8G,
//  336     INV_FSR_16G,
//  337     NUM_ACCEL_FSR
//  338 };
//  339 
//  340 /* Clock sources. */
//  341 enum clock_sel_e {
//  342     INV_CLK_INTERNAL = 0,
//  343     INV_CLK_PLL,
//  344     NUM_CLK
//  345 };
//  346 
//  347 /* Low-power accel wakeup rates. */
//  348 enum lp_accel_rate_e {
//  349 #if defined MPU6050
//  350     INV_LPA_1_25HZ,
//  351     INV_LPA_5HZ,
//  352     INV_LPA_20HZ,
//  353     INV_LPA_40HZ
//  354 #elif defined MPU6500
//  355     INV_LPA_0_3125HZ,
//  356     INV_LPA_0_625HZ,
//  357     INV_LPA_1_25HZ,
//  358     INV_LPA_2_5HZ,
//  359     INV_LPA_5HZ,
//  360     INV_LPA_10HZ,
//  361     INV_LPA_20HZ,
//  362     INV_LPA_40HZ,
//  363     INV_LPA_80HZ,
//  364     INV_LPA_160HZ,
//  365     INV_LPA_320HZ,
//  366     INV_LPA_640HZ
//  367 #endif
//  368 };
//  369 
//  370 #define BIT_I2C_MST_VDDIO   (0x80)
//  371 #define BIT_FIFO_EN         (0x40)
//  372 #define BIT_DMP_EN          (0x80)
//  373 #define BIT_FIFO_RST        (0x04)
//  374 #define BIT_DMP_RST         (0x08)
//  375 #define BIT_FIFO_OVERFLOW   (0x10)
//  376 #define BIT_DATA_RDY_EN     (0x01)
//  377 #define BIT_DMP_INT_EN      (0x02)
//  378 #define BIT_MOT_INT_EN      (0x40)
//  379 #define BITS_FSR            (0x18)
//  380 #define BITS_LPF            (0x07)
//  381 #define BITS_HPF            (0x07)
//  382 #define BITS_CLK            (0x07)
//  383 #define BIT_FIFO_SIZE_1024  (0x40)
//  384 #define BIT_FIFO_SIZE_2048  (0x80)
//  385 #define BIT_FIFO_SIZE_4096  (0xC0)
//  386 #define BIT_RESET           (0x80)
//  387 #define BIT_SLEEP           (0x40)
//  388 #define BIT_S0_DELAY_EN     (0x01)
//  389 #define BIT_S2_DELAY_EN     (0x04)
//  390 #define BITS_SLAVE_LENGTH   (0x0F)
//  391 #define BIT_SLAVE_BYTE_SW   (0x40)
//  392 #define BIT_SLAVE_GROUP     (0x10)
//  393 #define BIT_SLAVE_EN        (0x80)
//  394 #define BIT_I2C_READ        (0x80)
//  395 #define BITS_I2C_MASTER_DLY (0x1F)
//  396 #define BIT_AUX_IF_EN       (0x20)
//  397 #define BIT_ACTL            (0x80)
//  398 #define BIT_LATCH_EN        (0x20)
//  399 #define BIT_ANY_RD_CLR      (0x10)
//  400 #define BIT_BYPASS_EN       (0x02)
//  401 #define BITS_WOM_EN         (0xC0)
//  402 #define BIT_LPA_CYCLE       (0x20)
//  403 #define BIT_STBY_XA         (0x20)
//  404 #define BIT_STBY_YA         (0x10)
//  405 #define BIT_STBY_ZA         (0x08)
//  406 #define BIT_STBY_XG         (0x04)
//  407 #define BIT_STBY_YG         (0x02)
//  408 #define BIT_STBY_ZG         (0x01)
//  409 #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
//  410 #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
//  411 
//  412 #if defined AK8975_SECONDARY
//  413 #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
//  414 #define AK89xx_FSR                  (9830)
//  415 #elif defined AK8963_SECONDARY
//  416 #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
//  417 #define AK89xx_FSR                  (4915)
//  418 #endif
//  419 
//  420 #ifdef AK89xx_SECONDARY
//  421 #define AKM_REG_WHOAMI      (0x00)
//  422 
//  423 #define AKM_REG_ST1         (0x02)
//  424 #define AKM_REG_HXL         (0x03)
//  425 #define AKM_REG_ST2         (0x09)
//  426 
//  427 #define AKM_REG_CNTL        (0x0A)
//  428 #define AKM_REG_ASTC        (0x0C)
//  429 #define AKM_REG_ASAX        (0x10)
//  430 #define AKM_REG_ASAY        (0x11)
//  431 #define AKM_REG_ASAZ        (0x12)
//  432 
//  433 #define AKM_DATA_READY      (0x01)
//  434 #define AKM_DATA_OVERRUN    (0x02)
//  435 #define AKM_OVERFLOW        (0x80)
//  436 #define AKM_DATA_ERROR      (0x40)
//  437 
//  438 #define AKM_BIT_SELF_TEST   (0x40)
//  439 
//  440 #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
//  441 #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
//  442 #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
//  443 #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
//  444 
//  445 #define AKM_WHOAMI      (0x48)
//  446 #endif
//  447 
//  448 #if defined MPU6050
//  449 //const struct gyro_reg_s reg = {
//  450 //    .who_am_i       = 0x75,
//  451 //    .rate_div       = 0x19,
//  452 //    .lpf            = 0x1A,
//  453 //    .prod_id        = 0x0C,
//  454 //    .user_ctrl      = 0x6A,
//  455 //    .fifo_en        = 0x23,
//  456 //    .gyro_cfg       = 0x1B,
//  457 //    .accel_cfg      = 0x1C,
//  458 //    .motion_thr     = 0x1F,
//  459 //    .motion_dur     = 0x20,
//  460 //    .fifo_count_h   = 0x72,
//  461 //    .fifo_r_w       = 0x74,
//  462 //    .raw_gyro       = 0x43,
//  463 //    .raw_accel      = 0x3B,
//  464 //    .temp           = 0x41,
//  465 //    .int_enable     = 0x38,
//  466 //    .dmp_int_status = 0x39,
//  467 //    .int_status     = 0x3A,
//  468 //    .pwr_mgmt_1     = 0x6B,
//  469 //    .pwr_mgmt_2     = 0x6C,
//  470 //    .int_pin_cfg    = 0x37,
//  471 //    .mem_r_w        = 0x6F,
//  472 //    .accel_offs     = 0x06,
//  473 //    .i2c_mst        = 0x24,
//  474 //    .bank_sel       = 0x6D,
//  475 //    .mem_start_addr = 0x6E,
//  476 //    .prgm_start_h   = 0x70
//  477 //#ifdef AK89xx_SECONDARY
//  478 //    ,.raw_compass   = 0x49,
//  479 //    .yg_offs_tc     = 0x01,
//  480 //    .s0_addr        = 0x25,
//  481 //    .s0_reg         = 0x26,
//  482 //    .s0_ctrl        = 0x27,
//  483 //    .s1_addr        = 0x28,
//  484 //    .s1_reg         = 0x29,
//  485 //    .s1_ctrl        = 0x2A,
//  486 //    .s4_ctrl        = 0x34,
//  487 //    .s0_do          = 0x63,
//  488 //    .s1_do          = 0x64,
//  489 //    .i2c_delay_ctrl = 0x67
//  490 //#endif
//  491 //};

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  492 const struct gyro_reg_s reg = {
reg:
        DB 117
        DB 25
        DB 26
        DB 12
        DB 106
        DB 35
        DB 27
        DB 28
        DB 31
        DB 32
        DB 114
        DB 116
        DB 67
        DB 59
        DB 65
        DB 56
        DB 57
        DB 58
        DB 107
        DB 108
        DB 55
        DB 111
        DB 6
        DB 36
        DB 109
        DB 110
        DB 112
//  493 0x75,  //who_am_i
//  494 0x19,  //rate_div
//  495 0x1A,  //lpf
//  496 0x0C,  //prod_id
//  497 0x6A,  //user_ctrl
//  498 0x23,  //fifo_en
//  499 0x1B,  //gyro_cfg
//  500 0x1C,  //accel_cfg
//  501 0x1F,  // motion_thr
//  502 0x20,  // motion_dur
//  503 0x72,  // fifo_count_h
//  504 0x74,  // fifo_r_w
//  505 0x43,  // raw_gyro
//  506 0x3B,  // raw_accel
//  507 0x41,  // temp
//  508 0x38,  // int_enable
//  509 0x39,  //  dmp_int_status
//  510 0x3A,  //  int_status
//  511 0x6B,  // pwr_mgmt_1
//  512 0x6C,  // pwr_mgmt_2
//  513 0x37,  // int_pin_cfg
//  514 0x6F,  // mem_r_w
//  515 0x06,  // accel_offs
//  516 0x24,  // i2c_mst
//  517 0x6D,  // bank_sel
//  518 0x6E,  // mem_start_addr
//  519 0x70   // prgm_start_h
//  520 };
//  521 
//  522 //const struct hw_s hw = {
//  523 //    .addr           = 0x68,
//  524 //    .max_fifo       = 1024,
//  525 //    .num_reg        = 118,
//  526 //    .temp_sens      = 340,
//  527 //    .temp_offset    = -521,
//  528 //    .bank_size      = 256
//  529 //#if defined AK89xx_SECONDARY
//  530 //    ,.compass_fsr    = AK89xx_FSR
//  531 //#endif
//  532 //};

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  533 const struct hw_s hw={
hw:
        DB 104
        DATA16
        DW 1024
        DATA8
        DB 118
        DATA16
        DW 340
        DW -521
        DW 256
//  534   0x68,	 //addr
//  535   1024,	 //max_fifo
//  536   118,	 //num_reg
//  537   340,	 //temp_sens
//  538   -521,	 //temp_offset
//  539   256	 //bank_size
//  540 };
//  541 
//  542 //const struct test_s test = {
//  543 //    .gyro_sens      = 32768/250,
//  544 //    .accel_sens     = 32768/16,
//  545 //    .reg_rate_div   = 0,    /* 1kHz. */
//  546 //    .reg_lpf        = 1,    /* 188Hz. */
//  547 //    .reg_gyro_fsr   = 0,    /* 250dps. */
//  548 //    .reg_accel_fsr  = 0x18, /* 16g. */
//  549 //    .wait_ms        = 50,
//  550 //    .packet_thresh  = 5,    /* 5% */
//  551 //    .min_dps        = 10.f,
//  552 //    .max_dps        = 105.f,
//  553 //    .max_gyro_var   = 0.14f,
//  554 //    .min_g          = 0.3f,
//  555 //    .max_g          = 0.95f,
//  556 //    .max_accel_var  = 0.14f
//  557 //};

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  558 const struct test_s test={
test:
        DATA32
        DD 131
        DD 2048
        DATA8
        DB 0
        DB 1
        DB 0
        DB 24
        DATA16
        DW 50
        DATA8
        DB 5
        DATA32
        DD 41200000H
        DD 42D20000H
        DD 3E0F5C29H
        DD 3E99999AH
        DD 3F733333H
        DD 3E0F5C29H
//  559 32768/250,		 //gyro_sens
//  560 32768/16,		 //	accel_sens
//  561 0,				 //	reg_rate_div
//  562 1,				//	reg_lpf
//  563 0,				 //	reg_gyro_fsr
//  564 0x18,			//	reg_accel_fsr
//  565 50,				//	wait_ms
//  566 5,				//	packet_thresh
//  567 10.0f,			 //	min_dps
//  568 105.0f,			 //	max_dps
//  569 0.14f,			//	max_gyro_var
//  570 0.3f,		   //	min_g
//  571 0.95f,		   //	max_g
//  572 0.14f		   //	max_accel_var
//  573 };
//  574 
//  575 //static struct gyro_state_s st = {
//  576 //    .reg = &reg,
//  577 //    .hw = &hw,
//  578 //    .test = &test
//  579 //};

        RSEG XDATA_I:XDATA:NOROOT(0)
//  580 static struct gyro_state_s st={
st:
        DATA8
        DS 35
        REQUIRE `?<Initializer for st>`
        REQUIRE __INIT_XDATA_I
//  581   &reg,
//  582   &hw,
//  583   {0},
//  584   &test
//  585 };
//  586 
//  587 
//  588 #elif defined MPU6500
//  589 const struct gyro_reg_s reg = {
//  590     .who_am_i       = 0x75,
//  591     .rate_div       = 0x19,
//  592     .lpf            = 0x1A,
//  593     .prod_id        = 0x0C,
//  594     .user_ctrl      = 0x6A,
//  595     .fifo_en        = 0x23,
//  596     .gyro_cfg       = 0x1B,
//  597     .accel_cfg      = 0x1C,
//  598     .accel_cfg2     = 0x1D,
//  599     .lp_accel_odr   = 0x1E,
//  600     .motion_thr     = 0x1F,
//  601     .motion_dur     = 0x20,
//  602     .fifo_count_h   = 0x72,
//  603     .fifo_r_w       = 0x74,
//  604     .raw_gyro       = 0x43,
//  605     .raw_accel      = 0x3B,
//  606     .temp           = 0x41,
//  607     .int_enable     = 0x38,
//  608     .dmp_int_status = 0x39,
//  609     .int_status     = 0x3A,
//  610     .accel_intel    = 0x69,
//  611     .pwr_mgmt_1     = 0x6B,
//  612     .pwr_mgmt_2     = 0x6C,
//  613     .int_pin_cfg    = 0x37,
//  614     .mem_r_w        = 0x6F,
//  615     .accel_offs     = 0x77,
//  616     .i2c_mst        = 0x24,
//  617     .bank_sel       = 0x6D,
//  618     .mem_start_addr = 0x6E,
//  619     .prgm_start_h   = 0x70
//  620 #ifdef AK89xx_SECONDARY
//  621     ,.raw_compass   = 0x49,
//  622     .s0_addr        = 0x25,
//  623     .s0_reg         = 0x26,
//  624     .s0_ctrl        = 0x27,
//  625     .s1_addr        = 0x28,
//  626     .s1_reg         = 0x29,
//  627     .s1_ctrl        = 0x2A,
//  628     .s4_ctrl        = 0x34,
//  629     .s0_do          = 0x63,
//  630     .s1_do          = 0x64,
//  631     .i2c_delay_ctrl = 0x67
//  632 #endif
//  633 };
//  634 const struct hw_s hw = {
//  635     .addr           = 0x68,
//  636     .max_fifo       = 1024,
//  637     .num_reg        = 128,
//  638     .temp_sens      = 321,
//  639     .temp_offset    = 0,
//  640     .bank_size      = 256
//  641 #if defined AK89xx_SECONDARY
//  642     ,.compass_fsr    = AK89xx_FSR
//  643 #endif
//  644 };
//  645 
//  646 const struct test_s test = {
//  647     .gyro_sens      = 32768/250,
//  648     .accel_sens     = 32768/16,
//  649     .reg_rate_div   = 0,    /* 1kHz. */
//  650     .reg_lpf        = 1,    /* 188Hz. */
//  651     .reg_gyro_fsr   = 0,    /* 250dps. */
//  652     .reg_accel_fsr  = 0x18, /* 16g. */
//  653     .wait_ms        = 50,
//  654     .packet_thresh  = 5,    /* 5% */
//  655     .min_dps        = 10.f,
//  656     .max_dps        = 105.f,
//  657     .max_gyro_var   = 0.14f,
//  658     .min_g          = 0.3f,
//  659     .max_g          = 0.95f,
//  660     .max_accel_var  = 0.14f
//  661 };
//  662 
//  663 static struct gyro_state_s st = {
//  664     .reg = &reg,
//  665     .hw = &hw,
//  666     .test = &test
//  667 };
//  668 #endif
//  669 
//  670 #define MAX_PACKET_LENGTH (12)
//  671 
//  672 #ifdef AK89xx_SECONDARY
//  673 static int setup_compass(void);
//  674 #define MAX_COMPASS_SAMPLE_RATE (100)
//  675 #endif
//  676 
//  677 /**
//  678  *  @brief      Enable/disable data ready interrupt.
//  679  *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
//  680  *  interrupt is used.
//  681  *  @param[in]  enable      1 to enable interrupt.
//  682  *  @return     0 if successful.
//  683  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  684 static int set_int_enable(unsigned char enable)
set_int_enable:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function set_int_enable
        CODE
//  685 {
        FUNCALL set_int_enable, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL set_int_enable, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
//  686     unsigned char tmp;
//  687 
//  688     if (st.chip_cfg.dmp_on) {
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??set_int_enable_0
//  689         if (enable)
        MOV     A,R6
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??set_int_enable_1
//  690             tmp = BIT_DMP_INT_EN;
        MOV     A,#0x2
        SJMP    ??set_int_enable_2
//  691         else
//  692             tmp = 0x00;
??set_int_enable_1:
        CLR     A
??set_int_enable_2:
        MOVX    @DPTR,A
//  693         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??set_int_enable_3
//  694             return -1;
??set_int_enable_4:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
??set_int_enable_5:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI CFA_XSP16 add(XSP16, 10)
//  695         st.chip_cfg.int_enable = tmp;
//  696     } else {
//  697         if (!st.chip_cfg.sensors)
??set_int_enable_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??set_int_enable_4
//  698             return -1;
//  699         if (enable && st.chip_cfg.int_enable)
        MOV     A,R6
        JZ      ??set_int_enable_6
        MOV     DPTR,#st + 12
        MOVX    A,@DPTR
        JZ      ??set_int_enable_6
//  700             return 0;
??set_int_enable_7:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??set_int_enable_5
//  701         if (enable)
??set_int_enable_6:
        MOV     A,R6
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??set_int_enable_8
//  702             tmp = BIT_DATA_RDY_EN;
        MOV     A,#0x1
        SJMP    ??set_int_enable_9
//  703         else
//  704             tmp = 0x00;
??set_int_enable_8:
        CLR     A
??set_int_enable_9:
        MOVX    @DPTR,A
//  705         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??set_int_enable_4
//  706             return -1;
//  707         st.chip_cfg.int_enable = tmp;
//  708     }
??set_int_enable_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     DPTR,#st + 12
        MOVX    @DPTR,A
        SJMP    ??set_int_enable_7
        CFI EndBlock cfiBlock0
//  709     return 0;
//  710 }
//  711 
//  712 /**
//  713  *  @brief      Register dump for testing.
//  714  *  @return     0 if successful.
//  715  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  716 int mpu_reg_dump(void)
mpu_reg_dump:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function mpu_reg_dump
        CODE
//  717 {
        FUNCALL mpu_reg_dump, printf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reg_dump, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
//  718     unsigned char ii;
//  719     unsigned char data;
//  720 
//  721     for (ii = 0; ii < st.hw->num_reg; ii++) {
        MOV     R6,#0x0
        SJMP    ??mpu_reg_dump_0
//  722         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
//  723             continue;
//  724         if (i2c_read(st.hw->addr, ii, 1, &data))
//  725             return -1;
//  726         log_i("%#5x: %#5x\r\n", ii, data);
??mpu_reg_dump_1:
        ; Setup parameters for call to function printf
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 13)
        MOV     ?V0 + 0,R6
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 15)
        MOV     R2,#`?<Constant "%#5x: %#5x\\r\\n">` & 0xff
        MOV     R3,#(`?<Constant "%#5x: %#5x\\r\\n">` >> 8) & 0xff
        LCALL   ??printf?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
??mpu_reg_dump_2:
        INC     R6
??mpu_reg_dump_0:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R6
        CLR     C
        SUBB    A,R2
        JNC     ??mpu_reg_dump_3
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        XRL     A,R6
        JZ      ??mpu_reg_dump_2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        XRL     A,R6
        JZ      ??mpu_reg_dump_2
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     A,R6
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      ??mpu_reg_dump_1
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_reg_dump_4
//  727     }
//  728     return 0;
??mpu_reg_dump_3:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_reg_dump_4:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1
//  729 }
//  730 
//  731 /**
//  732  *  @brief      Read from a single register.
//  733  *  NOTE: The memory and FIFO read/write registers cannot be accessed.
//  734  *  @param[in]  reg     Register address.
//  735  *  @param[out] data    Register data.
//  736  *  @return     0 if successful.
//  737  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  738 int mpu_read_reg(unsigned char reg, unsigned char *data)
mpu_read_reg:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function mpu_read_reg
        CODE
//  739 {
        FUNCALL mpu_read_reg, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
//  740     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        XRL     A,R6
        JZ      ??mpu_read_reg_0
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??mpu_read_reg_1
//  741         return -1;
??mpu_read_reg_0:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_read_reg_2
//  742     if (reg >= st.hw->num_reg)
??mpu_read_reg_1:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R6
        CLR     C
        SUBB    A,R2
        JNC     ??mpu_read_reg_0
//  743         return -1;
//  744     return i2c_read(st.hw->addr, reg, 1, data);
        ; Setup parameters for call to function MPU_Read_Len
        MOV     R3,#0x1
        MOV     A,R6
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     ?V0 + 0,R1
        MOV     R2,?V0 + 0
        MOV     R3,#0x0
??mpu_read_reg_2:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock2
//  745 }
//  746 
//  747 /**
//  748  *  @brief      Initialize hardware.
//  749  *  Initial configuration:\n
//  750  *  Gyro FSR: +/- 2000DPS\n
//  751  *  Accel FSR +/- 2G\n
//  752  *  DLPF: 42Hz\n
//  753  *  FIFO rate: 50Hz\n
//  754  *  Clock source: Gyro PLL\n
//  755  *  FIFO: Disabled.\n
//  756  *  Data ready interrupt: Disabled, active low, unlatched.
//  757  *  @param[in]  int_param   Platform-specific parameters to interrupt API.
//  758  *  @return     0 if successful.
//  759  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  760 int mpu_init(void)
mpu_init:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function mpu_init
        CODE
//  761 {
        FUNCALL mpu_init, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, printf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, printf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, printf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_bypass
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_sensors
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 6
        MOV     A,#-0x6
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
//  762     unsigned char data[6], rev;
//  763 
//  764     /* Reset device. */
//  765     data[0] = BIT_RESET;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x80
        MOVX    @DPTR,A
//  766     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??mpu_init_0
//  767         return -1;
??mpu_init_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_init_2 & 0xFFFF
//  768     delay_ms(100);
??mpu_init_0:
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_64
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
//  769 
//  770     /* Wake up chip. */
//  771     data[0] = 0x00;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
//  772     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_init_1
//  773         return -1;
//  774 
//  775 #if defined MPU6050
//  776     /* Check product revision. */
//  777     if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x16
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_init_1
//  778         return -1;
//  779     rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
//  780         (data[1] & 0x01);
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        RLC     A
        MOV     R0,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        RLC     A
        RLC     A
        ORL     A,R0
        ORL     A,R1
        MOV     ?V0 + 0,A
//  781 
//  782     if (rev) {
        JZ      ??mpu_init_3
//  783         /* Congrats, these parts are better. */
//  784         if (rev == 1)
        MOV     A,#0x1
        XRL     A,?V0 + 0
        JZ      ??mpu_init_4
//  785             st.chip_cfg.accel_half = 1;
//  786         else if (rev == 2)
        MOV     A,#0x2
        XRL     A,?V0 + 0
        JNZ     ??mpu_init_5
//  787             st.chip_cfg.accel_half = 0;
??mpu_init_6:
        MOV     DPTR,#st + 14
        CLR     A
        SJMP    ??mpu_init_7
//  788         else {
//  789             log_e("Unsupported software product rev %d.\n", rev);
??mpu_init_5:
        ; Setup parameters for call to function printf
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     R2,#`?<Constant "Unsupported software ...">` & 0xff
        MOV     R3,#(`?<Constant "Unsupported software ...">` >> 8) & 0xff
        LCALL   ??printf?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
//  790             return -1;
        LJMP    ??mpu_init_1 & 0xFFFF
//  791         }
//  792     } else {
//  793         if (i2c_read(st.hw->addr, st.reg->prod_id, 1, data))
??mpu_init_3:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  794             return -1;
//  795         rev = data[0] & 0x0F;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0xf
        MOV     ?V0 + 0,A
//  796         if (!rev) {
        JNZ     ??mpu_init_8
//  797             log_e("Product ID read as 0 indicates device is either "
//  798                 "incompatible or an MPU3050.\n");
        ; Setup parameters for call to function printf
        MOV     R2,#`?<Constant "Product ID read as 0 ...">` & 0xff
        MOV     R3,#(`?<Constant "Product ID read as 0 ...">` >> 8) & 0xff
        LCALL   ??printf?relay
//  799             return -1;
        LJMP    ??mpu_init_1 & 0xFFFF
//  800         } else if (rev == 4) {
??mpu_init_8:
        MOV     A,#0x4
        XRL     A,?V0 + 0
        JNZ     ??mpu_init_6
//  801             log_i("Half sensitivity part found.\n");
        ; Setup parameters for call to function printf
        MOV     R2,#`?<Constant "Half sensitivity part...">` & 0xff
        MOV     R3,#(`?<Constant "Half sensitivity part...">` >> 8) & 0xff
        LCALL   ??printf?relay
//  802             st.chip_cfg.accel_half = 1;
??mpu_init_4:
        MOV     DPTR,#st + 14
        MOV     A,#0x1
??mpu_init_7:
        MOVX    @DPTR,A
//  803         } else
//  804             st.chip_cfg.accel_half = 0;
//  805     }
//  806 #elif defined MPU6500
//  807 #define MPU6500_MEM_REV_ADDR    (0x17)
//  808     if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
//  809         return -1;
//  810     if (rev == 0x1)
//  811         st.chip_cfg.accel_half = 0;
//  812     else {
//  813         log_e("Unsupported software product rev %d.\n", rev);
//  814         return -1;
//  815     }
//  816 
//  817     /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
//  818      * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
//  819      */
//  820     data[0] = BIT_FIFO_SIZE_1024 | 0x8;
//  821     if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
//  822         return -1;
//  823 #endif
//  824 
//  825     /* Set to invalid values to ensure no I2C writes are skipped. */
//  826     st.chip_cfg.sensors = 0xFF;
        MOV     DPTR,#st + 6
        MOV     A,#-0x1
        MOVX    @DPTR,A
//  827     st.chip_cfg.gyro_fsr = 0xFF;
        MOV     DPTR,#st + 4
        MOVX    @DPTR,A
//  828     st.chip_cfg.accel_fsr = 0xFF;
        INC     DPTR
        MOVX    @DPTR,A
//  829     st.chip_cfg.lpf = 0xFF;
        MOV     DPTR,#st + 7
        MOVX    @DPTR,A
//  830     st.chip_cfg.sample_rate = 0xFFFF;
        MOV     DPTR,#st + 9
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  831     st.chip_cfg.fifo_enable = 0xFF;
        INC     DPTR
        MOVX    @DPTR,A
//  832     st.chip_cfg.bypass_mode = 0xFF;
        MOV     DPTR,#st + 13
        MOVX    @DPTR,A
//  833 #ifdef AK89xx_SECONDARY
//  834     st.chip_cfg.compass_sample_rate = 0xFFFF;
//  835 #endif
//  836     /* mpu_set_sensors always preserves this setting. */
//  837     st.chip_cfg.clk_src = INV_CLK_PLL;
        MOV     DPTR,#st + 8
        MOV     A,#0x1
        MOVX    @DPTR,A
//  838     /* Handled in next call to mpu_set_bypass. */
//  839     st.chip_cfg.active_low_int = 1;
        MOV     DPTR,#st + 27
        MOVX    @DPTR,A
//  840     st.chip_cfg.latched_int = 0;
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//  841     st.chip_cfg.int_motion_only = 0;
        MOV     DPTR,#st + 16
        MOVX    @DPTR,A
//  842     st.chip_cfg.lp_accel_mode = 0;
        MOV     DPTR,#st + 15
        MOVX    @DPTR,A
//  843     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
        ; Setup parameters for call to function memset
        MOV     ?V0 + 0,#0xa
        MOV     ?V0 + 1,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R2,#(st + 17) & 0xff
        MOV     R3,#((st + 17) >> 8) & 0xff
        LCALL   ??memset?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
//  844     st.chip_cfg.dmp_on = 0;
        MOV     DPTR,#st + 29
        CLR     A
        MOVX    @DPTR,A
//  845     st.chip_cfg.dmp_loaded = 0;
        INC     DPTR
        MOVX    @DPTR,A
//  846     st.chip_cfg.dmp_sample_rate = 0;
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  847 
//  848     if (mpu_set_gyro_fsr(2000))
        ; Setup parameters for call to function mpu_set_gyro_fsr
        MOV     R2,#-0x30
        MOV     R3,#0x7
        LCALL   ??mpu_set_gyro_fsr?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  849         return -1;
//  850     if (mpu_set_accel_fsr(2))
        ; Setup parameters for call to function mpu_set_accel_fsr
        MOV     R1,#0x2
        LCALL   ??mpu_set_accel_fsr?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  851         return -1;
//  852     if (mpu_set_lpf(42))
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0x2a
        MOV     R3,#0x0
        LCALL   ??mpu_set_lpf?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  853         return -1;
//  854     if (mpu_set_sample_rate(50))
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     R2,#0x32
        MOV     R3,#0x0
        LCALL   ??mpu_set_sample_rate?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  855         return -1;
//  856     if (mpu_configure_fifo(0))
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     R1,#0x0
        LCALL   ??mpu_configure_fifo?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  857         return -1;
//  858 
//  859 //    if (int_param)
//  860 //        reg_int_cb(int_param);
//  861 
//  862 #ifdef AK89xx_SECONDARY
//  863     setup_compass();
//  864     if (mpu_set_compass_sample_rate(10))
//  865         return -1;
//  866 #else
//  867     /* Already disabled by setup_compass. */
//  868     if (mpu_set_bypass(0))
        ; Setup parameters for call to function mpu_set_bypass
        MOV     R1,#0x0
        LCALL   ??mpu_set_bypass?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  869         return -1;
//  870 #endif
//  871 
//  872     mpu_set_sensors(0);
        ; Setup parameters for call to function mpu_set_sensors
        MOV     R1,#0x0
        LCALL   ??mpu_set_sensors?relay
//  873     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_init_2:
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock3
//  874 }
//  875 
//  876 /**
//  877  *  @brief      Enter low-power accel-only mode.
//  878  *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
//  879  *  the accelerometer at one of the following frequencies:
//  880  *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
//  881  *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
//  882  *  \n If the requested rate is not one listed above, the device will be set to
//  883  *  the next highest rate. Requesting a rate above the maximum supported
//  884  *  frequency will result in an error.
//  885  *  \n To select a fractional wake-up frequency, round down the value passed to
//  886  *  @e rate.
//  887  *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
//  888  *                          accel mode.
//  889  *  @return     0 if successful.
//  890  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  891 int mpu_lp_accel_mode(unsigned char rate)
mpu_lp_accel_mode:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function mpu_lp_accel_mode
        CODE
//  892 {
        FUNCALL mpu_lp_accel_mode, mpu_set_int_latched
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_int_latched
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
        MOV     A,R1
        MOV     R6,A
//  893     unsigned char tmp[2];
//  894 
//  895     if (rate > 40)
        CLR     C
        SUBB    A,#0x29
        JC      ??mpu_lp_accel_mode_0
//  896         return -1;
??mpu_lp_accel_mode_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
//  897 
//  898     if (!rate) {
??mpu_lp_accel_mode_0:
        MOV     A,R6
        JNZ     ??mpu_lp_accel_mode_3
//  899         mpu_set_int_latched(0);
        ; Setup parameters for call to function mpu_set_int_latched
        MOV     R1,#0x0
        LCALL   ??mpu_set_int_latched?relay
//  900         tmp[0] = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
//  901         tmp[1] = BIT_STBY_XYZG;
        INC     A
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x7
        MOVX    @DPTR,A
//  902         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_lp_accel_mode_1
//  903             return -1;
//  904         st.chip_cfg.lp_accel_mode = 0;
        MOV     DPTR,#st + 15
        CLR     A
        MOVX    @DPTR,A
//  905         return 0;
        MOV     R2,A
        MOV     R3,A
        LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
//  906     }
//  907     /* For LP accel, we automatically configure the hardware to produce latched
//  908      * interrupts. In LP accel mode, the hardware cycles into sleep mode before
//  909      * it gets a chance to deassert the interrupt pin; therefore, we shift this
//  910      * responsibility over to the MCU.
//  911      *
//  912      * Any register read will clear the interrupt.
//  913      */
//  914     mpu_set_int_latched(1);
??mpu_lp_accel_mode_3:
        ; Setup parameters for call to function mpu_set_int_latched
        MOV     R1,#0x1
        LCALL   ??mpu_set_int_latched?relay
//  915 #if defined MPU6050
//  916     tmp[0] = BIT_LPA_CYCLE;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x20
        MOVX    @DPTR,A
//  917     if (rate == 1) {
        MOV     A,#0x1
        XRL     A,R6
        JNZ     ??mpu_lp_accel_mode_4
//  918         tmp[1] = INV_LPA_1_25HZ;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
//  919         mpu_set_lpf(5);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0x5
        MOV     R3,A
        SJMP    ??mpu_lp_accel_mode_5
//  920     } else if (rate <= 5) {
??mpu_lp_accel_mode_4:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x6
        JNC     ??mpu_lp_accel_mode_6
//  921         tmp[1] = INV_LPA_5HZ;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
//  922         mpu_set_lpf(5);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0x5
        SJMP    ??mpu_lp_accel_mode_7
//  923     } else if (rate <= 20) {
??mpu_lp_accel_mode_6:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x15
        MOV     A,#0x1
        JNC     ??mpu_lp_accel_mode_8
//  924         tmp[1] = INV_LPA_20HZ;
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x2
        MOVX    @DPTR,A
//  925         mpu_set_lpf(10);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0xa
        SJMP    ??mpu_lp_accel_mode_7
//  926     } else {
//  927         tmp[1] = INV_LPA_40HZ;
??mpu_lp_accel_mode_8:
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x3
        MOVX    @DPTR,A
//  928         mpu_set_lpf(20);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0x14
??mpu_lp_accel_mode_7:
        MOV     R3,#0x0
??mpu_lp_accel_mode_5:
        LCALL   ??mpu_set_lpf?relay
//  929     }
//  930     tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        SWAP    A
        RLC     A
        RLC     A
        ANL     A,#0xc0
        ORL     A,#0x7
        MOVX    @DPTR,A
//  931     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_accel_mode_1 & 0xFFFF
//  932         return -1;
//  933 #elif defined MPU6500
//  934     /* Set wake frequency. */
//  935     if (rate == 1)
//  936         tmp[0] = INV_LPA_1_25HZ;
//  937     else if (rate == 2)
//  938         tmp[0] = INV_LPA_2_5HZ;
//  939     else if (rate <= 5)
//  940         tmp[0] = INV_LPA_5HZ;
//  941     else if (rate <= 10)
//  942         tmp[0] = INV_LPA_10HZ;
//  943     else if (rate <= 20)
//  944         tmp[0] = INV_LPA_20HZ;
//  945     else if (rate <= 40)
//  946         tmp[0] = INV_LPA_40HZ;
//  947     else if (rate <= 80)
//  948         tmp[0] = INV_LPA_80HZ;
//  949     else if (rate <= 160)
//  950         tmp[0] = INV_LPA_160HZ;
//  951     else if (rate <= 320)
//  952         tmp[0] = INV_LPA_320HZ;
//  953     else
//  954         tmp[0] = INV_LPA_640HZ;
//  955     if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
//  956         return -1;
//  957     tmp[0] = BIT_LPA_CYCLE;
//  958     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
//  959         return -1;
//  960 #endif
//  961     st.chip_cfg.sensors = INV_XYZ_ACCEL;
        MOV     DPTR,#st + 6
        MOV     A,#0x8
        MOVX    @DPTR,A
//  962     st.chip_cfg.clk_src = 0;
        MOV     DPTR,#st + 8
        CLR     A
        MOVX    @DPTR,A
//  963     st.chip_cfg.lp_accel_mode = 1;
        MOV     DPTR,#st + 15
        INC     A
        MOVX    @DPTR,A
//  964     mpu_configure_fifo(0);
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     R1,#0x0
        LCALL   ??mpu_configure_fifo?relay
//  965 
//  966     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_lp_accel_mode_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock4
//  967 }
//  968 
//  969 /**
//  970  *  @brief      Read raw gyro data directly from the registers.
//  971  *  @param[out] data        Raw data in hardware units.
//  972  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
//  973  *  @return     0 if successful.
//  974  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  975 int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
mpu_get_gyro_reg:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function mpu_get_gyro_reg
        CODE
//  976 {
        FUNCALL mpu_get_gyro_reg, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_get_gyro_reg, mget_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 6
        MOV     A,#-0x6
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
//  977     unsigned char tmp[6];
//  978 
//  979     if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        ANL     A,#0x70
        JNZ     ??mpu_get_gyro_reg_0
//  980         return -1;
??mpu_get_gyro_reg_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_get_gyro_reg_2 & 0xFFFF
//  981 
//  982     if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
??mpu_get_gyro_reg_0:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xc
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_get_gyro_reg_1
//  983         return -1;
//  984     data[0] = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  985     data[1] = (tmp[2] << 8) | tmp[3];
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  986     data[2] = (tmp[4] << 8) | tmp[5];
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  987     if (timestamp)
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??mpu_get_gyro_reg_3
//  988         get_ms(timestamp);
        ; Setup parameters for call to function mget_ms
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??mget_ms?relay
//  989     return 0;
??mpu_get_gyro_reg_3:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_gyro_reg_2:
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock5
//  990 }
//  991 
//  992 /**
//  993  *  @brief      Read raw accel data directly from the registers.
//  994  *  @param[out] data        Raw data in hardware units.
//  995  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
//  996  *  @return     0 if successful.
//  997  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  998 int mpu_get_accel_reg(short *data, unsigned long *timestamp)
mpu_get_accel_reg:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function mpu_get_accel_reg
        CODE
//  999 {
        FUNCALL mpu_get_accel_reg, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_get_accel_reg, mget_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 6
        MOV     A,#-0x6
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
// 1000     unsigned char tmp[6];
// 1001 
// 1002     if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JC      ??mpu_get_accel_reg_0
// 1003         return -1;
??mpu_get_accel_reg_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_get_accel_reg_2 & 0xFFFF
// 1004 
// 1005     if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
??mpu_get_accel_reg_0:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xd
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_get_accel_reg_1
// 1006         return -1;
// 1007     data[0] = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1008     data[1] = (tmp[2] << 8) | tmp[3];
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1009     data[2] = (tmp[4] << 8) | tmp[5];
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1010     if (timestamp)
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??mpu_get_accel_reg_3
// 1011         get_ms(timestamp);
        ; Setup parameters for call to function mget_ms
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??mget_ms?relay
// 1012     return 0;
??mpu_get_accel_reg_3:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_accel_reg_2:
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock6
// 1013 }
// 1014 
// 1015 /**
// 1016  *  @brief      Read temperature data directly from the registers.
// 1017  *  @param[out] data        Data in q16 format.
// 1018  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
// 1019  *  @return     0 if successful.
// 1020  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1021 int mpu_get_temperature(long *data, unsigned long *timestamp)
mpu_get_temperature:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function mpu_get_temperature
        CODE
// 1022 {
        FUNCALL mpu_get_temperature, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_get_temperature, mget_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
// 1023     unsigned char tmp[2];
// 1024     short raw;
// 1025 
// 1026     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_get_temperature_0
// 1027         return -1;
??mpu_get_temperature_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_get_temperature_2 & 0xFFFF
// 1028 
// 1029     if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
??mpu_get_temperature_0:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xe
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_get_temperature_1
// 1030         return -1;
// 1031     raw = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        MOV     A,R1
        MOV     ?V0 + 5,A
// 1032     if (timestamp)
        MOV     A,R6
        ORL     A,R7
        JZ      ??mpu_get_temperature_3
// 1033         get_ms(timestamp);
        ; Setup parameters for call to function mget_ms
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??mget_ms?relay
// 1034 
// 1035     data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
??mpu_get_temperature_3:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,?V0 + 5
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 4
        LCALL   ?L_TO_FLT
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 10,A
        MOV     ?V0 + 11,A
        MOV     R0,#?V0 + 8
        LCALL   ?L_TO_FLT
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_SUB
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        CLR     A
        MOV     ?V0 + 10,A
        MOV     ?V0 + 11,A
        MOV     R0,#?V0 + 8
        LCALL   ?UL_TO_FLT
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_DIV
        MOV     DPTR,#__Constant_420c0000
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_ADD
        MOV     DPTR,#__Constant_47800000
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 4
        LCALL   ?FLT_TO_L
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_TO_X
// 1036     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_temperature_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock7
// 1037 }
// 1038 
// 1039 /**
// 1040  *  @brief      Push biases to the accel bias registers.
// 1041  *  This function expects biases relative to the current sensor output, and
// 1042  *  these biases will be added to the factory-supplied values.
// 1043  *  @param[in]  accel_bias  New biases.
// 1044  *  @return     0 if successful.
// 1045  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1046 int mpu_set_accel_bias(const long *accel_bias)
mpu_set_accel_bias:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function mpu_set_accel_bias
        CODE
// 1047 {
        FUNCALL mpu_set_accel_bias, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_accel_bias, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_accel_bias, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 24
        MOV     A,#-0x18
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1048     unsigned char data[6];
// 1049     short accel_hw[3];
// 1050     short got_accel[3];
// 1051     short fg[3];
// 1052 
// 1053     if (!accel_bias)
        MOV     A,R6
        ORL     A,R7
        JNZ     ??mpu_set_accel_bias_0
// 1054         return -1;
??mpu_set_accel_bias_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
??mpu_set_accel_bias_2:
        MOV     A,#0x18
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI CFA_XSP16 add(XSP16, 40)
// 1055     if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
??mpu_set_accel_bias_0:
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        ORL     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??mpu_set_accel_bias_3
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        ORL     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??mpu_set_accel_bias_3
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        ORL     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??mpu_set_accel_bias_3
// 1056         return 0;
??mpu_set_accel_bias_4:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??mpu_set_accel_bias_2
// 1057 
// 1058     if (i2c_read(st.hw->addr, 3, 3, data))
??mpu_set_accel_bias_3:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x3
        MOV     R2,#0x3
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_set_accel_bias_1
// 1059         return -1;
// 1060     fg[0] = ((data[0] >> 4) + 8) & 0xf;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        ADD     A,#0x8
        ANL     A,#0xf
        MOV     R0,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
// 1061     fg[1] = ((data[1] >> 4) + 8) & 0xf;
        INC     A
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        ADD     A,#0x8
        ANL     A,#0xf
        MOV     R4,A
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
// 1062     fg[2] = ((data[2] >> 4) + 8) & 0xf;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        ADD     A,#0x8
        ANL     A,#0xf
        MOV     R2,A
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
// 1063 
// 1064     accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x1
        MOV     R0,#?V0 + 4
        LCALL   ?L_SHL
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x40
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?L_DIV_MOD
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 5
        MOVX    @DPTR,A
// 1065     accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     A,R4
        ADD     A,#0x40
        MOV     ?V0 + 4,A
        CLR     A
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?L_DIV_MOD
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 1066     accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     A,R2
        ADD     A,#0x40
        MOV     ?V0 + 4,A
        CLR     A
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?L_DIV_MOD
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 1067 
// 1068     if (i2c_read(st.hw->addr, 0x06, 6, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     R2,#0x6
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
// 1069         return -1;
// 1070 
// 1071     got_accel[0] = ((short)data[0] << 8) | data[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1072     got_accel[1] = ((short)data[2] << 8) | data[3];
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1073     got_accel[2] = ((short)data[4] << 8) | data[5];
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1074 
// 1075     accel_hw[0] += got_accel[0];
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R5
        MOVX    @DPTR,A
// 1076     accel_hw[1] += got_accel[1];
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOVX    @DPTR,A
// 1077     accel_hw[2] += got_accel[2];
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOVX    @DPTR,A
// 1078 
// 1079     data[0] = (accel_hw[0] >> 8) & 0xff;
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?SS_SHR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 1080     data[1] = (accel_hw[0]) & 0xff;
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1081     data[2] = (accel_hw[1] >> 8) & 0xff;
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?SS_SHR
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 1082     data[3] = (accel_hw[1]) & 0xff;
        MOV     A,R2
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1083     data[4] = (accel_hw[2] >> 8) & 0xff;
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?SS_SHR
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 1084     data[5] = (accel_hw[2]) & 0xff;
        MOV     A,R2
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1085 
// 1086     if (i2c_write(st.hw->addr, 0x06, 6, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     R2,#0x6
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
        LJMP    ??mpu_set_accel_bias_4 & 0xFFFF
        CFI EndBlock cfiBlock8
// 1087         return -1;
// 1088     return 0;
// 1089 }
// 1090 
// 1091 /**
// 1092  *  @brief  Reset FIFO read/write pointers.
// 1093  *  @return 0 if successful.
// 1094  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1095 int mpu_reset_fifo(void)
mpu_reset_fifo:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function mpu_reset_fifo
        CODE
// 1096 {
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, delay_ms
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, delay_ms
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 1)
// 1097     unsigned char data;
// 1098 
// 1099     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_reset_fifo_0
// 1100         return -1;
??mpu_reset_fifo_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_reset_fifo_2 & 0xFFFF
// 1101 
// 1102     data = 0;
??mpu_reset_fifo_0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 1103     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_reset_fifo_1
// 1104         return -1;
// 1105     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_reset_fifo_1
// 1106         return -1;
// 1107     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1108         return -1;
// 1109 
// 1110     if (st.chip_cfg.dmp_on) {
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JNZ     $+5
        LJMP    ??mpu_reset_fifo_3 & 0xFFFF
// 1111         data = BIT_FIFO_RST | BIT_DMP_RST;
        MOV     A,#0xc
        MOVX    @DPTR,A
// 1112         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1113             return -1;
// 1114         delay_ms(50);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_32
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1115         data = BIT_DMP_EN | BIT_FIFO_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x40
        MOVX    @DPTR,A
// 1116         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JNC     ??mpu_reset_fifo_4
// 1117             data |= BIT_AUX_IF_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x20
        MOVX    @DPTR,A
// 1118         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
??mpu_reset_fifo_4:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1119             return -1;
// 1120         if (st.chip_cfg.int_enable)
        MOV     DPTR,#st + 12
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_reset_fifo_5
// 1121             data = BIT_DMP_INT_EN;
        MOV     A,#0x2
        SJMP    ??mpu_reset_fifo_6
// 1122         else
// 1123             data = 0;
??mpu_reset_fifo_5:
        CLR     A
??mpu_reset_fifo_6:
        MOVX    @DPTR,A
// 1124         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1125             return -1;
// 1126         data = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 1127         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
        LJMP    ??mpu_reset_fifo_7 & 0xFFFF
// 1128             return -1;
// 1129     } else {
// 1130         data = BIT_FIFO_RST;
??mpu_reset_fifo_3:
        MOV     A,#0x4
        MOVX    @DPTR,A
// 1131         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1132             return -1;
// 1133         if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
        MOV     DPTR,#st + 13
        MOVX    A,@DPTR
        JNZ     ??mpu_reset_fifo_8
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JC      ??mpu_reset_fifo_9
// 1134             data = BIT_FIFO_EN;
??mpu_reset_fifo_8:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x40
        SJMP    ??mpu_reset_fifo_10
// 1135         else
// 1136             data = BIT_FIFO_EN | BIT_AUX_IF_EN;
??mpu_reset_fifo_9:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x60
??mpu_reset_fifo_10:
        MOVX    @DPTR,A
// 1137         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1138             return -1;
// 1139         delay_ms(50);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_32
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1140         if (st.chip_cfg.int_enable)
        MOV     DPTR,#st + 12
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_reset_fifo_11
// 1141             data = BIT_DATA_RDY_EN;
        MOV     A,#0x1
        SJMP    ??mpu_reset_fifo_12
// 1142         else
// 1143             data = 0;
??mpu_reset_fifo_11:
        CLR     A
??mpu_reset_fifo_12:
        MOVX    @DPTR,A
// 1144         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1145             return -1;
// 1146         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,#(st + 11) & 0xff
        MOV     R5,#((st + 11) >> 8) & 0xff
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1147             return -1;
// 1148     }
// 1149     return 0;
??mpu_reset_fifo_7:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_reset_fifo_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 XSP16+0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock9
// 1150 }
// 1151 
// 1152 /**
// 1153  *  @brief      Get the gyro full-scale range.
// 1154  *  @param[out] fsr Current full-scale range.
// 1155  *  @return     0 if successful.
// 1156  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1157 int mpu_get_gyro_fsr(unsigned short *fsr)
mpu_get_gyro_fsr:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function mpu_get_gyro_fsr
        CODE
// 1158 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1159     switch (st.chip_cfg.gyro_fsr) {
        MOV     DPTR,#st + 4
        MOVX    A,@DPTR
        JZ      ??mpu_get_gyro_fsr_0
        DEC     A
        JZ      ??mpu_get_gyro_fsr_1
        DEC     A
        JZ      ??mpu_get_gyro_fsr_2
        DEC     A
        JZ      ??mpu_get_gyro_fsr_3
        SJMP    ??mpu_get_gyro_fsr_4
// 1160     case INV_FSR_250DPS:
// 1161         fsr[0] = 250;
??mpu_get_gyro_fsr_0:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x6
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        SJMP    ??mpu_get_gyro_fsr_5
// 1162         break;
// 1163     case INV_FSR_500DPS:
// 1164         fsr[0] = 500;
??mpu_get_gyro_fsr_1:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0xc
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x1
        SJMP    ??mpu_get_gyro_fsr_5
// 1165         break;
// 1166     case INV_FSR_1000DPS:
// 1167         fsr[0] = 1000;
??mpu_get_gyro_fsr_2:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x18
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x3
        SJMP    ??mpu_get_gyro_fsr_5
// 1168         break;
// 1169     case INV_FSR_2000DPS:
// 1170         fsr[0] = 2000;
??mpu_get_gyro_fsr_3:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x30
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x7
        SJMP    ??mpu_get_gyro_fsr_5
// 1171         break;
// 1172     default:
// 1173         fsr[0] = 0;
??mpu_get_gyro_fsr_4:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
??mpu_get_gyro_fsr_5:
        MOVX    @DPTR,A
// 1174         break;
// 1175     }
// 1176     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock10
// 1177 }
// 1178 
// 1179 /**
// 1180  *  @brief      Set the gyro full-scale range.
// 1181  *  @param[in]  fsr Desired full-scale range.
// 1182  *  @return     0 if successful.
// 1183  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1184 int mpu_set_gyro_fsr(unsigned short fsr)
mpu_set_gyro_fsr:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function mpu_set_gyro_fsr
        CODE
// 1185 {
        FUNCALL mpu_set_gyro_fsr, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
// 1186     unsigned char data;
// 1187 
// 1188     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_set_gyro_fsr_0
// 1189         return -1;
??mpu_set_gyro_fsr_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_gyro_fsr_2 & 0xFFFF
// 1190 
// 1191     switch (fsr) {
??mpu_set_gyro_fsr_0:
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R0,#?V0 + 0
        LCALL   ?US_SWITCH_SPARSE
`?<Jumptable for mpu_set_gyro_fsr>_0`:
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        0
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        4
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        250
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_3
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        500
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_4
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        1000
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_5
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        2000
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_6
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_1
        CODE
// 1192     case 250:
// 1193         data = INV_FSR_250DPS << 3;
??mpu_set_gyro_fsr_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        SJMP    ??mpu_set_gyro_fsr_7
// 1194         break;
// 1195     case 500:
// 1196         data = INV_FSR_500DPS << 3;
??mpu_set_gyro_fsr_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x8
        SJMP    ??mpu_set_gyro_fsr_7
// 1197         break;
// 1198     case 1000:
// 1199         data = INV_FSR_1000DPS << 3;
??mpu_set_gyro_fsr_5:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x10
        SJMP    ??mpu_set_gyro_fsr_7
// 1200         break;
// 1201     case 2000:
// 1202         data = INV_FSR_2000DPS << 3;
??mpu_set_gyro_fsr_6:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x18
??mpu_set_gyro_fsr_7:
        MOVX    @DPTR,A
// 1203         break;
// 1204     default:
// 1205         return -1;
// 1206     }
// 1207 
// 1208     if (st.chip_cfg.gyro_fsr == (data >> 3))
        MOV     DPTR,#st + 4
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        XRL     A,R0
        JZ      ??mpu_set_gyro_fsr_8
// 1209         return 0;
// 1210     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_gyro_fsr_1 & 0xFFFF
// 1211         return -1;
// 1212     st.chip_cfg.gyro_fsr = data >> 3;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     DPTR,#st + 4
        MOVX    @DPTR,A
// 1213     return 0;
??mpu_set_gyro_fsr_8:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_gyro_fsr_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock11
// 1214 }
// 1215 
// 1216 /**
// 1217  *  @brief      Get the accel full-scale range.
// 1218  *  @param[out] fsr Current full-scale range.
// 1219  *  @return     0 if successful.
// 1220  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1221 int mpu_get_accel_fsr(unsigned char *fsr)
mpu_get_accel_fsr:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function mpu_get_accel_fsr
        CODE
// 1222 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1223     switch (st.chip_cfg.accel_fsr) {
        MOV     DPTR,#st + 5
        MOVX    A,@DPTR
        JZ      ??mpu_get_accel_fsr_0
        DEC     A
        JZ      ??mpu_get_accel_fsr_1
        DEC     A
        JZ      ??mpu_get_accel_fsr_2
        DEC     A
        JZ      ??mpu_get_accel_fsr_3
        SJMP    ??mpu_get_accel_fsr_4
// 1224     case INV_FSR_2G:
// 1225         fsr[0] = 2;
??mpu_get_accel_fsr_0:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x2
??mpu_get_accel_fsr_5:
        MOVX    @DPTR,A
// 1226         break;
// 1227     case INV_FSR_4G:
// 1228         fsr[0] = 4;
// 1229         break;
// 1230     case INV_FSR_8G:
// 1231         fsr[0] = 8;
// 1232         break;
// 1233     case INV_FSR_16G:
// 1234         fsr[0] = 16;
// 1235         break;
// 1236     default:
// 1237         return -1;
// 1238     }
// 1239     if (st.chip_cfg.accel_half)
        MOV     DPTR,#st + 14
        MOVX    A,@DPTR
        JZ      ??mpu_get_accel_fsr_6
// 1240         fsr[0] <<= 1;
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        CLR     C
        RLC     A
        MOVX    @DPTR,A
// 1241     return 0;
??mpu_get_accel_fsr_6:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_accel_fsr_7:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
??mpu_get_accel_fsr_1:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x4
        SJMP    ??mpu_get_accel_fsr_5
??mpu_get_accel_fsr_2:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x8
        SJMP    ??mpu_get_accel_fsr_5
??mpu_get_accel_fsr_3:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x10
        SJMP    ??mpu_get_accel_fsr_5
??mpu_get_accel_fsr_4:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_accel_fsr_7
        CFI EndBlock cfiBlock12
// 1242 }
// 1243 
// 1244 /**
// 1245  *  @brief      Set the accel full-scale range.
// 1246  *  @param[in]  fsr Desired full-scale range.
// 1247  *  @return     0 if successful.
// 1248  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1249 int mpu_set_accel_fsr(unsigned char fsr)
mpu_set_accel_fsr:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function mpu_set_accel_fsr
        CODE
// 1250 {
        FUNCALL mpu_set_accel_fsr, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
// 1251     unsigned char data;
// 1252 
// 1253     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_set_accel_fsr_0
// 1254         return -1;
??mpu_set_accel_fsr_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_accel_fsr_2 & 0xFFFF
// 1255 
// 1256     switch (fsr) {
??mpu_set_accel_fsr_0:
        MOV     A,R6
        ADD     A,#-0x2
        JZ      ??mpu_set_accel_fsr_3
        ADD     A,#-0x2
        JZ      ??mpu_set_accel_fsr_4
        ADD     A,#-0x4
        JZ      ??mpu_set_accel_fsr_5
        ADD     A,#-0x8
        JZ      ??mpu_set_accel_fsr_6
        SJMP    ??mpu_set_accel_fsr_1
// 1257     case 2:
// 1258         data = INV_FSR_2G << 3;
??mpu_set_accel_fsr_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        SJMP    ??mpu_set_accel_fsr_7
// 1259         break;
// 1260     case 4:
// 1261         data = INV_FSR_4G << 3;
??mpu_set_accel_fsr_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x8
        SJMP    ??mpu_set_accel_fsr_7
// 1262         break;
// 1263     case 8:
// 1264         data = INV_FSR_8G << 3;
??mpu_set_accel_fsr_5:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x10
        SJMP    ??mpu_set_accel_fsr_7
// 1265         break;
// 1266     case 16:
// 1267         data = INV_FSR_16G << 3;
??mpu_set_accel_fsr_6:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x18
??mpu_set_accel_fsr_7:
        MOVX    @DPTR,A
// 1268         break;
// 1269     default:
// 1270         return -1;
// 1271     }
// 1272 
// 1273     if (st.chip_cfg.accel_fsr == (data >> 3))
        MOV     DPTR,#st + 5
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        XRL     A,R0
        JZ      ??mpu_set_accel_fsr_8
// 1274         return 0;
// 1275     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_accel_fsr_1 & 0xFFFF
// 1276         return -1;
// 1277     st.chip_cfg.accel_fsr = data >> 3;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     DPTR,#st + 5
        MOVX    @DPTR,A
// 1278     return 0;
??mpu_set_accel_fsr_8:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_accel_fsr_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock13
// 1279 }
// 1280 
// 1281 /**
// 1282  *  @brief      Get the current DLPF setting.
// 1283  *  @param[out] lpf Current LPF setting.
// 1284  *  0 if successful.
// 1285  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1286 int mpu_get_lpf(unsigned short *lpf)
mpu_get_lpf:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function mpu_get_lpf
        CODE
// 1287 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1288     switch (st.chip_cfg.lpf) {
        MOV     DPTR,#st + 7
        MOVX    A,@DPTR
        DEC     A
        JZ      ??mpu_get_lpf_0
        DEC     A
        JZ      ??mpu_get_lpf_1
        DEC     A
        JZ      ??mpu_get_lpf_2
        DEC     A
        JZ      ??mpu_get_lpf_3
        DEC     A
        JZ      ??mpu_get_lpf_4
        DEC     A
        JZ      ??mpu_get_lpf_5
        SJMP    ??mpu_get_lpf_6
// 1289     case INV_FILTER_188HZ:
// 1290         lpf[0] = 188;
??mpu_get_lpf_0:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x44
??mpu_get_lpf_7:
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        SJMP    ??mpu_get_lpf_8
// 1291         break;
// 1292     case INV_FILTER_98HZ:
// 1293         lpf[0] = 98;
??mpu_get_lpf_1:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x62
        SJMP    ??mpu_get_lpf_7
// 1294         break;
// 1295     case INV_FILTER_42HZ:
// 1296         lpf[0] = 42;
??mpu_get_lpf_2:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x2a
        SJMP    ??mpu_get_lpf_7
// 1297         break;
// 1298     case INV_FILTER_20HZ:
// 1299         lpf[0] = 20;
??mpu_get_lpf_3:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x14
        SJMP    ??mpu_get_lpf_7
// 1300         break;
// 1301     case INV_FILTER_10HZ:
// 1302         lpf[0] = 10;
??mpu_get_lpf_4:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0xa
        SJMP    ??mpu_get_lpf_7
// 1303         break;
// 1304     case INV_FILTER_5HZ:
// 1305         lpf[0] = 5;
??mpu_get_lpf_5:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x5
        SJMP    ??mpu_get_lpf_7
// 1306         break;
// 1307     case INV_FILTER_256HZ_NOLPF2:
// 1308     case INV_FILTER_2100HZ_NOLPF:
// 1309     default:
// 1310         lpf[0] = 0;
??mpu_get_lpf_6:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
??mpu_get_lpf_8:
        MOVX    @DPTR,A
// 1311         break;
// 1312     }
// 1313     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock14
// 1314 }
// 1315 
// 1316 /**
// 1317  *  @brief      Set digital low pass filter.
// 1318  *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
// 1319  *  @param[in]  lpf Desired LPF setting.
// 1320  *  @return     0 if successful.
// 1321  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1322 int mpu_set_lpf(unsigned short lpf)
mpu_set_lpf:
        CFI Block cfiBlock15 Using cfiCommon0
        CFI Function mpu_set_lpf
        CODE
// 1323 {
        FUNCALL mpu_set_lpf, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 1)
// 1324     unsigned char data;
// 1325 
// 1326     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_set_lpf_0
// 1327         return -1;
??mpu_set_lpf_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_lpf_2 & 0xFFFF
// 1328 
// 1329     if (lpf >= 188)
??mpu_set_lpf_0:
        CLR     C
        MOV     A,R2
        SUBB    A,#-0x44
        MOV     A,R3
        SUBB    A,#0x0
        JC      ??mpu_set_lpf_3
// 1330         data = INV_FILTER_188HZ;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        SJMP    ??mpu_set_lpf_4
// 1331     else if (lpf >= 98)
??mpu_set_lpf_3:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x62
        MOV     A,R3
        SUBB    A,#0x0
        JC      ??mpu_set_lpf_5
// 1332         data = INV_FILTER_98HZ;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x2
        SJMP    ??mpu_set_lpf_4
// 1333     else if (lpf >= 42)
??mpu_set_lpf_5:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x2a
        MOV     A,R3
        SUBB    A,#0x0
        JC      ??mpu_set_lpf_6
// 1334         data = INV_FILTER_42HZ;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x3
        SJMP    ??mpu_set_lpf_4
// 1335     else if (lpf >= 20)
??mpu_set_lpf_6:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x14
        MOV     A,R3
        SUBB    A,#0x0
        JC      ??mpu_set_lpf_7
// 1336         data = INV_FILTER_20HZ;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x4
        SJMP    ??mpu_set_lpf_4
// 1337     else if (lpf >= 10)
??mpu_set_lpf_7:
        CLR     C
        MOV     A,R2
        SUBB    A,#0xa
        MOV     A,R3
        SUBB    A,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JC      ??mpu_set_lpf_8
// 1338         data = INV_FILTER_10HZ;
        MOV     A,#0x5
        SJMP    ??mpu_set_lpf_4
// 1339     else
// 1340         data = INV_FILTER_5HZ;
??mpu_set_lpf_8:
        MOV     A,#0x6
??mpu_set_lpf_4:
        MOVX    @DPTR,A
// 1341 
// 1342     if (st.chip_cfg.lpf == data)
        MOV     DPTR,#st + 7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,R0
        JZ      ??mpu_set_lpf_9
// 1343         return 0;
// 1344     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_lpf_1 & 0xFFFF
// 1345         return -1;
// 1346     st.chip_cfg.lpf = data;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     DPTR,#st + 7
        MOVX    @DPTR,A
// 1347     return 0;
??mpu_set_lpf_9:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_lpf_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 XSP16+0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock15
// 1348 }
// 1349 
// 1350 /**
// 1351  *  @brief      Get sampling rate.
// 1352  *  @param[out] rate    Current sampling rate (Hz).
// 1353  *  @return     0 if successful.
// 1354  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1355 int mpu_get_sample_rate(unsigned short *rate)
mpu_get_sample_rate:
        CFI Block cfiBlock16 Using cfiCommon0
        CFI Function mpu_get_sample_rate
        CODE
// 1356 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1357     if (st.chip_cfg.dmp_on)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_get_sample_rate_0
// 1358         return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_sample_rate_1
// 1359     else
// 1360         rate[0] = st.chip_cfg.sample_rate;
??mpu_get_sample_rate_0:
        MOV     DPTR,#st + 9
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1361     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_sample_rate_1:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock16
// 1362 }
// 1363 
// 1364 /**
// 1365  *  @brief      Set sampling rate.
// 1366  *  Sampling rate must be between 4Hz and 1kHz.
// 1367  *  @param[in]  rate    Desired sampling rate (Hz).
// 1368  *  @return     0 if successful.
// 1369  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1370 int mpu_set_sample_rate(unsigned short rate)
mpu_set_sample_rate:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function mpu_set_sample_rate
        CODE
// 1371 {
        FUNCALL mpu_set_sample_rate, mpu_lp_accel_mode
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sample_rate, mpu_lp_accel_mode
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sample_rate, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sample_rate, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1372     unsigned char data;
// 1373 
// 1374     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_set_sample_rate_0
// 1375         return -1;
??mpu_set_sample_rate_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_sample_rate_2 & 0xFFFF
// 1376 
// 1377     if (st.chip_cfg.dmp_on)
??mpu_set_sample_rate_0:
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JNZ     ??mpu_set_sample_rate_1
// 1378         return -1;
// 1379     else {
// 1380         if (st.chip_cfg.lp_accel_mode) {
        MOV     DPTR,#st + 15
        MOVX    A,@DPTR
        JZ      ??mpu_set_sample_rate_3
// 1381             if (rate && (rate <= 40)) {
        MOV     A,R6
        ORL     A,R7
        JZ      ??mpu_set_sample_rate_4
        CLR     C
        MOV     A,R6
        SUBB    A,#0x29
        MOV     A,R7
        SUBB    A,#0x0
        JNC     ??mpu_set_sample_rate_4
// 1382                 /* Just stay in low-power accel mode. */
// 1383                 mpu_lp_accel_mode(rate);
        ; Setup parameters for call to function mpu_lp_accel_mode
        MOV     A,R6
        MOV     R1,A
        LCALL   ??mpu_lp_accel_mode?relay
// 1384                 return 0;
        LJMP    ??mpu_set_sample_rate_5 & 0xFFFF
// 1385             }
// 1386             /* Requested rate exceeds the allowed frequencies in LP accel mode,
// 1387              * switch back to full-power mode.
// 1388              */
// 1389             mpu_lp_accel_mode(0);
??mpu_set_sample_rate_4:
        ; Setup parameters for call to function mpu_lp_accel_mode
        MOV     R1,#0x0
        LCALL   ??mpu_lp_accel_mode?relay
// 1390         }
// 1391         if (rate < 4)
??mpu_set_sample_rate_3:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x4
        MOV     A,R7
        SUBB    A,#0x0
        JNC     ??mpu_set_sample_rate_6
// 1392             rate = 4;
        MOV     R6,#0x4
        MOV     R7,#0x0
        SJMP    ??mpu_set_sample_rate_7
// 1393         else if (rate > 1000)
??mpu_set_sample_rate_6:
        CLR     C
        MOV     A,R6
        SUBB    A,#-0x17
        MOV     A,R7
        SUBB    A,#0x3
        JC      ??mpu_set_sample_rate_7
// 1394             rate = 1000;
        MOV     R6,#-0x18
        MOV     R7,#0x3
// 1395 
// 1396         data = 1000 / rate - 1;
??mpu_set_sample_rate_7:
        MOV     R0,#-0x18
        MOV     R1,#0x3
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        DEC     A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 1397         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_sample_rate_1 & 0xFFFF
// 1398             return -1;
// 1399 
// 1400         st.chip_cfg.sample_rate = 1000 / (1 + data);
        MOV     R0,#-0x18
        MOV     R1,#0x3
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        CLR     A
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ?S_DIV_MOD
        MOV     DPTR,#st + 9
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1401 
// 1402 #ifdef AK89xx_SECONDARY
// 1403         mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
// 1404 #endif
// 1405 
// 1406         /* Automatically set LPF to 1/2 sampling rate. */
// 1407         mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     DPTR,#st + 9
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        RRC     A
        MOV     R3,A
        MOV     A,R2
        RRC     A
        MOV     R2,A
        LCALL   ??mpu_set_lpf?relay
// 1408         return 0;
??mpu_set_sample_rate_5:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_sample_rate_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock17
// 1409     }
// 1410 }
// 1411 
// 1412 /**
// 1413  *  @brief      Get compass sampling rate.
// 1414  *  @param[out] rate    Current compass sampling rate (Hz).
// 1415  *  @return     0 if successful.
// 1416  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1417 int mpu_get_compass_sample_rate(unsigned short *rate)
mpu_get_compass_sample_rate:
        CFI Block cfiBlock18 Using cfiCommon0
        CFI Function mpu_get_compass_sample_rate
        CODE
// 1418 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1419 #ifdef AK89xx_SECONDARY
// 1420     rate[0] = st.chip_cfg.compass_sample_rate;
// 1421     return 0;
// 1422 #else
// 1423     rate[0] = 0;
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 1424     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock18
// 1425 #endif
// 1426 }
// 1427 
// 1428 /**
// 1429  *  @brief      Set compass sampling rate.
// 1430  *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
// 1431  *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
// 1432  *  sampling rate.
// 1433  *
// 1434  *  \n WARNING: The new rate may be different than what was requested. Call
// 1435  *  mpu_get_compass_sample_rate to check the actual setting.
// 1436  *  @param[in]  rate    Desired compass sampling rate (Hz).
// 1437  *  @return     0 if successful.
// 1438  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1439 int mpu_set_compass_sample_rate(unsigned short rate)
mpu_set_compass_sample_rate:
        CFI Block cfiBlock19 Using cfiCommon0
        CFI Function mpu_set_compass_sample_rate
        CODE
// 1440 {
        ; Saved register size: 0
        ; Auto size: 0
// 1441 #ifdef AK89xx_SECONDARY
// 1442     unsigned char div;
// 1443     if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
// 1444         return -1;
// 1445 
// 1446     div = st.chip_cfg.sample_rate / rate - 1;
// 1447     if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
// 1448         return -1;
// 1449     st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
// 1450     return 0;
// 1451 #else
// 1452     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ?BRET
        CFI EndBlock cfiBlock19
// 1453 #endif
// 1454 }
// 1455 
// 1456 /**
// 1457  *  @brief      Get gyro sensitivity scale factor.
// 1458  *  @param[out] sens    Conversion from hardware units to dps.
// 1459  *  @return     0 if successful.
// 1460  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1461 int mpu_get_gyro_sens(float *sens)
mpu_get_gyro_sens:
        CFI Block cfiBlock20 Using cfiCommon0
        CFI Function mpu_get_gyro_sens
        CODE
// 1462 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
// 1463     switch (st.chip_cfg.gyro_fsr) {
        MOV     DPTR,#st + 4
        MOVX    A,@DPTR
        JZ      ??mpu_get_gyro_sens_0
        DEC     A
        JZ      ??mpu_get_gyro_sens_1
        DEC     A
        JZ      ??mpu_get_gyro_sens_2
        DEC     A
        JZ      ??mpu_get_gyro_sens_3
        SJMP    ??mpu_get_gyro_sens_4
// 1464     case INV_FSR_250DPS:
// 1465         sens[0] = 131.f;
??mpu_get_gyro_sens_0:
        MOV     DPTR,#__Constant_43030000
??mpu_get_gyro_sens_5:
        LCALL   ?XLOAD_R2345
        MOV     DPL,R0
        MOV     DPH,R1
        LCALL   ?XSTORE_R2345
// 1466         break;
// 1467     case INV_FSR_500DPS:
// 1468         sens[0] = 65.5f;
// 1469         break;
// 1470     case INV_FSR_1000DPS:
// 1471         sens[0] = 32.8f;
// 1472         break;
// 1473     case INV_FSR_2000DPS:
// 1474         sens[0] = 16.4f;
// 1475         break;
// 1476     default:
// 1477         return -1;
// 1478     }
// 1479     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_gyro_sens_6:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
??mpu_get_gyro_sens_1:
        MOV     DPTR,#__Constant_42830000
        SJMP    ??mpu_get_gyro_sens_5
??mpu_get_gyro_sens_2:
        MOV     DPTR,#__Constant_42033333
        SJMP    ??mpu_get_gyro_sens_5
??mpu_get_gyro_sens_3:
        MOV     DPTR,#__Constant_41833333
        SJMP    ??mpu_get_gyro_sens_5
??mpu_get_gyro_sens_4:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_gyro_sens_6
        CFI EndBlock cfiBlock20
// 1480 }
// 1481 
// 1482 /**
// 1483  *  @brief      Get accel sensitivity scale factor.
// 1484  *  @param[out] sens    Conversion from hardware units to g's.
// 1485  *  @return     0 if successful.
// 1486  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1487 int mpu_get_accel_sens(unsigned short *sens)
mpu_get_accel_sens:
        CFI Block cfiBlock21 Using cfiCommon0
        CFI Function mpu_get_accel_sens
        CODE
// 1488 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1489     switch (st.chip_cfg.accel_fsr) {
        MOV     DPTR,#st + 5
        MOVX    A,@DPTR
        JZ      ??mpu_get_accel_sens_0
        DEC     A
        JZ      ??mpu_get_accel_sens_1
        DEC     A
        JZ      ??mpu_get_accel_sens_2
        DEC     A
        JZ      ??mpu_get_accel_sens_3
        SJMP    ??mpu_get_accel_sens_4
// 1490     case INV_FSR_2G:
// 1491         sens[0] = 16384;
??mpu_get_accel_sens_0:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x40
??mpu_get_accel_sens_5:
        MOVX    @DPTR,A
// 1492         break;
// 1493     case INV_FSR_4G:
// 1494         sens[0] = 8092;
// 1495         break;
// 1496     case INV_FSR_8G:
// 1497         sens[0] = 4096;
// 1498         break;
// 1499     case INV_FSR_16G:
// 1500         sens[0] = 2048;
// 1501         break;
// 1502     default:
// 1503         return -1;
// 1504     }
// 1505     if (st.chip_cfg.accel_half)
        MOV     DPTR,#st + 14
        MOVX    A,@DPTR
        JZ      ??mpu_get_accel_sens_6
// 1506         sens[0] >>= 1;
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        RRC     A
        MOV     R1,A
        MOV     A,R0
        RRC     A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1507     return 0;
??mpu_get_accel_sens_6:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_accel_sens_7:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
??mpu_get_accel_sens_1:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x64
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x1f
        SJMP    ??mpu_get_accel_sens_5
??mpu_get_accel_sens_2:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x10
        SJMP    ??mpu_get_accel_sens_5
??mpu_get_accel_sens_3:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x8
        SJMP    ??mpu_get_accel_sens_5
??mpu_get_accel_sens_4:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_accel_sens_7
        CFI EndBlock cfiBlock21
// 1508 }
// 1509 
// 1510 /**
// 1511  *  @brief      Get current FIFO configuration.
// 1512  *  @e sensors can contain a combination of the following flags:
// 1513  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
// 1514  *  \n INV_XYZ_GYRO
// 1515  *  \n INV_XYZ_ACCEL
// 1516  *  @param[out] sensors Mask of sensors in FIFO.
// 1517  *  @return     0 if successful.
// 1518  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1519 int mpu_get_fifo_config(unsigned char *sensors)
mpu_get_fifo_config:
        CFI Block cfiBlock22 Using cfiCommon0
        CFI Function mpu_get_fifo_config
        CODE
// 1520 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1521     sensors[0] = st.chip_cfg.fifo_enable;
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
// 1522     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock22
// 1523 }
// 1524 
// 1525 /**
// 1526  *  @brief      Select which sensors are pushed to FIFO.
// 1527  *  @e sensors can contain a combination of the following flags:
// 1528  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
// 1529  *  \n INV_XYZ_GYRO
// 1530  *  \n INV_XYZ_ACCEL
// 1531  *  @param[in]  sensors Mask of sensors to push to FIFO.
// 1532  *  @return     0 if successful.
// 1533  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1534 int mpu_configure_fifo(unsigned char sensors)
mpu_configure_fifo:
        CFI Block cfiBlock23 Using cfiCommon0
        CFI Function mpu_configure_fifo
        CODE
// 1535 {
        FUNCALL mpu_configure_fifo, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_configure_fifo, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_configure_fifo, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
// 1536     unsigned char prev;
// 1537     int result = 0;
// 1538 
// 1539     /* Compass data isn't going into the FIFO. Stop trying. */
// 1540     sensors &= ~INV_XYZ_COMPASS;
        MOV     A,R1
        CLR     0xE0 /* A   */.0
        MOV     ?V0 + 0,A
// 1541 
// 1542     if (st.chip_cfg.dmp_on)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_configure_fifo_0
// 1543         return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??mpu_configure_fifo_1
// 1544     else {
// 1545         if (!(st.chip_cfg.sensors))
??mpu_configure_fifo_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     R0,A
        JNZ     ??mpu_configure_fifo_2
// 1546             return -1;
??mpu_configure_fifo_3:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_configure_fifo_1
// 1547         prev = st.chip_cfg.fifo_enable;
??mpu_configure_fifo_2:
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 1548         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
        MOV     A,?V0 + 0
        ANL     A,R0
        MOV     R0,A
        MOVX    @DPTR,A
// 1549         if (st.chip_cfg.fifo_enable != sensors)
        MOV     A,?V0 + 0
        XRL     A,R0
        JZ      ??mpu_configure_fifo_4
// 1550             /* You're not getting what you asked for. Some sensors are
// 1551              * asleep.
// 1552              */
// 1553             result = -1;
        MOV     R6,#-0x1
        MOV     R7,#-0x1
        SJMP    ??mpu_configure_fifo_5
// 1554         else
// 1555             result = 0;
??mpu_configure_fifo_4:
        MOV     R6,#0x0
        MOV     R7,#0x0
// 1556         if (sensors || st.chip_cfg.lp_accel_mode)
??mpu_configure_fifo_5:
        MOV     A,?V0 + 0
        JNZ     ??mpu_configure_fifo_6
        MOV     DPTR,#st + 15
        MOVX    A,@DPTR
        JZ      ??mpu_configure_fifo_7
// 1557             set_int_enable(1);
??mpu_configure_fifo_6:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x1
        SJMP    ??mpu_configure_fifo_8
// 1558         else
// 1559             set_int_enable(0);
??mpu_configure_fifo_7:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x0
??mpu_configure_fifo_8:
        LCALL   ??set_int_enable?relay
// 1560         if (sensors) {
        MOV     A,?V0 + 0
        JZ      ??mpu_configure_fifo_9
// 1561             if (mpu_reset_fifo()) {
        ; Setup parameters for call to function mpu_reset_fifo
        LCALL   ??mpu_reset_fifo?relay
        MOV     ?V0 + 3,R3
        MOV     A,R2
        ORL     A,?V0 + 3
        JZ      ??mpu_configure_fifo_9
// 1562                 st.chip_cfg.fifo_enable = prev;
        MOV     A,?V0 + 1
        MOV     DPTR,#st + 11
        MOVX    @DPTR,A
// 1563                 return -1;
        SJMP    ??mpu_configure_fifo_3
// 1564             }
// 1565         }
// 1566     }
// 1567 
// 1568     return result;
??mpu_configure_fifo_9:
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
??mpu_configure_fifo_1:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock23
// 1569 }
// 1570 
// 1571 /**
// 1572  *  @brief      Get current power state.
// 1573  *  @param[in]  power_on    1 if turned on, 0 if suspended.
// 1574  *  @return     0 if successful.
// 1575  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1576 int mpu_get_power_state(unsigned char *power_on)
mpu_get_power_state:
        CFI Block cfiBlock24 Using cfiCommon0
        CFI Function mpu_get_power_state
        CODE
// 1577 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1578     if (st.chip_cfg.sensors)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     DPL,R2
        MOV     DPH,R3
        JZ      ??mpu_get_power_state_0
// 1579         power_on[0] = 1;
        MOV     A,#0x1
        SJMP    ??mpu_get_power_state_1
// 1580     else
// 1581         power_on[0] = 0;
??mpu_get_power_state_0:
        CLR     A
??mpu_get_power_state_1:
        MOVX    @DPTR,A
// 1582     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock24
// 1583 }
// 1584 
// 1585 /**
// 1586  *  @brief      Turn specific sensors on/off.
// 1587  *  @e sensors can contain a combination of the following flags:
// 1588  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
// 1589  *  \n INV_XYZ_GYRO
// 1590  *  \n INV_XYZ_ACCEL
// 1591  *  \n INV_XYZ_COMPASS
// 1592  *  @param[in]  sensors    Mask of sensors to wake.
// 1593  *  @return     0 if successful.
// 1594  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1595 int mpu_set_sensors(unsigned char sensors)
mpu_set_sensors:
        CFI Block cfiBlock25 Using cfiCommon0
        CFI Function mpu_set_sensors
        CODE
// 1596 {
        FUNCALL mpu_set_sensors, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sensors, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sensors, mpu_set_int_latched
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sensors, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
// 1597     unsigned char data;
// 1598 #ifdef AK89xx_SECONDARY
// 1599     unsigned char user_ctrl;
// 1600 #endif
// 1601 
// 1602     if (sensors & INV_XYZ_GYRO)
        MOV     A,#0x70
        ANL     A,R6
        JZ      ??mpu_set_sensors_0
// 1603         data = INV_CLK_PLL;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        SJMP    ??mpu_set_sensors_1
// 1604     else if (sensors)
??mpu_set_sensors_0:
        MOV     A,R6
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_set_sensors_2
// 1605         data = 0;
        CLR     A
        SJMP    ??mpu_set_sensors_1
// 1606     else
// 1607         data = BIT_SLEEP;
??mpu_set_sensors_2:
        MOV     A,#0x40
??mpu_set_sensors_1:
        MOVX    @DPTR,A
// 1608     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??mpu_set_sensors_3
// 1609         st.chip_cfg.sensors = 0;
??mpu_set_sensors_4:
        MOV     DPTR,#st + 6
        CLR     A
        MOVX    @DPTR,A
// 1610         return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_sensors_5 & 0xFFFF
// 1611     }
// 1612     st.chip_cfg.clk_src = data & ~BIT_SLEEP;
??mpu_set_sensors_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0xbf
        MOV     DPTR,#st + 8
        MOVX    @DPTR,A
// 1613 
// 1614     data = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 1615     if (!(sensors & INV_X_GYRO))
        MOV     A,R6
        MOV     C,0xE0 /* A   */.6
        JC      ??mpu_set_sensors_6
// 1616         data |= BIT_STBY_XG;
        MOV     A,#0x4
        MOVX    @DPTR,A
// 1617     if (!(sensors & INV_Y_GYRO))
??mpu_set_sensors_6:
        MOV     A,R6
        MOV     C,0xE0 /* A   */.5
        JC      ??mpu_set_sensors_7
// 1618         data |= BIT_STBY_YG;
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
// 1619     if (!(sensors & INV_Z_GYRO))
??mpu_set_sensors_7:
        MOV     A,R6
        MOV     C,0xE0 /* A   */.4
        JC      ??mpu_set_sensors_8
// 1620         data |= BIT_STBY_ZG;
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
// 1621     if (!(sensors & INV_XYZ_ACCEL))
??mpu_set_sensors_8:
        MOV     A,R6
        MOV     C,0xE0 /* A   */.3
        JC      ??mpu_set_sensors_9
// 1622         data |= BIT_STBY_XYZA;
        MOVX    A,@DPTR
        ORL     A,#0x38
        MOVX    @DPTR,A
// 1623     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
??mpu_set_sensors_9:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x13
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_set_sensors_4
// 1624         st.chip_cfg.sensors = 0;
// 1625         return -1;
// 1626     }
// 1627 
// 1628     if (sensors && (sensors != INV_XYZ_ACCEL))
        MOV     A,R6
        JZ      ??mpu_set_sensors_10
        MOV     A,#0x8
        XRL     A,R6
        JZ      ??mpu_set_sensors_10
// 1629         /* Latched interrupts only used in LP accel mode. */
// 1630         mpu_set_int_latched(0);
        ; Setup parameters for call to function mpu_set_int_latched
        MOV     R1,#0x0
        LCALL   ??mpu_set_int_latched?relay
// 1631 
// 1632 #ifdef AK89xx_SECONDARY
// 1633 #ifdef AK89xx_BYPASS
// 1634     if (sensors & INV_XYZ_COMPASS)
// 1635         mpu_set_bypass(1);
// 1636     else
// 1637         mpu_set_bypass(0);
// 1638 #else
// 1639     if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
// 1640         return -1;
// 1641     /* Handle AKM power management. */
// 1642     if (sensors & INV_XYZ_COMPASS) {
// 1643         data = AKM_SINGLE_MEASUREMENT;
// 1644         user_ctrl |= BIT_AUX_IF_EN;
// 1645     } else {
// 1646         data = AKM_POWER_DOWN;
// 1647         user_ctrl &= ~BIT_AUX_IF_EN;
// 1648     }
// 1649     if (st.chip_cfg.dmp_on)
// 1650         user_ctrl |= BIT_DMP_EN;
// 1651     else
// 1652         user_ctrl &= ~BIT_DMP_EN;
// 1653     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
// 1654         return -1;
// 1655     /* Enable/disable I2C master mode. */
// 1656     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
// 1657         return -1;
// 1658 #endif
// 1659 #endif
// 1660 
// 1661     st.chip_cfg.sensors = sensors;
??mpu_set_sensors_10:
        MOV     A,R6
        MOV     DPTR,#st + 6
        MOVX    @DPTR,A
// 1662     st.chip_cfg.lp_accel_mode = 0;
        MOV     DPTR,#st + 15
        CLR     A
        MOVX    @DPTR,A
// 1663     delay_ms(50);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_32
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1664     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_sensors_5:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock25
// 1665 }
// 1666 
// 1667 /**
// 1668  *  @brief      Read the MPU interrupt status registers.
// 1669  *  @param[out] status  Mask of interrupt bits.
// 1670  *  @return     0 if successful.
// 1671  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1672 int mpu_get_int_status(short *status)
mpu_get_int_status:
        CFI Block cfiBlock26 Using cfiCommon0
        CFI Function mpu_get_int_status
        CODE
// 1673 {
        FUNCALL mpu_get_int_status, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1674     unsigned char tmp[2];
// 1675     if (!st.chip_cfg.sensors)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_get_int_status_0
// 1676         return -1;
??mpu_get_int_status_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_int_status_2
// 1677     if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
??mpu_get_int_status_0:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x10
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_get_int_status_1
// 1678         return -1;
// 1679     status[0] = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1680     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_int_status_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock26
// 1681 }
// 1682 
// 1683 /**
// 1684  *  @brief      Get one packet from the FIFO.
// 1685  *  If @e sensors does not contain a particular sensor, disregard the data
// 1686  *  returned to that pointer.
// 1687  *  \n @e sensors can contain a combination of the following flags:
// 1688  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
// 1689  *  \n INV_XYZ_GYRO
// 1690  *  \n INV_XYZ_ACCEL
// 1691  *  \n If the FIFO has no new data, @e sensors will be zero.
// 1692  *  \n If the FIFO is disabled, @e sensors will be zero and this function will
// 1693  *  return a non-zero error code.
// 1694  *  @param[out] gyro        Gyro data in hardware units.
// 1695  *  @param[out] accel       Accel data in hardware units.
// 1696  *  @param[out] timestamp   Timestamp in milliseconds.
// 1697  *  @param[out] sensors     Mask of sensors read from FIFO.
// 1698  *  @param[out] more        Number of remaining packets.
// 1699  *  @return     0 if successful.
// 1700  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1701 int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
mpu_read_fifo:
        CFI Block cfiBlock27 Using cfiCommon0
        CFI Function mpu_read_fifo
        CODE
// 1702         unsigned char *sensors, unsigned char *more)
// 1703 {
        FUNCALL mpu_read_fifo, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo, mget_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 12
        MOV     A,#-0xc
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 8,R4
        MOV     ?V0 + 9,R5
        MOV     A,#0x24
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 12,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 13,A
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
// 1704     /* Assumes maximum packet size is gyro (6) + accel (6). */
// 1705     unsigned char data[MAX_PACKET_LENGTH];
// 1706     unsigned char packet_size = 0;
        MOV     ?V0 + 0,#0x0
// 1707     unsigned short fifo_count, index = 0;
        MOV     ?V0 + 2,#0x0
        MOV     ?V0 + 3,#0x0
// 1708 
// 1709     if (st.chip_cfg.dmp_on)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_read_fifo_0
// 1710         return -1;
??mpu_read_fifo_1:
        MOV     R2,#-0x1
??mpu_read_fifo_2:
        MOV     R3,#-0x1
??mpu_read_fifo_3:
        MOV     A,#0xc
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI CFA_XSP16 add(XSP16, 36)
// 1711 
// 1712     sensors[0] = 0;
??mpu_read_fifo_0:
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        CLR     A
        MOVX    @DPTR,A
// 1713     if (!st.chip_cfg.sensors)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??mpu_read_fifo_1
// 1714         return -1;
// 1715     if (!st.chip_cfg.fifo_enable)
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        JZ      ??mpu_read_fifo_1
// 1716         return -1;
// 1717 
// 1718     if (st.chip_cfg.fifo_enable & INV_X_GYRO)
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.6
        JNC     ??mpu_read_fifo_4
// 1719         packet_size += 2;
        MOV     ?V0 + 0,#0x2
// 1720     if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
??mpu_read_fifo_4:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.5
        JNC     ??mpu_read_fifo_5
// 1721         packet_size += 2;
        INC     ?V0 + 0
        INC     ?V0 + 0
// 1722     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
??mpu_read_fifo_5:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??mpu_read_fifo_6
// 1723         packet_size += 2;
        INC     ?V0 + 0
        INC     ?V0 + 0
// 1724     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
??mpu_read_fifo_6:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JNC     ??mpu_read_fifo_7
// 1725         packet_size += 6;
        MOV     A,#0x6
        ADD     A,?V0 + 0
        MOV     ?V0 + 0,A
// 1726 
// 1727     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
??mpu_read_fifo_7:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_read_fifo_1
// 1728         return -1;
// 1729     fifo_count = (data[0] << 8) | data[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
// 1730     if (fifo_count < packet_size)
        MOV     DPL,?V0 + 0
        MOV     ?V0 + 4,DPL
        CLR     C
        MOV     A,R6
        SUBB    A,?V0 + 4
        MOV     A,R7
        SUBB    A,#0x0
        JNC     ??mpu_read_fifo_8
// 1731         return 0;
??mpu_read_fifo_9:
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??mpu_read_fifo_3 & 0xFFFF
// 1732 //    log_i("FIFO count: %hd\n", fifo_count);
// 1733     if (fifo_count > (st.hw->max_fifo >> 1)) {
??mpu_read_fifo_8:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        RRC     A
        MOV     R3,A
        MOV     A,R2
        RRC     A
        CLR     C
        SUBB    A,R6
        MOV     A,R3
        SUBB    A,R7
        JNC     ??mpu_read_fifo_10
// 1734         /* FIFO is 50% full, better check overflow bit. */
// 1735         if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x11
        MOV     ?V0 + 14,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     DPL,?V0 + 14
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_fifo_1 & 0xFFFF
// 1736             return -1;
// 1737         if (data[0] & BIT_FIFO_OVERFLOW) {
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??mpu_read_fifo_10
// 1738             mpu_reset_fifo();
        ; Setup parameters for call to function mpu_reset_fifo
        LCALL   ??mpu_reset_fifo?relay
// 1739             return -2;
        MOV     R2,#-0x2
        LJMP    ??mpu_read_fifo_2 & 0xFFFF
// 1740         }
// 1741     }
// 1742     get_ms((unsigned long*)timestamp);
??mpu_read_fifo_10:
        ; Setup parameters for call to function mget_ms
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        LCALL   ??mget_ms?relay
// 1743 
// 1744     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,?V0 + 0
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_fifo_1 & 0xFFFF
// 1745         return -1;
// 1746     more[0] = fifo_count / packet_size - 1;
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     R2,?V0 + 4
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        DEC     A
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1747     sensors[0] = 0;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        CLR     A
        MOVX    @DPTR,A
// 1748 
// 1749     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
        MOV     A,?V0 + 0
        JZ      ??mpu_read_fifo_11
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JNC     ??mpu_read_fifo_11
// 1750         accel[0] = (data[index+0] << 8) | data[index+1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1751         accel[1] = (data[index+2] << 8) | data[index+3];
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1752         accel[2] = (data[index+4] << 8) | data[index+5];
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1753         sensors[0] |= INV_XYZ_ACCEL;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.3
        MOVX    @DPTR,A
// 1754         index += 6;
        MOV     ?V0 + 2,#0x6
// 1755     }
// 1756     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
??mpu_read_fifo_11:
        MOV     A,?V0 + 4
        XRL     A,?V0 + 2
        JNZ     ??mpu_read_fifo_12
        CLR     A
??mpu_read_fifo_12:
        JZ      ??mpu_read_fifo_13
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.6
        JNC     ??mpu_read_fifo_13
// 1757         gyro[0] = (data[index+0] << 8) | data[index+1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 2
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1758         sensors[0] |= INV_X_GYRO;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.6
        MOVX    @DPTR,A
// 1759         index += 2;
        MOV     A,?V0 + 2
        ADD     A,#0x2
        MOV     ?V0 + 2,A
        CLR     A
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 1760     }
// 1761     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
??mpu_read_fifo_13:
        MOV     A,?V0 + 4
        XRL     A,?V0 + 2
        JNZ     ??mpu_read_fifo_14
        MOV     A,?V0 + 3
??mpu_read_fifo_14:
        JZ      ??mpu_read_fifo_15
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.5
        JNC     ??mpu_read_fifo_15
// 1762         gyro[1] = (data[index+0] << 8) | data[index+1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 2
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1763         sensors[0] |= INV_Y_GYRO;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.5
        MOVX    @DPTR,A
// 1764         index += 2;
        MOV     A,?V0 + 2
        ADD     A,#0x2
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 1765     }
// 1766     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
??mpu_read_fifo_15:
        MOV     A,?V0 + 4
        XRL     A,?V0 + 2
        JNZ     ??mpu_read_fifo_16
        MOV     A,?V0 + 3
??mpu_read_fifo_16:
        JNZ     $+5
        LJMP    ??mpu_read_fifo_9 & 0xFFFF
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JC      $+5
        LJMP    ??mpu_read_fifo_9 & 0xFFFF
// 1767         gyro[2] = (data[index+0] << 8) | data[index+1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 2
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1768         sensors[0] |= INV_Z_GYRO;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.4
        MOVX    @DPTR,A
// 1769         index += 2;
        LJMP    ??mpu_read_fifo_9 & 0xFFFF
        CFI EndBlock cfiBlock27
// 1770     }
// 1771 
// 1772     return 0;
// 1773 }
// 1774 
// 1775 /**
// 1776  *  @brief      Get one unparsed packet from the FIFO.
// 1777  *  This function should be used if the packet is to be parsed elsewhere.
// 1778  *  @param[in]  length  Length of one FIFO packet.
// 1779  *  @param[in]  data    FIFO packet.
// 1780  *  @param[in]  more    Number of remaining packets.
// 1781  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1782 int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
mpu_read_fifo_stream:
        CFI Block cfiBlock28 Using cfiCommon0
        CFI Function mpu_read_fifo_stream
        CODE
// 1783     unsigned char *more)
// 1784 {
        FUNCALL mpu_read_fifo_stream, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo_stream, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo_stream, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo_stream, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
// 1785     unsigned char tmp[2];
// 1786     unsigned short fifo_count;
// 1787     if (!st.chip_cfg.dmp_on)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JNZ     ??mpu_read_fifo_stream_0
// 1788         return -1;
??mpu_read_fifo_stream_1:
        MOV     R2,#-0x1
??mpu_read_fifo_stream_2:
        MOV     R3,#-0x1
        LJMP    ??mpu_read_fifo_stream_3 & 0xFFFF
// 1789     if (!st.chip_cfg.sensors)
??mpu_read_fifo_stream_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??mpu_read_fifo_stream_1
// 1790         return -1;
// 1791 
// 1792     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_read_fifo_stream_1
// 1793         return -1;
// 1794     fifo_count = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     ?V0 + 0,A
        MOV     A,R1
        MOV     ?V0 + 1,A
// 1795     if (fifo_count < length) {
        CLR     C
        MOV     A,R2
        SUBB    A,R6
        MOV     A,R1
        SUBB    A,R7
        JNC     ??mpu_read_fifo_stream_4
// 1796         more[0] = 0;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        CLR     A
        MOVX    @DPTR,A
// 1797         return -1;
        SJMP    ??mpu_read_fifo_stream_1
// 1798     }
// 1799     if (fifo_count > (st.hw->max_fifo >> 1)) {
??mpu_read_fifo_stream_4:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        RRC     A
        MOV     R3,A
        MOV     A,R2
        RRC     A
        CLR     C
        SUBB    A,?V0 + 0
        MOV     A,R3
        SUBB    A,?V0 + 1
        JNC     ??mpu_read_fifo_stream_5
// 1800         /* FIFO is 50% full, better check overflow bit. */
// 1801         if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x11
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     DPL,?V0 + 6
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_fifo_stream_1 & 0xFFFF
// 1802             return -1;
// 1803         if (tmp[0] & BIT_FIFO_OVERFLOW) {
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??mpu_read_fifo_stream_5
// 1804             mpu_reset_fifo();
        ; Setup parameters for call to function mpu_reset_fifo
        LCALL   ??mpu_reset_fifo?relay
// 1805             return -2;
        MOV     R2,#-0x2
        LJMP    ??mpu_read_fifo_stream_2 & 0xFFFF
// 1806         }
// 1807     }
// 1808 
// 1809     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
??mpu_read_fifo_stream_5:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     A,R6
        MOV     R3,A
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_fifo_stream_1 & 0xFFFF
// 1810         return -1;
// 1811     more[0] = fifo_count / length - 1;
        MOV     R0,?V0 + 0
        MOV     R1,?V0 + 1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        DEC     A
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    @DPTR,A
// 1812     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_read_fifo_stream_3:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock28
// 1813 }
// 1814 
// 1815 /**
// 1816  *  @brief      Set device to bypass mode.
// 1817  *  @param[in]  bypass_on   1 to enable bypass mode.
// 1818  *  @return     0 if successful.
// 1819  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1820 int mpu_set_bypass(unsigned char bypass_on)
mpu_set_bypass:
        CFI Block cfiBlock29 Using cfiCommon0
        CFI Function mpu_set_bypass
        CODE
// 1821 {
        FUNCALL mpu_set_bypass, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     ?V0 + 0,R1
// 1822     unsigned char tmp;
// 1823 
// 1824     if (st.chip_cfg.bypass_mode == bypass_on)
        MOV     DPTR,#st + 13
        MOVX    A,@DPTR
        XRL     A,?V0 + 0
        JNZ     $+5
        LJMP    ??mpu_set_bypass_0 & 0xFFFF
// 1825         return 0;
// 1826 
// 1827     if (bypass_on) {
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     A,?V0 + 0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPL,R6
        MOV     DPH,R7
        JNZ     $+5
        LJMP    ??mpu_set_bypass_1 & 0xFFFF
// 1828         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      ??mpu_set_bypass_2
// 1829             return -1;
??mpu_set_bypass_3:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_bypass_4 & 0xFFFF
// 1830         tmp &= ~BIT_AUX_IF_EN;
??mpu_set_bypass_2:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.5
        MOVX    @DPTR,A
// 1831         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_set_bypass_3
// 1832             return -1;
// 1833         delay_ms(3);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_3
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1834         tmp = BIT_BYPASS_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x2
        MOVX    @DPTR,A
// 1835         if (st.chip_cfg.active_low_int)
        MOV     DPTR,#st + 27
        MOVX    A,@DPTR
        JZ      ??mpu_set_bypass_5
// 1836             tmp |= BIT_ACTL;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x7e
        MOVX    @DPTR,A
// 1837         if (st.chip_cfg.latched_int)
??mpu_set_bypass_5:
        MOV     DPTR,#st + 28
        MOVX    A,@DPTR
        JZ      ??mpu_set_bypass_6
// 1838             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ORL     A,#0x30
        MOVX    @DPTR,A
// 1839         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
??mpu_set_bypass_6:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x14
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_bypass_3 & 0xFFFF
        LJMP    ??mpu_set_bypass_7 & 0xFFFF
// 1840             return -1;
// 1841     } else {
// 1842         /* Enable I2C master mode if compass is being used. */
// 1843         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
??mpu_set_bypass_1:
        ; Setup parameters for call to function MPU_Read_Len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_bypass_3 & 0xFFFF
// 1844             return -1;
// 1845         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JNC     ??mpu_set_bypass_8
// 1846             tmp |= BIT_AUX_IF_EN;
        SETB    0xE0 /* A   */.5
        SJMP    ??mpu_set_bypass_9
// 1847         else
// 1848             tmp &= ~BIT_AUX_IF_EN;
??mpu_set_bypass_8:
        CLR     0xE0 /* A   */.5
??mpu_set_bypass_9:
        MOVX    @DPTR,A
// 1849         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_bypass_3 & 0xFFFF
// 1850             return -1;
// 1851         delay_ms(3);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_3
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1852         if (st.chip_cfg.active_low_int)
        MOV     DPTR,#st + 27
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_set_bypass_10
// 1853             tmp = BIT_ACTL;
        MOV     A,#-0x80
        SJMP    ??mpu_set_bypass_11
// 1854         else
// 1855             tmp = 0;
??mpu_set_bypass_10:
        CLR     A
??mpu_set_bypass_11:
        MOVX    @DPTR,A
// 1856         if (st.chip_cfg.latched_int)
        MOV     DPTR,#st + 28
        MOVX    A,@DPTR
        JZ      ??mpu_set_bypass_12
// 1857             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ORL     A,#0x30
        MOVX    @DPTR,A
// 1858         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
??mpu_set_bypass_12:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x14
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_bypass_3 & 0xFFFF
// 1859             return -1;
// 1860     }
// 1861     st.chip_cfg.bypass_mode = bypass_on;
??mpu_set_bypass_7:
        MOV     A,?V0 + 0
        MOV     DPTR,#st + 13
        MOVX    @DPTR,A
// 1862     return 0;
??mpu_set_bypass_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_bypass_4:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock29
// 1863 }
// 1864 
// 1865 /**
// 1866  *  @brief      Set interrupt level.
// 1867  *  @param[in]  active_low  1 for active low, 0 for active high.
// 1868  *  @return     0 if successful.
// 1869  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1870 int mpu_set_int_level(unsigned char active_low)
mpu_set_int_level:
        CFI Block cfiBlock30 Using cfiCommon0
        CFI Function mpu_set_int_level
        CODE
// 1871 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1872     st.chip_cfg.active_low_int = active_low;
        MOV     A,R1
        MOV     DPTR,#st + 27
        MOVX    @DPTR,A
// 1873     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock30
// 1874 }
// 1875 
// 1876 /**
// 1877  *  @brief      Enable latched interrupts.
// 1878  *  Any MPU register will clear the interrupt.
// 1879  *  @param[in]  enable  1 to enable, 0 to disable.
// 1880  *  @return     0 if successful.
// 1881  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1882 int mpu_set_int_latched(unsigned char enable)
mpu_set_int_latched:
        CFI Block cfiBlock31 Using cfiCommon0
        CFI Function mpu_set_int_latched
        CODE
// 1883 {
        FUNCALL mpu_set_int_latched, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
// 1884     unsigned char tmp;
// 1885     if (st.chip_cfg.latched_int == enable)
        MOV     DPTR,#st + 28
        MOVX    A,@DPTR
        XRL     A,R6
        JZ      ??mpu_set_int_latched_0
// 1886         return 0;
// 1887 
// 1888     if (enable)
        MOV     A,R6
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_set_int_latched_1
// 1889         tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
        MOV     A,#0x30
        SJMP    ??mpu_set_int_latched_2
// 1890     else
// 1891         tmp = 0;
??mpu_set_int_latched_1:
        CLR     A
??mpu_set_int_latched_2:
        MOVX    @DPTR,A
// 1892     if (st.chip_cfg.bypass_mode)
        MOV     DPTR,#st + 13
        MOVX    A,@DPTR
        JZ      ??mpu_set_int_latched_3
// 1893         tmp |= BIT_BYPASS_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
// 1894     if (st.chip_cfg.active_low_int)
??mpu_set_int_latched_3:
        MOV     DPTR,#st + 27
        MOVX    A,@DPTR
        JZ      ??mpu_set_int_latched_4
// 1895         tmp |= BIT_ACTL;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.7
        MOVX    @DPTR,A
// 1896     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
??mpu_set_int_latched_4:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x14
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??mpu_set_int_latched_5
// 1897         return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_set_int_latched_6
// 1898     st.chip_cfg.latched_int = enable;
??mpu_set_int_latched_5:
        MOV     A,R6
        MOV     DPTR,#st + 28
        MOVX    @DPTR,A
// 1899     return 0;
??mpu_set_int_latched_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_int_latched_6:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock31
// 1900 }
// 1901 
// 1902 #ifdef MPU6050

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1903 static int get_accel_prod_shift(float *st_shift)
get_accel_prod_shift:
        CFI Block cfiBlock32 Using cfiCommon0
        CFI Function get_accel_prod_shift
        CODE
// 1904 {
        FUNCALL get_accel_prod_shift, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x16
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 22)
        ; Saved register size: 22
        ; Auto size: 7
        MOV     A,#-0x7
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 29)
        MOV     ?V0 + 12,R2
        MOV     ?V0 + 13,R3
// 1905     unsigned char tmp[4], shift_code[3], ii;
// 1906 
// 1907     if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x4
        MOV     R2,#0xd
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      ??get_accel_prod_shift_0
// 1908         return 0x07;
        MOV     R2,#0x7
        LJMP    ??get_accel_prod_shift_1 & 0xFFFF
// 1909 
// 1910     shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
??get_accel_prod_shift_0:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        SWAP    A
        ANL     A,#0xf
        ANL     A,#0x3
        MOV     R0,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        ANL     A,#0x1c
        ORL     A,R0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 1911     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
        MOV     A,R1
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0x3
        MOV     R0,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        ANL     A,#0x1c
        ORL     A,R0
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1912     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
        MOV     A,#0x3
        ANL     A,R1
        MOV     R0,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        ANL     A,#0x1c
        ORL     A,R0
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1913     for (ii = 0; ii < 3; ii++) {
        MOV     R6,#0x0
        SJMP    ??get_accel_prod_shift_2
// 1914         if (!shift_code[ii]) {
// 1915             st_shift[ii] = 0.f;
// 1916             continue;
// 1917         }
// 1918         /* Equivalent to..
// 1919          * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
// 1920          */
// 1921         st_shift[ii] = 0.34f;
// 1922         while (--shift_code[ii])
// 1923             st_shift[ii] *= 1.034f;
??get_accel_prod_shift_3:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_3f845a1d
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
??get_accel_prod_shift_4:
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        DEC     A
        MOVX    @DPTR,A
        MOVX    A,@DPTR
        JNZ     ??get_accel_prod_shift_3
??get_accel_prod_shift_5:
        INC     R6
??get_accel_prod_shift_2:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x3
        JNC     ??get_accel_prod_shift_6
        MOV     DPL,R6
        MOV     R2,DPL
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,?V0 + 12
        ADD     A,?V0 + 0
        MOV     ?V0 + 4,A
        MOV     A,?V0 + 13
        ADDC    A,?V0 + 1
        MOV     ?V0 + 5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,R2
        MOV     ?V0 + 6,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     ?V0 + 7,A
        MOV     DPL,?V0 + 6
        MOV     DPH,A
        MOVX    A,@DPTR
        JNZ     ??get_accel_prod_shift_7
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        LCALL   ?XSTORE_R2345
        SJMP    ??get_accel_prod_shift_5
??get_accel_prod_shift_7:
        MOV     DPTR,#__Constant_3eae147b
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        LCALL   ?XSTORE_R2345
        SJMP    ??get_accel_prod_shift_4
// 1924     }
// 1925     return 0;
??get_accel_prod_shift_6:
        MOV     R2,#0x0
??get_accel_prod_shift_1:
        MOV     R3,#0x0
        MOV     A,#0x7
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R7,#0xe
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock32
// 1926 }
// 1927 

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1928 static int accel_self_test(long *bias_regular, long *bias_st)
accel_self_test:
        CFI Block cfiBlock33 Using cfiCommon0
        CFI Function accel_self_test
        CODE
// 1929 {
        FUNCALL accel_self_test, get_accel_prod_shift
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL accel_self_test, labs
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
// 1930     int jj, result = 0;
        MOV     ?V0 + 12,#0x0
        MOV     ?V0 + 13,#0x0
// 1931     float st_shift[3], st_shift_cust, st_shift_var;
// 1932 
// 1933     get_accel_prod_shift(st_shift);
        ; Setup parameters for call to function get_accel_prod_shift
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??get_accel_prod_shift?relay
// 1934     for(jj = 0; jj < 3; jj++) {
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??accel_self_test_0
// 1935         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
// 1936         if (st_shift[jj]) {
// 1937             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
// 1938             if (fabs(st_shift_var) > test.max_accel_var)
// 1939                 result |= 1 << jj;
// 1940         } else if ((st_shift_cust < test.min_g) ||
// 1941             (st_shift_cust > test.max_g))
??accel_self_test_1:
        MOV     DPTR,#__Constant_3e99999a
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_LT
        JNC     $+5
        LJMP    ??accel_self_test_2 & 0xFFFF
        MOV     DPTR,#__Constant_3f733334
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_GE
        JNC     $+5
        LJMP    ??accel_self_test_2 & 0xFFFF
??accel_self_test_3:
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
??accel_self_test_0:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x3
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      $+5
        LJMP    ??accel_self_test_4 & 0xFFFF
        MOV     ?V0 + 2,R6
        MOV     ?V0 + 3,R7
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     ?V0 + 0,?V0 + 2
        MOV     ?V0 + 1,?V0 + 3
        ; Setup parameters for call to function labs
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOV     DPL,R0
        MOV     DPH,A
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 14
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,?V0 + 15
        ADDC    A,?V0 + 1
        MOV     DPH,A
        MOV     R0,#?V0 + 4
        LCALL   ?L_SUB_X
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     R4,?V0 + 6
        MOV     R5,?V0 + 7
        LCALL   ??labs?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 6,R4
        MOV     ?V0 + 7,R5
        MOV     R0,#?V0 + 4
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_37800000
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,DPL
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 1
        MOV     DPH,A
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_EQ
        JNZ     $+5
        LJMP    ??accel_self_test_1 & 0xFFFF
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,R7
        MOV     A,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,DPL
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 1
        MOV     DPH,A
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_DIV
        MOV     DPTR,#__Constant_bf800000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_ADD
        MOV     A,?V0 + 7
        CLR     0xE0 /* A   */.7
        MOV     ?V0 + 7,A
        MOV     DPTR,#__Constant_3e0f5c2a
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_GE
        JC      $+5
        LJMP    ??accel_self_test_3 & 0xFFFF
??accel_self_test_2:
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     A,R6
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,?V0 + 0
        ORL     A,?V0 + 12
        MOV     ?V0 + 12,A
        MOV     A,?V0 + 1
        ORL     A,?V0 + 13
        MOV     ?V0 + 13,A
        LJMP    ??accel_self_test_3 & 0xFFFF
// 1942             result |= 1 << jj;
// 1943     }
// 1944 
// 1945     return result;
??accel_self_test_4:
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        MOV     A,#0xe
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock33
// 1946 }
// 1947 

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1948 static int gyro_self_test(long *bias_regular, long *bias_st)
gyro_self_test:
        CFI Block cfiBlock34 Using cfiCommon0
        CFI Function gyro_self_test
        CODE
// 1949 {
        FUNCALL gyro_self_test, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL gyro_self_test, labs
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 5
        MOV     A,#-0x5
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 29)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
// 1950     int jj, result = 0;
        MOV     ?V0 + 12,#0x0
        MOV     ?V0 + 13,#0x0
// 1951     unsigned char tmp[3];
// 1952     float st_shift, st_shift_cust, st_shift_var;
// 1953 
// 1954     if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x3
        MOV     R2,#0xd
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      ??gyro_self_test_0
// 1955         return 0x07;
        MOV     R2,#0x7
        MOV     R3,#0x0
        LJMP    ??gyro_self_test_1 & 0xFFFF
// 1956 
// 1957     tmp[0] &= 0x1F;
??gyro_self_test_0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
// 1958     tmp[1] &= 0x1F;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
// 1959     tmp[2] &= 0x1F;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
// 1960 
// 1961     for (jj = 0; jj < 3; jj++) {
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??gyro_self_test_2
// 1962         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
// 1963         if (tmp[jj]) {
// 1964             st_shift = 3275.f / test.gyro_sens;
// 1965             while (--tmp[jj])
// 1966                 st_shift *= 1.046f;
// 1967             st_shift_var = st_shift_cust / st_shift - 1.f;
// 1968             if (fabs(st_shift_var) > test.max_gyro_var)
// 1969                 result |= 1 << jj;
// 1970         } else if ((st_shift_cust < test.min_dps) ||
// 1971             (st_shift_cust > test.max_dps))
??gyro_self_test_3:
        MOV     DPTR,#__Constant_41200000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_LT
        JNC     $+5
        LJMP    ??gyro_self_test_4 & 0xFFFF
        MOV     DPTR,#__Constant_42d20001
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_GE
        JNC     $+5
        LJMP    ??gyro_self_test_4 & 0xFFFF
??gyro_self_test_5:
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
??gyro_self_test_2:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x3
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      $+5
        LJMP    ??gyro_self_test_6 & 0xFFFF
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,R7
        MOV     A,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        ; Setup parameters for call to function labs
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R0
        MOV     DPH,A
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 14
        ADD     A,R2
        MOV     DPL,A
        MOV     A,?V0 + 15
        ADDC    A,R3
        MOV     DPH,A
        MOV     R0,#?V0 + 0
        LCALL   ?L_SUB_X
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        LCALL   ??labs?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 6,R4
        MOV     ?V0 + 7,R5
        MOV     R0,#?V0 + 4
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_37800000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,R6
        MOV     R2,A
        MOV     A,DPH
        ADDC    A,R7
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        JNZ     $+5
        LJMP    ??gyro_self_test_3 & 0xFFFF
        MOV     DPTR,#__Constant_41c80000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        SJMP    ??gyro_self_test_7
??gyro_self_test_8:
        MOV     DPTR,#__Constant_3f85e354
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
??gyro_self_test_7:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        DEC     A
        MOVX    @DPTR,A
        MOVX    A,@DPTR
        JNZ     ??gyro_self_test_8
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_DIV
        MOV     DPTR,#__Constant_bf800000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_ADD
        MOV     A,?V0 + 7
        CLR     0xE0 /* A   */.7
        MOV     ?V0 + 7,A
        MOV     DPTR,#__Constant_3e0f5c2a
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_GE
        JC      $+5
        LJMP    ??gyro_self_test_5 & 0xFFFF
??gyro_self_test_4:
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     A,R6
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,?V0 + 0
        ORL     A,?V0 + 12
        MOV     ?V0 + 12,A
        MOV     A,?V0 + 1
        ORL     A,?V0 + 13
        MOV     ?V0 + 13,A
        LJMP    ??gyro_self_test_5 & 0xFFFF
// 1972             result |= 1 << jj;
// 1973     }
// 1974     return result;
??gyro_self_test_6:
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
??gyro_self_test_1:
        MOV     A,#0x5
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock34
// 1975 }
// 1976 
// 1977 #ifdef AK89xx_SECONDARY
// 1978 static int compass_self_test(void)
// 1979 {
// 1980     unsigned char tmp[6];
// 1981     unsigned char tries = 10;
// 1982     int result = 0x07;
// 1983     short data;
// 1984 
// 1985     mpu_set_bypass(1);
// 1986 
// 1987     tmp[0] = AKM_POWER_DOWN;
// 1988     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
// 1989         return 0x07;
// 1990     tmp[0] = AKM_BIT_SELF_TEST;
// 1991     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
// 1992         goto AKM_restore;
// 1993     tmp[0] = AKM_MODE_SELF_TEST;
// 1994     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
// 1995         goto AKM_restore;
// 1996 
// 1997     do {
// 1998         delay_ms(10);
// 1999         if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
// 2000             goto AKM_restore;
// 2001         if (tmp[0] & AKM_DATA_READY)
// 2002             break;
// 2003     } while (tries--);
// 2004     if (!(tmp[0] & AKM_DATA_READY))
// 2005         goto AKM_restore;
// 2006 
// 2007     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
// 2008         goto AKM_restore;
// 2009 
// 2010     result = 0;
// 2011     data = (short)(tmp[1] << 8) | tmp[0];
// 2012     if ((data > 100) || (data < -100))
// 2013         result |= 0x01;
// 2014     data = (short)(tmp[3] << 8) | tmp[2];
// 2015     if ((data > 100) || (data < -100))
// 2016         result |= 0x02;
// 2017     data = (short)(tmp[5] << 8) | tmp[4];
// 2018     if ((data > -300) || (data < -1000))
// 2019         result |= 0x04;
// 2020 
// 2021 AKM_restore:
// 2022     tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
// 2023     i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
// 2024     tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
// 2025     i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
// 2026     mpu_set_bypass(0);
// 2027     return result;
// 2028 }
// 2029 #endif
// 2030 #endif
// 2031 

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2032 static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
get_st_biases:
        CFI Block cfiBlock35 Using cfiCommon0
        CFI Function get_st_biases
        CODE
// 2033 {
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 31
        MOV     A,#-0x1f
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 55)
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     A,R1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2034     unsigned char data[MAX_PACKET_LENGTH];
// 2035     unsigned char packet_count, ii;
// 2036     unsigned short fifo_count;
// 2037 
// 2038     data[0] = 0x01;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2039     data[1] = 0;
        INC     A
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
// 2040     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
        ; Setup parameters for call to function MPU_Write_Len
        INC     A
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??get_st_biases_0
// 2041         return -1;
??get_st_biases_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??get_st_biases_2 & 0xFFFF
// 2042     delay_ms(200);
??get_st_biases_0:
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_c8
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2043     data[0] = 0;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
// 2044     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??get_st_biases_1
// 2045         return -1;
// 2046     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??get_st_biases_1
// 2047         return -1;
// 2048     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2049         return -1;
// 2050     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x17
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2051         return -1;
// 2052     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2053         return -1;
// 2054     data[0] = BIT_FIFO_RST | BIT_DMP_RST;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0xc
        MOVX    @DPTR,A
// 2055     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2056         return -1;
// 2057     delay_ms(15);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_f
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2058     data[0] = st.test->reg_lpf;
        MOV     DPTR,#st + 33
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2059     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2060         return -1;
// 2061     data[0] = st.test->reg_rate_div;
        MOV     DPTR,#st + 33
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2062     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2063         return -1;
// 2064     if (hw_test)
        MOV     DPTR,#st + 33
        MOVX    A,@DPTR
        ADD     A,#0xa
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     DPL,R0
        MOV     DPH,R1
        JZ      ??get_st_biases_3
// 2065         data[0] = st.test->reg_gyro_fsr | 0xE0;
        MOVX    A,@DPTR
        ORL     A,#0xe0
        SJMP    ??get_st_biases_4
// 2066     else
// 2067         data[0] = st.test->reg_gyro_fsr;
??get_st_biases_3:
        MOVX    A,@DPTR
??get_st_biases_4:
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2068     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2069         return -1;
// 2070 
// 2071     if (hw_test)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JZ      ??get_st_biases_5
// 2072         data[0] = st.test->reg_accel_fsr | 0xE0;
        MOV     DPTR,#st + 33
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        ORL     A,#0xe0
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        SJMP    ??get_st_biases_6
// 2073     else
// 2074         data[0] = test.reg_accel_fsr;
??get_st_biases_5:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x18
??get_st_biases_6:
        MOVX    @DPTR,A
// 2075     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2076         return -1;
// 2077     if (hw_test)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JZ      ??get_st_biases_7
// 2078         delay_ms(200);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_c8
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2079 
// 2080     /* Fill FIFO for test.wait_ms milliseconds. */
// 2081     data[0] = BIT_FIFO_EN;
??get_st_biases_7:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x40
        MOVX    @DPTR,A
// 2082     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2083         return -1;
// 2084 
// 2085     data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x78
        MOVX    @DPTR,A
// 2086     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2087         return -1;
// 2088     delay_ms(test.wait_ms);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_32
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2089     data[0] = 0;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
// 2090     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2091         return -1;
// 2092 
// 2093     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2094         return -1;
// 2095 
// 2096     fifo_count = (data[0] << 8) | data[1];
// 2097     packet_count = fifo_count / MAX_PACKET_LENGTH;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R2,#0xc
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        MOV     ?V0 + 0,A
// 2098     gyro[0] = gyro[1] = gyro[2] = 0;
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     ?V0 + 14,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 15,A
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        LCALL   ?XSTORE_R2345
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     ?V0 + 12,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 13,A
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        LCALL   ?XSTORE_R2345
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?XSTORE_R2345
// 2099     accel[0] = accel[1] = accel[2] = 0;
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R7,A
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ?XSTORE_R2345
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?XSTORE_R2345
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?XSTORE_R2345
// 2100 
// 2101     for (ii = 0; ii < packet_count; ii++) {
        MOV     ?V0 + 1,#0x0
        LJMP    ??get_st_biases_8 & 0xFFFF
// 2102         short accel_cur[3], gyro_cur[3];
// 2103         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
??get_st_biases_9:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0xc
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2104             return -1;
// 2105         accel_cur[0] = ((short)data[0] << 8) | data[1];
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x19
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2106         accel_cur[1] = ((short)data[2] << 8) | data[3];
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2107         accel_cur[2] = ((short)data[4] << 8) | data[5];
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2108         accel[0] += (long)accel_cur[0];
        MOV     A,#0x19
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2109         accel[1] += (long)accel_cur[1];
        MOV     ?V0 + 4,R4
        MOV     A,R5
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2110         accel[2] += (long)accel_cur[2];
        MOV     ?V0 + 4,R2
        MOV     A,R3
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2111         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2112         gyro_cur[1] = (((short)data[8] << 8) | data[9]);
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2113         gyro_cur[2] = (((short)data[10] << 8) | data[11]);
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2114         gyro[0] += (long)gyro_cur[0];
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2115         gyro[1] += (long)gyro_cur[1];
        MOV     ?V0 + 4,R4
        MOV     A,R5
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2116         gyro[2] += (long)gyro_cur[2];
        MOV     ?V0 + 4,R2
        MOV     A,R3
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2117     }
        INC     ?V0 + 1
??get_st_biases_8:
        MOV     A,?V0 + 1
        CLR     C
        SUBB    A,?V0 + 0
        JNC     $+5
        LJMP    ??get_st_biases_9 & 0xFFFF
// 2118 #ifdef EMPL_NO_64BIT
// 2119     gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
// 2120     gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
// 2121     gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
// 2122     if (has_accel) {
// 2123         accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
// 2124             packet_count);
// 2125         accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
// 2126             packet_count);
// 2127         accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
// 2128             packet_count);
// 2129         /* Don't remove gravity! */
// 2130         accel[2] -= 65536L;
// 2131     }
// 2132 #else
// 2133     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
        MOV     A,?V0 + 0
        MOV     ?V0 + 4,A
        CLR     A
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     DPTR,#__Constant_83
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,?V0 + 5
        MOV     ?V0 + 10,?V0 + 6
        MOV     ?V0 + 11,?V0 + 7
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2134     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     DPTR,#__Constant_83
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,?V0 + 5
        MOV     ?V0 + 10,?V0 + 6
        MOV     ?V0 + 11,?V0 + 7
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2135     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     DPTR,#__Constant_83
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,?V0 + 5
        MOV     ?V0 + 10,?V0 + 6
        MOV     ?V0 + 11,?V0 + 7
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2136     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
// 2137         packet_count);
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 8
        LCALL   ?L_SHL
        MOV     A,#0xb
        MOV     R0,#?V0 + 8
        LCALL   ?UL_SHR
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?UL_DIV_MOD
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_TO_X
// 2138     accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
// 2139         packet_count);
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 8
        LCALL   ?L_SHL
        MOV     A,#0xb
        MOV     R0,#?V0 + 8
        LCALL   ?UL_SHR
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?UL_DIV_MOD
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_TO_X
// 2140     accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
// 2141         packet_count);
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     A,#0xb
        MOV     R0,#?V0 + 0
        LCALL   ?UL_SHR
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?UL_DIV_MOD
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2142     /* Don't remove gravity! */
// 2143     if (accel[2] > 0L)
        MOV     DPL,R6
        MOV     DPH,R7
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     DPTR,#__Constant_1
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOV     R0,#?V0 + 0
        LCALL   ?SL_GT_X
        JC      ??get_st_biases_10
// 2144         accel[2] -= 65536L;
        MOV     DPTR,#__Constant_ffff0000
        SJMP    ??get_st_biases_11
// 2145     else
// 2146         accel[2] += 65536L;
??get_st_biases_10:
        MOV     DPTR,#__Constant_10000
??get_st_biases_11:
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 0
        LCALL   ?L_ADD_TO_X
// 2147 #endif
// 2148 
// 2149     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??get_st_biases_2:
        MOV     A,#0x1f
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock35
// 2150 }
// 2151 
// 2152 /**
// 2153  *  @brief      Trigger gyro/accel/compass self-test.
// 2154  *  On success/error, the self-test returns a mask representing the sensor(s)
// 2155  *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
// 2156  *  a zero (0) indicates a failure.
// 2157  *
// 2158  *  \n The mask is defined as follows:
// 2159  *  \n Bit 0:   Gyro.
// 2160  *  \n Bit 1:   Accel.
// 2161  *  \n Bit 2:   Compass.
// 2162  *
// 2163  *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
// 2164  *  this function can still be used to obtain the accel and gyro biases.
// 2165  *
// 2166  *  \n This function must be called with the device either face-up or face-down
// 2167  *  (z-axis is parallel to gravity).
// 2168  *  @param[out] gyro        Gyro biases in q16 format.
// 2169  *  @param[out] accel       Accel biases (if applicable) in q16 format.
// 2170  *  @return     Result mask (see above).
// 2171  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2172 int mpu_run_self_test(long *gyro, long *accel)
mpu_run_self_test:
        CFI Block cfiBlock36 Using cfiCommon0
        CFI Function mpu_run_self_test
        CODE
// 2173 {
        FUNCALL mpu_run_self_test, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_fifo_config
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, get_st_biases
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, get_st_biases
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, accel_self_test
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, gyro_self_test
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_sensors
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 32
        MOV     A,#-0x20
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 48)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
// 2174 #ifdef MPU6050
// 2175     const unsigned char tries = 2;
// 2176     long gyro_st[3], accel_st[3];
// 2177     unsigned char accel_result, gyro_result;
// 2178 #ifdef AK89xx_SECONDARY
// 2179     unsigned char compass_result;
// 2180 #endif
// 2181     int ii;
// 2182 #endif
// 2183     int result;
// 2184     unsigned char accel_fsr, fifo_sensors, sensors_on;
// 2185     unsigned short gyro_fsr, sample_rate, lpf;
// 2186     unsigned char dmp_was_on;
// 2187 
// 2188     if (st.chip_cfg.dmp_on) {
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_run_self_test_0
// 2189         mpu_set_dmp_state(0);
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x0
        LCALL   ??mpu_set_dmp_state?relay
// 2190         dmp_was_on = 1;
        MOV     ?V0 + 0,#0x1
        SJMP    ??mpu_run_self_test_1
// 2191     } else
// 2192         dmp_was_on = 0;
??mpu_run_self_test_0:
        MOV     ?V0 + 0,#0x0
// 2193 
// 2194     /* Get initial settings. */
// 2195     mpu_get_gyro_fsr(&gyro_fsr);
??mpu_run_self_test_1:
        ; Setup parameters for call to function mpu_get_gyro_fsr
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_gyro_fsr?relay
// 2196     mpu_get_accel_fsr(&accel_fsr);
        ; Setup parameters for call to function mpu_get_accel_fsr
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_accel_fsr?relay
// 2197     mpu_get_lpf(&lpf);
        ; Setup parameters for call to function mpu_get_lpf
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_lpf?relay
// 2198     mpu_get_sample_rate(&sample_rate);
        ; Setup parameters for call to function mpu_get_sample_rate
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_sample_rate?relay
// 2199     sensors_on = st.chip_cfg.sensors;
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2200     mpu_get_fifo_config(&fifo_sensors);
        ; Setup parameters for call to function mpu_get_fifo_config
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_fifo_config?relay
// 2201 
// 2202     /* For older chips, the self-test will be different. */
// 2203 #if defined MPU6050
// 2204     for (ii = 0; ii < tries; ii++)
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??mpu_run_self_test_2
??mpu_run_self_test_3:
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
??mpu_run_self_test_2:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x2
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??mpu_run_self_test_4
// 2205         if (!get_st_biases(gyro, accel, 0))
        ; Setup parameters for call to function get_st_biases
        MOV     R1,#0x0
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        LCALL   ??get_st_biases?relay
        MOV     ?V0 + 7,R3
        MOV     A,R2
        ORL     A,?V0 + 7
        JNZ     ??mpu_run_self_test_3
// 2206             break;
// 2207     if (ii == tries) {
??mpu_run_self_test_4:
        MOV     A,#0x2
        XRL     A,R6
        JNZ     ??mpu_run_self_test_5
        MOV     A,R7
??mpu_run_self_test_5:
        JNZ     ??mpu_run_self_test_6
// 2208         /* If we reach this point, we most likely encountered an I2C error.
// 2209          * We'll just report an error for all three sensors.
// 2210          */
// 2211         result = 0;
??mpu_run_self_test_7:
        MOV     R6,#0x0
// 2212         goto restore;
        SJMP    ??mpu_run_self_test_8
// 2213     }
// 2214     for (ii = 0; ii < tries; ii++)
??mpu_run_self_test_6:
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??mpu_run_self_test_9
??mpu_run_self_test_10:
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
??mpu_run_self_test_9:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x2
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??mpu_run_self_test_11
// 2215         if (!get_st_biases(gyro_st, accel_st, 1))
        ; Setup parameters for call to function get_st_biases
        MOV     R1,#0x1
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??get_st_biases?relay
        MOV     ?V0 + 7,R3
        MOV     A,R2
        ORL     A,?V0 + 7
        JNZ     ??mpu_run_self_test_10
// 2216             break;
// 2217     if (ii == tries) {
??mpu_run_self_test_11:
        MOV     A,#0x2
        XRL     A,R6
        JNZ     ??mpu_run_self_test_12
        MOV     A,R7
??mpu_run_self_test_12:
        JZ      ??mpu_run_self_test_7
// 2218         /* Again, probably an I2C error. */
// 2219         result = 0;
// 2220         goto restore;
// 2221     }
// 2222     accel_result = accel_self_test(accel, accel_st);
        ; Setup parameters for call to function accel_self_test
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??accel_self_test?relay
        MOV     A,R2
        MOV     ?V0 + 2,A
// 2223     gyro_result = gyro_self_test(gyro, gyro_st);
        ; Setup parameters for call to function gyro_self_test
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        LCALL   ??gyro_self_test?relay
        MOV     A,R2
// 2224 
// 2225     result = 0;
        MOV     R6,#0x0
// 2226     if (!gyro_result)
        JNZ     ??mpu_run_self_test_13
// 2227         result |= 0x01;
        INC     R6
// 2228     if (!accel_result)
??mpu_run_self_test_13:
        MOV     A,?V0 + 2
        JNZ     ??mpu_run_self_test_8
// 2229         result |= 0x02;
        MOV     A,#0x2
        ORL     A,R6
        MOV     R6,A
// 2230 
// 2231 #ifdef AK89xx_SECONDARY
// 2232     compass_result = compass_self_test();
// 2233     if (!compass_result)
// 2234         result |= 0x04;
// 2235 #endif
// 2236 restore:
// 2237 #elif defined MPU6500
// 2238     /* For now, this function will return a "pass" result for all three sensors
// 2239      * for compatibility with current test applications.
// 2240      */
// 2241     get_st_biases(gyro, accel, 0);
// 2242     result = 0x7;
// 2243 #endif
// 2244     /* Set to invalid values to ensure no I2C writes are skipped. */
// 2245     st.chip_cfg.gyro_fsr = 0xFF;
??mpu_run_self_test_8:
        MOV     DPTR,#st + 4
        MOV     A,#-0x1
        MOVX    @DPTR,A
// 2246     st.chip_cfg.accel_fsr = 0xFF;
        INC     DPTR
        MOVX    @DPTR,A
// 2247     st.chip_cfg.lpf = 0xFF;
        MOV     DPTR,#st + 7
        MOVX    @DPTR,A
// 2248     st.chip_cfg.sample_rate = 0xFFFF;
        MOV     DPTR,#st + 9
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 2249     st.chip_cfg.sensors = 0xFF;
        MOV     DPTR,#st + 6
        MOVX    @DPTR,A
// 2250     st.chip_cfg.fifo_enable = 0xFF;
        MOV     DPTR,#st + 11
        MOVX    @DPTR,A
// 2251     st.chip_cfg.clk_src = INV_CLK_PLL;
        MOV     DPTR,#st + 8
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2252     mpu_set_gyro_fsr(gyro_fsr);
        ; Setup parameters for call to function mpu_set_gyro_fsr
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_gyro_fsr?relay
// 2253     mpu_set_accel_fsr(accel_fsr);
        ; Setup parameters for call to function mpu_set_accel_fsr
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_set_accel_fsr?relay
// 2254     mpu_set_lpf(lpf);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_lpf?relay
// 2255     mpu_set_sample_rate(sample_rate);
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_sample_rate?relay
// 2256     mpu_set_sensors(sensors_on);
        ; Setup parameters for call to function mpu_set_sensors
        MOV     R1,?V0 + 1
        LCALL   ??mpu_set_sensors?relay
// 2257     mpu_configure_fifo(fifo_sensors);
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_configure_fifo?relay
// 2258 
// 2259     if (dmp_was_on)
        MOV     A,?V0 + 0
        JZ      ??mpu_run_self_test_14
// 2260         mpu_set_dmp_state(1);
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x1
        LCALL   ??mpu_set_dmp_state?relay
// 2261 
// 2262     return result;
??mpu_run_self_test_14:
        MOV     A,R6
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,#0x20
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock36
// 2263 }
// 2264 
// 2265 /**
// 2266  *  @brief      Write to the DMP memory.
// 2267  *  This function prevents I2C writes past the bank boundaries. The DMP memory
// 2268  *  is only accessible when the chip is awake.
// 2269  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
// 2270  *  @param[in]  length      Number of bytes to write.
// 2271  *  @param[in]  data        Bytes to write to memory.
// 2272  *  @return     0 if successful.
// 2273  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2274 int mpu_write_mem(unsigned short mem_addr, unsigned short length,
mpu_write_mem:
        CFI Block cfiBlock37 Using cfiCommon0
        CFI Function mpu_write_mem
        CODE
// 2275         unsigned char *data)
// 2276 {
        FUNCALL mpu_write_mem, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_write_mem, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2277     unsigned char tmp[2];
// 2278 
// 2279     if (!data)
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??mpu_write_mem_0
// 2280         return -1;
??mpu_write_mem_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_write_mem_2 & 0xFFFF
// 2281     if (!st.chip_cfg.sensors)
??mpu_write_mem_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??mpu_write_mem_1
// 2282         return -1;
// 2283 
// 2284     tmp[0] = (unsigned char)(mem_addr >> 8);
        MOV     A,R3
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2285     tmp[1] = (unsigned char)(mem_addr & 0xFF);
        MOV     A,R2
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2286 
// 2287     /* Check bank boundaries. */
// 2288     if (tmp[1] + length > st.hw->bank_size)
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R6
        MOV     R2,A
        CLR     A
        ADDC    A,R7
        MOV     R3,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        JC      ??mpu_write_mem_1
// 2289         return -1;
// 2290 
// 2291     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x18
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     DPL,?V0 + 2
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_write_mem_1
// 2292         return -1;
// 2293     if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     A,R6
        MOV     R3,A
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_write_mem_1 & 0xFFFF
// 2294         return -1;
// 2295     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_write_mem_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock37
// 2296 }
// 2297 
// 2298 /**
// 2299  *  @brief      Read from the DMP memory.
// 2300  *  This function prevents I2C reads past the bank boundaries. The DMP memory
// 2301  *  is only accessible when the chip is awake.
// 2302  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
// 2303  *  @param[in]  length      Number of bytes to read.
// 2304  *  @param[out] data        Bytes read from memory.
// 2305  *  @return     0 if successful.
// 2306  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2307 int mpu_read_mem(unsigned short mem_addr, unsigned short length,
mpu_read_mem:
        CFI Block cfiBlock38 Using cfiCommon0
        CFI Function mpu_read_mem
        CODE
// 2308         unsigned char *data)
// 2309 {
        FUNCALL mpu_read_mem, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_mem, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2310     unsigned char tmp[2];
// 2311 
// 2312     if (!data)
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??mpu_read_mem_0
// 2313         return -1;
??mpu_read_mem_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_read_mem_2 & 0xFFFF
// 2314     if (!st.chip_cfg.sensors)
??mpu_read_mem_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??mpu_read_mem_1
// 2315         return -1;
// 2316 
// 2317     tmp[0] = (unsigned char)(mem_addr >> 8);
        MOV     A,R3
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2318     tmp[1] = (unsigned char)(mem_addr & 0xFF);
        MOV     A,R2
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2319 
// 2320     /* Check bank boundaries. */
// 2321     if (tmp[1] + length > st.hw->bank_size)
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R6
        MOV     R2,A
        CLR     A
        ADDC    A,R7
        MOV     R3,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        JC      ??mpu_read_mem_1
// 2322         return -1;
// 2323 
// 2324     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x18
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     DPL,?V0 + 2
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_read_mem_1
// 2325         return -1;
// 2326     if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     A,R6
        MOV     R3,A
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_mem_1 & 0xFFFF
// 2327         return -1;
// 2328     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_read_mem_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock38
// 2329 }
// 2330 
// 2331 /**
// 2332  *  @brief      Load and verify DMP image.
// 2333  *  @param[in]  length      Length of DMP image.
// 2334  *  @param[in]  firmware    DMP code.
// 2335  *  @param[in]  start_addr  Starting address of DMP code memory.
// 2336  *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
// 2337  *  @return     0 if successful.
// 2338  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2339 int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
mpu_load_firmware:
        CFI Block cfiBlock39 Using cfiCommon0
        CFI Function mpu_load_firmware
        CODE
// 2340     unsigned short start_addr, unsigned short sample_rate)
// 2341 {
        FUNCALL mpu_load_firmware, mpu_write_mem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_load_firmware, mpu_read_mem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_load_firmware, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_load_firmware, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x16
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 22)
        ; Saved register size: 22
        ; Auto size: 18
        MOV     A,#-0x12
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 4,R4
        MOV     ?V0 + 5,R5
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     A,#0x2a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
// 2342     unsigned short ii;
// 2343     unsigned short this_write;
// 2344     /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
// 2345 #define LOAD_CHUNK  (16)
// 2346     unsigned char cur[LOAD_CHUNK], tmp[2];
// 2347 
// 2348     if (st.chip_cfg.dmp_loaded)
        MOV     DPTR,#st + 30
        MOVX    A,@DPTR
        JZ      ??mpu_load_firmware_0
// 2349         /* DMP should only be loaded once. */
// 2350         return -1;
??mpu_load_firmware_1:
        MOV     R2,#-0x1
??mpu_load_firmware_2:
        MOV     R3,#-0x1
        LJMP    ??mpu_load_firmware_3 & 0xFFFF
// 2351 
// 2352     if (!firmware)
??mpu_load_firmware_0:
        MOV     A,R4
        ORL     A,?V0 + 5
        JZ      ??mpu_load_firmware_1
// 2353         return -1;
// 2354     for (ii = 0; ii < length; ii += this_write) {
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??mpu_load_firmware_4
??mpu_load_firmware_5:
        MOV     A,R6
        ADD     A,?V0 + 10
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 11
        MOV     R7,A
??mpu_load_firmware_4:
        CLR     C
        MOV     A,R6
        SUBB    A,?V0 + 2
        MOV     A,R7
        SUBB    A,?V0 + 3
        JC      $+5
        LJMP    ??mpu_load_firmware_6 & 0xFFFF
// 2355         this_write = min(LOAD_CHUNK, length - ii);
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,R6
        MOV     R0,A
        MOV     A,?V0 + 3
        SUBB    A,R7
        MOV     R1,A
        CLR     C
        MOV     A,R0
        SUBB    A,#0x11
        MOV     A,R1
        SUBB    A,#0x0
        JC      ??mpu_load_firmware_7
        MOV     ?V0 + 10,#0x10
        MOV     ?V0 + 11,#0x0
        SJMP    ??mpu_load_firmware_8
??mpu_load_firmware_7:
        MOV     ?V0 + 10,R0
        MOV     ?V0 + 11,R1
// 2356         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
??mpu_load_firmware_8:
        MOV     A,?V0 + 4
        ADD     A,R6
        MOV     ?V0 + 12,A
        MOV     A,?V0 + 5
        ADDC    A,R7
        MOV     ?V0 + 13,A
        ; Setup parameters for call to function mpu_write_mem
        MOV     R0,#?V0 + 12
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 42)
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??mpu_write_mem?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 9,R3
        MOV     A,R2
        ORL     A,?V0 + 9
        JNZ     ??mpu_load_firmware_1
// 2357             return -1;
// 2358         if (mpu_read_mem(ii, this_write, cur))
        ; Setup parameters for call to function mpu_read_mem
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 8,DPL
        MOV     ?V0 + 9,DPH
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 42)
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??mpu_read_mem?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 9,R3
        MOV     A,R2
        ORL     A,?V0 + 9
        JZ      $+5
        LJMP    ??mpu_load_firmware_1 & 0xFFFF
// 2359             return -1;
// 2360         if (memcmp(firmware+ii, cur, this_write))
        ; Setup parameters for call to function memcmp
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 42)
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        LCALL   ??memcmp?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 9,R3
        MOV     A,R2
        ORL     A,?V0 + 9
        JNZ     $+5
        LJMP    ??mpu_load_firmware_5 & 0xFFFF
// 2361             return -2;
        MOV     R2,#-0x2
        LJMP    ??mpu_load_firmware_2 & 0xFFFF
// 2362     }
// 2363 
// 2364     /* Set program start address. */
// 2365     tmp[0] = start_addr >> 8;
??mpu_load_firmware_6:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 2366     tmp[1] = start_addr & 0xFF;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 2367     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x1a
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_load_firmware_1 & 0xFFFF
// 2368         return -1;
// 2369 
// 2370     st.chip_cfg.dmp_loaded = 1;
        MOV     DPTR,#st + 30
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2371     st.chip_cfg.dmp_sample_rate = sample_rate;
        INC     DPTR
        MOV     A,?V0 + 6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
// 2372     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_load_firmware_3:
        MOV     A,#0x12
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R7,#0xe
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock39
// 2373 }
// 2374 
// 2375 /**
// 2376  *  @brief      Enable/disable DMP support.
// 2377  *  @param[in]  enable  1 to turn on the DMP.
// 2378  *  @return     0 if successful.
// 2379  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2380 int mpu_set_dmp_state(unsigned char enable)
mpu_set_dmp_state:
        CFI Block cfiBlock40 Using cfiCommon0
        CFI Function mpu_set_dmp_state
        CODE
// 2381 {
        FUNCALL mpu_set_dmp_state, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, mpu_set_bypass
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
// 2382     unsigned char tmp;
// 2383     if (st.chip_cfg.dmp_on == enable)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??mpu_set_dmp_state_0
// 2384         return 0;
??mpu_set_dmp_state_1:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_dmp_state_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI CFA_XSP16 add(XSP16, 10)
// 2385 
// 2386     if (enable) {
??mpu_set_dmp_state_0:
        MOV     A,R6
        JZ      ??mpu_set_dmp_state_3
// 2387         if (!st.chip_cfg.dmp_loaded)
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??mpu_set_dmp_state_4
// 2388             return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_set_dmp_state_2
// 2389         /* Disable data ready interrupt. */
// 2390         set_int_enable(0);
??mpu_set_dmp_state_4:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x0
        LCALL   ??set_int_enable?relay
// 2391         /* Disable bypass mode. */
// 2392         mpu_set_bypass(0);
        ; Setup parameters for call to function mpu_set_bypass
        MOV     R1,#0x0
        LCALL   ??mpu_set_bypass?relay
// 2393         /* Keep constant sample rate, FIFO rate controlled by DMP. */
// 2394         mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     DPTR,#st + 31
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_sample_rate?relay
// 2395         /* Remove FIFO elements. */
// 2396         tmp = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 2397         i2c_write(st.hw->addr, 0x23, 1, &tmp);
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     R2,#0x23
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
// 2398         st.chip_cfg.dmp_on = 1;
        MOV     DPTR,#st + 29
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2399         /* Enable DMP interrupt. */
// 2400         set_int_enable(1);
        ; Setup parameters for call to function set_int_enable
        MOV     R1,A
        LCALL   ??set_int_enable?relay
// 2401         mpu_reset_fifo();
        ; Setup parameters for call to function mpu_reset_fifo
??mpu_set_dmp_state_5:
        LCALL   ??mpu_reset_fifo?relay
        SJMP    ??mpu_set_dmp_state_1
// 2402     } else {
// 2403         /* Disable DMP interrupt. */
// 2404         set_int_enable(0);
??mpu_set_dmp_state_3:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x0
        LCALL   ??set_int_enable?relay
// 2405         /* Restore FIFO settings. */
// 2406         tmp = st.chip_cfg.fifo_enable;
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2407         i2c_write(st.hw->addr, 0x23, 1, &tmp);
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     R2,#0x23
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
// 2408         st.chip_cfg.dmp_on = 0;
        MOV     DPTR,#st + 29
        CLR     A
        MOVX    @DPTR,A
// 2409         mpu_reset_fifo();
        ; Setup parameters for call to function mpu_reset_fifo
        SJMP    ??mpu_set_dmp_state_5
        CFI EndBlock cfiBlock40
// 2410     }
// 2411     return 0;
// 2412 }
// 2413 
// 2414 /**
// 2415  *  @brief      Get DMP state.
// 2416  *  @param[out] enabled 1 if enabled.
// 2417  *  @return     0 if successful.
// 2418  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2419 int mpu_get_dmp_state(unsigned char *enabled)
mpu_get_dmp_state:
        CFI Block cfiBlock41 Using cfiCommon0
        CFI Function mpu_get_dmp_state
        CODE
// 2420 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 2421     enabled[0] = st.chip_cfg.dmp_on;
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
// 2422     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock41
// 2423 }
// 2424 
// 2425 
// 2426 /* This initialization is similar to the one in ak8975.c. */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2427 int setup_compass(void)
setup_compass:
        CFI Block cfiBlock42 Using cfiCommon0
        CFI Function setup_compass
        CODE
// 2428 {
        ; Saved register size: 0
        ; Auto size: 0
// 2429 #ifdef AK89xx_SECONDARY
// 2430     unsigned char data[4], akm_addr;
// 2431 
// 2432     mpu_set_bypass(1);
// 2433 
// 2434     /* Find compass. Possible addresses range from 0x0C to 0x0F. */
// 2435     for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
// 2436         int result;
// 2437         result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
// 2438         if (!result && (data[0] == AKM_WHOAMI))
// 2439             break;
// 2440     }
// 2441 
// 2442     if (akm_addr > 0x0F) {
// 2443         /* TODO: Handle this case in all compass-related functions. */
// 2444         log_e("Compass not found.\n");
// 2445         return -1;
// 2446     }
// 2447 
// 2448     st.chip_cfg.compass_addr = akm_addr;
// 2449 
// 2450     data[0] = AKM_POWER_DOWN;
// 2451     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
// 2452         return -1;
// 2453     delay_ms(1);
// 2454 
// 2455     data[0] = AKM_FUSE_ROM_ACCESS;
// 2456     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
// 2457         return -1;
// 2458     delay_ms(1);
// 2459 
// 2460     /* Get sensitivity adjustment data from fuse ROM. */
// 2461     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
// 2462         return -1;
// 2463     st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
// 2464     st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
// 2465     st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
// 2466 
// 2467     data[0] = AKM_POWER_DOWN;
// 2468     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
// 2469         return -1;
// 2470     delay_ms(1);
// 2471 
// 2472     mpu_set_bypass(0);
// 2473 
// 2474     /* Set up master mode, master clock, and ES bit. */
// 2475     data[0] = 0x40;
// 2476     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
// 2477         return -1;
// 2478 
// 2479     /* Slave 0 reads from AKM data registers. */
// 2480     data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
// 2481     if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
// 2482         return -1;
// 2483 
// 2484     /* Compass reads start at this register. */
// 2485     data[0] = AKM_REG_ST1;
// 2486     if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
// 2487         return -1;
// 2488 
// 2489     /* Enable slave 0, 8-byte reads. */
// 2490     data[0] = BIT_SLAVE_EN | 8;
// 2491     if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
// 2492         return -1;
// 2493 
// 2494     /* Slave 1 changes AKM measurement mode. */
// 2495     data[0] = st.chip_cfg.compass_addr;
// 2496     if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
// 2497         return -1;
// 2498 
// 2499     /* AKM measurement mode register. */
// 2500     data[0] = AKM_REG_CNTL;
// 2501     if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
// 2502         return -1;
// 2503 
// 2504     /* Enable slave 1, 1-byte writes. */
// 2505     data[0] = BIT_SLAVE_EN | 1;
// 2506     if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
// 2507         return -1;
// 2508 
// 2509     /* Set slave 1 data. */
// 2510     data[0] = AKM_SINGLE_MEASUREMENT;
// 2511     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
// 2512         return -1;
// 2513 
// 2514     /* Trigger slave 0 and slave 1 actions at each sample. */
// 2515     data[0] = 0x03;
// 2516     if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
// 2517         return -1;
// 2518 
// 2519 #ifdef MPU9150
// 2520     /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
// 2521     data[0] = BIT_I2C_MST_VDDIO;
// 2522     if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
// 2523         return -1;
// 2524 #endif
// 2525 
// 2526     return 0;
// 2527 #else
// 2528     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ?BRET
        CFI EndBlock cfiBlock42
// 2529 #endif
// 2530 }
// 2531 
// 2532 /**
// 2533  *  @brief      Read raw compass data.
// 2534  *  @param[out] data        Raw data in hardware units.
// 2535  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
// 2536  *  @return     0 if successful.
// 2537  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2538 int mpu_get_compass_reg(short *data, unsigned long *timestamp)
mpu_get_compass_reg:
        CFI Block cfiBlock43 Using cfiCommon0
        CFI Function mpu_get_compass_reg
        CODE
// 2539 {
        ; Saved register size: 0
        ; Auto size: 0
// 2540 #ifdef AK89xx_SECONDARY
// 2541     unsigned char tmp[9];
// 2542 
// 2543     if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
// 2544         return -1;
// 2545 
// 2546 #ifdef AK89xx_BYPASS
// 2547     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
// 2548         return -1;
// 2549     tmp[8] = AKM_SINGLE_MEASUREMENT;
// 2550     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
// 2551         return -1;
// 2552 #else
// 2553     if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
// 2554         return -1;
// 2555 #endif
// 2556 
// 2557 #if defined AK8975_SECONDARY
// 2558     /* AK8975 doesn't have the overrun error bit. */
// 2559     if (!(tmp[0] & AKM_DATA_READY))
// 2560         return -2;
// 2561     if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
// 2562         return -3;
// 2563 #elif defined AK8963_SECONDARY
// 2564     /* AK8963 doesn't have the data read error bit. */
// 2565     if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
// 2566         return -2;
// 2567     if (tmp[7] & AKM_OVERFLOW)
// 2568         return -3;
// 2569 #endif
// 2570     data[0] = (tmp[2] << 8) | tmp[1];
// 2571     data[1] = (tmp[4] << 8) | tmp[3];
// 2572     data[2] = (tmp[6] << 8) | tmp[5];
// 2573 
// 2574     data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
// 2575     data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
// 2576     data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
// 2577 
// 2578     if (timestamp)
// 2579         get_ms(timestamp);
// 2580     return 0;
// 2581 #else
// 2582     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ?BRET
        CFI EndBlock cfiBlock43
// 2583 #endif
// 2584 }
// 2585 
// 2586 /**
// 2587  *  @brief      Get the compass full-scale range.
// 2588  *  @param[out] fsr Current full-scale range.
// 2589  *  @return     0 if successful.
// 2590  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2591 int mpu_get_compass_fsr(unsigned short *fsr)
mpu_get_compass_fsr:
        CFI Block cfiBlock44 Using cfiCommon0
        CFI Function mpu_get_compass_fsr
        CODE
// 2592 {
        ; Saved register size: 0
        ; Auto size: 0
// 2593 #ifdef AK89xx_SECONDARY
// 2594     fsr[0] = st.hw->compass_fsr;
// 2595     return 0;
// 2596 #else
// 2597     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ?BRET
        CFI EndBlock cfiBlock44
// 2598 #endif
// 2599 }
// 2600 
// 2601 /**
// 2602  *  @brief      Enters LP accel motion interrupt mode.
// 2603  *  The behavior of this feature is very different between the MPU6050 and the
// 2604  *  MPU6500. Each chip's version of this feature is explained below.
// 2605  *
// 2606  *  \n MPU6050:
// 2607  *  \n When this mode is first enabled, the hardware captures a single accel
// 2608  *  sample, and subsequent samples are compared with this one to determine if
// 2609  *  the device is in motion. Therefore, whenever this "locked" sample needs to
// 2610  *  be changed, this function must be called again.
// 2611  *
// 2612  *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
// 2613  *  increments.
// 2614  *
// 2615  *  \n Low-power accel mode supports the following frequencies:
// 2616  *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
// 2617  *
// 2618  *  \n MPU6500:
// 2619  *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
// 2620  *  sample. The hardware monitors the accel data and detects any large change
// 2621  *  over a short period of time.
// 2622  *
// 2623  *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
// 2624  *  increments.
// 2625  *
// 2626  *  \n MPU6500 Low-power accel mode supports the following frequencies:
// 2627  *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
// 2628  *
// 2629  *  \n\n NOTES:
// 2630  *  \n The driver will round down @e thresh to the nearest supported value if
// 2631  *  an unsupported threshold is selected.
// 2632  *  \n To select a fractional wake-up frequency, round down the value passed to
// 2633  *  @e lpa_freq.
// 2634  *  \n The MPU6500 does not support a delay parameter. If this function is used
// 2635  *  for the MPU6500, the value passed to @e time will be ignored.
// 2636  *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
// 2637  *  the previous configuration.
// 2638  *
// 2639  *  @param[in]  thresh      Motion threshold in mg.
// 2640  *  @param[in]  time        Duration in milliseconds that the accel data must
// 2641  *                          exceed @e thresh before motion is reported.
// 2642  *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
// 2643  *  @return     0 if successful.
// 2644  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2645 int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
mpu_lp_motion_interrupt:
        CFI Block cfiBlock45 Using cfiCommon0
        CFI Function mpu_lp_motion_interrupt
        CODE
// 2646     unsigned char lpa_freq)
// 2647 {
        FUNCALL mpu_lp_motion_interrupt, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_fifo_config
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_lp_accel_mode
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_sensors
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 3
        MOV     A,#-0x3
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 13)
        MOV     A,R1
        MOV     R7,A
        MOV     A,R4
        MOV     R6,A
// 2648     unsigned char data[3];
// 2649 
// 2650     if (lpa_freq) {
        JNZ     $+5
        LJMP    ??mpu_lp_motion_interrupt_0 & 0xFFFF
// 2651         unsigned char thresh_hw;
// 2652 
// 2653 #if defined MPU6050
// 2654         /* TODO: Make these const/#defines. */
// 2655         /* 1LSb = 32mg. */
// 2656         if (thresh > 8160)
        CLR     C
        MOV     A,R2
        SUBB    A,#-0x1f
        MOV     A,R3
        SUBB    A,#0x1f
        JC      ??mpu_lp_motion_interrupt_1
// 2657             thresh_hw = 255;
        MOV     ?V0 + 0,#-0x1
        SJMP    ??mpu_lp_motion_interrupt_2
// 2658         else if (thresh < 32)
??mpu_lp_motion_interrupt_1:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x20
        MOV     A,R3
        SUBB    A,#0x0
        JNC     ??mpu_lp_motion_interrupt_3
// 2659             thresh_hw = 1;
        MOV     ?V0 + 0,#0x1
        SJMP    ??mpu_lp_motion_interrupt_2
// 2660         else
// 2661             thresh_hw = thresh >> 5;
??mpu_lp_motion_interrupt_3:
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#0x5
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
// 2662 #elif defined MPU6500
// 2663         /* 1LSb = 4mg. */
// 2664         if (thresh > 1020)
// 2665             thresh_hw = 255;
// 2666         else if (thresh < 4)
// 2667             thresh_hw = 1;
// 2668         else
// 2669             thresh_hw = thresh >> 2;
// 2670 #endif
// 2671 
// 2672         if (!time)
??mpu_lp_motion_interrupt_2:
        MOV     A,R7
        JNZ     ??mpu_lp_motion_interrupt_4
// 2673             /* Minimum duration must be 1ms. */
// 2674             time = 1;
        MOV     R7,#0x1
// 2675 
// 2676 #if defined MPU6050
// 2677         if (lpa_freq > 40)
??mpu_lp_motion_interrupt_4:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x29
        JC      ??mpu_lp_motion_interrupt_5
// 2678 #elif defined MPU6500
// 2679         if (lpa_freq > 640)
// 2680 #endif
// 2681             /* At this point, the chip has not been re-configured, so the
// 2682              * function can safely exit.
// 2683              */
// 2684             return -1;
??mpu_lp_motion_interrupt_6:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
// 2685 
// 2686         if (!st.chip_cfg.int_motion_only) {
??mpu_lp_motion_interrupt_5:
        MOV     DPTR,#st + 16
        MOVX    A,@DPTR
        JNZ     ??mpu_lp_motion_interrupt_8
// 2687             /* Store current settings for later. */
// 2688             if (st.chip_cfg.dmp_on) {
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_lp_motion_interrupt_9
// 2689                 mpu_set_dmp_state(0);
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x0
        LCALL   ??mpu_set_dmp_state?relay
// 2690                 st.chip_cfg.cache.dmp_on = 1;
        MOV     DPTR,#st + 26
        MOV     A,#0x1
        SJMP    ??mpu_lp_motion_interrupt_10
// 2691             } else
// 2692                 st.chip_cfg.cache.dmp_on = 0;
??mpu_lp_motion_interrupt_9:
        MOV     DPTR,#st + 26
        CLR     A
??mpu_lp_motion_interrupt_10:
        MOVX    @DPTR,A
// 2693             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
        ; Setup parameters for call to function mpu_get_gyro_fsr
        MOV     R2,#(st + 17) & 0xff
        MOV     R3,#((st + 17) >> 8) & 0xff
        LCALL   ??mpu_get_gyro_fsr?relay
// 2694             mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
        ; Setup parameters for call to function mpu_get_accel_fsr
        MOV     R2,#(st + 19) & 0xff
        MOV     R3,#((st + 19) >> 8) & 0xff
        LCALL   ??mpu_get_accel_fsr?relay
// 2695             mpu_get_lpf(&st.chip_cfg.cache.lpf);
        ; Setup parameters for call to function mpu_get_lpf
        MOV     R2,#(st + 20) & 0xff
        MOV     R3,#((st + 20) >> 8) & 0xff
        LCALL   ??mpu_get_lpf?relay
// 2696             mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
        ; Setup parameters for call to function mpu_get_sample_rate
        MOV     R2,#(st + 22) & 0xff
        MOV     R3,#((st + 22) >> 8) & 0xff
        LCALL   ??mpu_get_sample_rate?relay
// 2697             st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     DPTR,#st + 24
        MOVX    @DPTR,A
// 2698             mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
        ; Setup parameters for call to function mpu_get_fifo_config
        MOV     R2,#(st + 25) & 0xff
        MOV     R3,#((st + 25) >> 8) & 0xff
        LCALL   ??mpu_get_fifo_config?relay
// 2699         }
// 2700 
// 2701 #ifdef MPU6050
// 2702         /* Disable hardware interrupts for now. */
// 2703         set_int_enable(0);
??mpu_lp_motion_interrupt_8:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x0
        LCALL   ??set_int_enable?relay
// 2704 
// 2705         /* Enter full-power accel-only mode. */
// 2706         mpu_lp_accel_mode(0);
        ; Setup parameters for call to function mpu_lp_accel_mode
        MOV     R1,#0x0
        LCALL   ??mpu_lp_accel_mode?relay
// 2707 
// 2708         /* Override current LPF (and HPF) settings to obtain a valid accel
// 2709          * reading.
// 2710          */
// 2711         data[0] = INV_FILTER_256HZ_NOLPF2;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 2712         if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
// 2713             return -1;
// 2714 
// 2715         /* NOTE: Digital high pass filter should be configured here. Since this
// 2716          * driver doesn't modify those bits anywhere, they should already be
// 2717          * cleared by default.
// 2718          */
// 2719 
// 2720         /* Configure the device to send motion interrupts. */
// 2721         /* Enable motion interrupt. */
// 2722         data[0] = BIT_MOT_INT_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x40
        MOVX    @DPTR,A
// 2723         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
// 2724             goto lp_int_restore;
// 2725 
// 2726         /* Set motion interrupt parameters. */
// 2727         data[0] = thresh_hw;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 2728         data[1] = time;
        MOV     A,R7
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2729         if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
// 2730             goto lp_int_restore;
// 2731 
// 2732         /* Force hardware to "lock" current accel sample. */
// 2733         delay_ms(5);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_5
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2734         data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
        MOV     DPTR,#st + 5
        MOVX    A,@DPTR
        RLC     A
        RLC     A
        RLC     A
        ANL     A,#0xf8
        ORL     A,#0x7
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2735         if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
// 2736             goto lp_int_restore;
// 2737 
// 2738         /* Set up LP accel mode. */
// 2739         data[0] = BIT_LPA_CYCLE;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x20
        MOVX    @DPTR,A
// 2740         if (lpa_freq == 1)
        MOV     A,#0x1
        XRL     A,R6
        JNZ     ??mpu_lp_motion_interrupt_12
// 2741             data[1] = INV_LPA_1_25HZ;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        SJMP    ??mpu_lp_motion_interrupt_13
// 2742         else if (lpa_freq <= 5)
??mpu_lp_motion_interrupt_12:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x6
        JNC     ??mpu_lp_motion_interrupt_14
// 2743             data[1] = INV_LPA_5HZ;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        SJMP    ??mpu_lp_motion_interrupt_13
// 2744         else if (lpa_freq <= 20)
??mpu_lp_motion_interrupt_14:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x15
        MOV     A,#0x1
        JNC     ??mpu_lp_motion_interrupt_15
// 2745             data[1] = INV_LPA_20HZ;
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x2
        SJMP    ??mpu_lp_motion_interrupt_13
// 2746         else
// 2747             data[1] = INV_LPA_40HZ;
??mpu_lp_motion_interrupt_15:
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x3
??mpu_lp_motion_interrupt_13:
        MOVX    @DPTR,A
// 2748         data[1] = (data[1] << 6) | BIT_STBY_XYZG;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        SWAP    A
        RLC     A
        RLC     A
        ANL     A,#0xc0
        ORL     A,#0x7
        MOVX    @DPTR,A
// 2749         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_lp_motion_interrupt_11
// 2750             goto lp_int_restore;
// 2751 
// 2752         st.chip_cfg.int_motion_only = 1;
        MOV     DPTR,#st + 16
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2753         return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
// 2754 #elif defined MPU6500
// 2755         /* Disable hardware interrupts. */
// 2756         set_int_enable(0);
// 2757 
// 2758         /* Enter full-power accel-only mode, no FIFO/DMP. */
// 2759         data[0] = 0;
// 2760         data[1] = 0;
// 2761         data[2] = BIT_STBY_XYZG;
// 2762         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
// 2763             goto lp_int_restore;
// 2764 
// 2765         /* Set motion threshold. */
// 2766         data[0] = thresh_hw;
// 2767         if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
// 2768             goto lp_int_restore;
// 2769 
// 2770         /* Set wake frequency. */
// 2771         if (lpa_freq == 1)
// 2772             data[0] = INV_LPA_1_25HZ;
// 2773         else if (lpa_freq == 2)
// 2774             data[0] = INV_LPA_2_5HZ;
// 2775         else if (lpa_freq <= 5)
// 2776             data[0] = INV_LPA_5HZ;
// 2777         else if (lpa_freq <= 10)
// 2778             data[0] = INV_LPA_10HZ;
// 2779         else if (lpa_freq <= 20)
// 2780             data[0] = INV_LPA_20HZ;
// 2781         else if (lpa_freq <= 40)
// 2782             data[0] = INV_LPA_40HZ;
// 2783         else if (lpa_freq <= 80)
// 2784             data[0] = INV_LPA_80HZ;
// 2785         else if (lpa_freq <= 160)
// 2786             data[0] = INV_LPA_160HZ;
// 2787         else if (lpa_freq <= 320)
// 2788             data[0] = INV_LPA_320HZ;
// 2789         else
// 2790             data[0] = INV_LPA_640HZ;
// 2791         if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
// 2792             goto lp_int_restore;
// 2793 
// 2794         /* Enable motion interrupt (MPU6500 version). */
// 2795         data[0] = BITS_WOM_EN;
// 2796         if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
// 2797             goto lp_int_restore;
// 2798 
// 2799         /* Enable cycle mode. */
// 2800         data[0] = BIT_LPA_CYCLE;
// 2801         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
// 2802             goto lp_int_restore;
// 2803 
// 2804         /* Enable interrupt. */
// 2805         data[0] = BIT_MOT_INT_EN;
// 2806         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
// 2807             goto lp_int_restore;
// 2808 
// 2809         st.chip_cfg.int_motion_only = 1;
// 2810         return 0;
// 2811 #endif
// 2812     } else {
// 2813         /* Don't "restore" the previous state if no state has been saved. */
// 2814         int ii;
// 2815         char *cache_ptr = (char*)&st.chip_cfg.cache;
// 2816         for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
??mpu_lp_motion_interrupt_0:
        MOV     R0,#0x0
        MOV     R1,#0x0
        SJMP    ??mpu_lp_motion_interrupt_16
??mpu_lp_motion_interrupt_17:
        MOV     A,R0
        ADD     A,#0x1
        INC     R0
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
??mpu_lp_motion_interrupt_16:
        CLR     C
        MOV     A,R0
        SUBB    A,#0xa
        MOV     A,R1
        SUBB    A,#0x0
        JC      $+5
        LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
// 2817             if (cache_ptr[ii] != 0)
        MOV     A,#(st + 17) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((st + 17) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      ??mpu_lp_motion_interrupt_17
// 2818                 goto lp_int_restore;
// 2819         }
// 2820         /* If we reach this point, motion interrupt mode hasn't been used yet. */
// 2821         return -1;
// 2822     }
// 2823 lp_int_restore:
// 2824     /* Set to invalid values to ensure no I2C writes are skipped. */
// 2825     st.chip_cfg.gyro_fsr = 0xFF;
??mpu_lp_motion_interrupt_11:
        MOV     DPTR,#st + 4
        MOV     A,#-0x1
        MOVX    @DPTR,A
// 2826     st.chip_cfg.accel_fsr = 0xFF;
        INC     DPTR
        MOVX    @DPTR,A
// 2827     st.chip_cfg.lpf = 0xFF;
        MOV     DPTR,#st + 7
        MOVX    @DPTR,A
// 2828     st.chip_cfg.sample_rate = 0xFFFF;
        MOV     DPTR,#st + 9
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 2829     st.chip_cfg.sensors = 0xFF;
        MOV     DPTR,#st + 6
        MOVX    @DPTR,A
// 2830     st.chip_cfg.fifo_enable = 0xFF;
        MOV     DPTR,#st + 11
        MOVX    @DPTR,A
// 2831     st.chip_cfg.clk_src = INV_CLK_PLL;
        MOV     DPTR,#st + 8
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2832     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
        ; Setup parameters for call to function mpu_set_sensors
        MOV     DPTR,#st + 24
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_set_sensors?relay
// 2833     mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
        ; Setup parameters for call to function mpu_set_gyro_fsr
        MOV     DPTR,#st + 17
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_gyro_fsr?relay
// 2834     mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
        ; Setup parameters for call to function mpu_set_accel_fsr
        MOV     DPTR,#st + 19
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_set_accel_fsr?relay
// 2835     mpu_set_lpf(st.chip_cfg.cache.lpf);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     DPTR,#st + 20
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_lpf?relay
// 2836     mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     DPTR,#st + 22
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_sample_rate?relay
// 2837     mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     DPTR,#st + 25
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_configure_fifo?relay
// 2838 
// 2839     if (st.chip_cfg.cache.dmp_on)
        MOV     DPTR,#st + 26
        MOVX    A,@DPTR
        JZ      ??mpu_lp_motion_interrupt_18
// 2840         mpu_set_dmp_state(1);
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x1
        LCALL   ??mpu_set_dmp_state?relay
// 2841 
// 2842 #ifdef MPU6500
// 2843     /* Disable motion interrupt (MPU6500 version). */
// 2844     data[0] = 0;
// 2845     if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
// 2846         goto lp_int_restore;
// 2847 #endif
// 2848 
// 2849     st.chip_cfg.int_motion_only = 0;
??mpu_lp_motion_interrupt_18:
        MOV     DPTR,#st + 16
        CLR     A
        MOVX    @DPTR,A
// 2850     return 0;
        MOV     R2,A
        MOV     R3,A
??mpu_lp_motion_interrupt_7:
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock45
// 2851 }
// 2852 
// 2853 //q30¸ñÊ½,long×ªfloatÊ±µÄ³ýÊý.
// 2854 #define q30  1073741824.0f
// 2855 
// 2856 //ÍÓÂÝÒÇ·½ÏòÉèÖÃ

        RSEG XDATA_I:XDATA:NOROOT(0)
// 2857 static signed char gyro_orientation[9] = { 1, 0, 0,
gyro_orientation:
        DATA8
        DS 9
        REQUIRE `?<Initializer for gyro_orientation>`
        REQUIRE __INIT_XDATA_I
// 2858                                            0, 1, 0,
// 2859                                            0, 0, 1};
// 2860 //MPU6050×Ô²âÊÔ
// 2861 //·µ»ØÖµ:0,Õý³£
// 2862 //    ÆäËû,Ê§°Ü

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2863 u8 run_self_test(void)
run_self_test:
        CFI Block cfiBlock46 Using cfiCommon0
        CFI Function run_self_test
        CODE
// 2864 {
        FUNCALL run_self_test, mpu_run_self_test
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL run_self_test, mpu_get_gyro_sens
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL run_self_test, dmp_set_gyro_bias
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL run_self_test, mpu_get_accel_sens
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL run_self_test, dmp_set_accel_bias
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 30
        MOV     A,#-0x1e
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 46)
// 2865   int result;
// 2866   //char test_packet[4] = {0};
// 2867   long gyro[3], accel[3]; 
// 2868   result = mpu_run_self_test(gyro, accel);
// 2869   if (result == 0x3) 
        ; Setup parameters for call to function mpu_run_self_test
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_run_self_test?relay
        MOV     ?V0 + 0,R2
        MOV     A,#0x3
        XRL     A,?V0 + 0
        JNZ     ??run_self_test_0
        MOV     A,R3
??run_self_test_0:
        JZ      $+5
        LJMP    ??run_self_test_1 & 0xFFFF
// 2870   {
// 2871       /* Test passed. We can trust the gyro data here, so let's push it down
// 2872       * to the DMP.
// 2873       */
// 2874       float sens;
// 2875       unsigned short accel_sens;
// 2876       mpu_get_gyro_sens(&sens);
        ; Setup parameters for call to function mpu_get_gyro_sens
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_gyro_sens?relay
// 2877       gyro[0] = (long)(gyro[0] * sens);
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        LCALL   ?FLT_TO_L
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2878       gyro[1] = (long)(gyro[1] * sens);
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        LCALL   ?FLT_TO_L
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2879       gyro[2] = (long)(gyro[2] * sens);
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        LCALL   ?FLT_TO_L
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2880       dmp_set_gyro_bias(gyro);
        ; Setup parameters for call to function dmp_set_gyro_bias
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??dmp_set_gyro_bias?relay
// 2881       mpu_get_accel_sens(&accel_sens);
        ; Setup parameters for call to function mpu_get_accel_sens
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_accel_sens?relay
// 2882       accel_sens=0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 2883       accel[0] *= accel_sens;
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XSTORE_R2345
// 2884       accel[1] *= accel_sens;
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XSTORE_R2345
// 2885       accel[2] *= accel_sens;
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XSTORE_R2345
// 2886       dmp_set_accel_bias(accel);
        ; Setup parameters for call to function dmp_set_accel_bias
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??dmp_set_accel_bias?relay
// 2887       return 0;
        MOV     R1,#0x0
        SJMP    ??run_self_test_2
// 2888   }else return 1;
??run_self_test_1:
        MOV     R1,#0x1
??run_self_test_2:
        MOV     A,#0x1e
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock46
// 2889 }
// 2890 //ÍÓÂÝÒÇ·½Ïò¿ØÖÆ

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2891 unsigned short inv_orientation_matrix_to_scalar(
inv_orientation_matrix_to_scalar:
        CFI Block cfiBlock47 Using cfiCommon0
        CFI Function inv_orientation_matrix_to_scalar
        CODE
// 2892     const signed char *mtx)
// 2893 {
        FUNCALL inv_orientation_matrix_to_scalar, inv_row_2_scale
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL inv_orientation_matrix_to_scalar, inv_row_2_scale
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL inv_orientation_matrix_to_scalar, inv_row_2_scale
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 2894     unsigned short scalar; 
// 2895     /*
// 2896        XYZ  010_001_000 Identity Matrix
// 2897        XZY  001_010_000
// 2898        YXZ  010_000_001
// 2899        YZX  000_010_001
// 2900        ZXY  001_000_010
// 2901        ZYX  000_001_010
// 2902      */
// 2903 
// 2904     scalar = inv_row_2_scale(mtx);
        ; Setup parameters for call to function inv_row_2_scale
        LCALL   ??inv_row_2_scale?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 2905     scalar |= inv_row_2_scale(mtx + 3) << 3;
        ; Setup parameters for call to function inv_row_2_scale
        MOV     A,R6
        ADD     A,#0x3
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??inv_row_2_scale?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,#0x3
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,?V0 + 2
        ORL     A,?V0 + 0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 3
        ORL     A,?V0 + 1
        MOV     ?V0 + 1,A
// 2906     scalar |= inv_row_2_scale(mtx + 6) << 6;
        ; Setup parameters for call to function inv_row_2_scale
        MOV     A,R6
        ADD     A,#0x6
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??inv_row_2_scale?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,#0x6
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,?V0 + 2
        ORL     A,?V0 + 0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 3
        ORL     A,?V0 + 1
// 2907 
// 2908 
// 2909     return scalar;
        MOV     R2,?V0 + 0
        MOV     R3,A
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock47
// 2910 }
// 2911 //·½Ïò×ª»»

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2912 unsigned short inv_row_2_scale(const signed char *row)
inv_row_2_scale:
        CFI Block cfiBlock48 Using cfiCommon0
        CFI Function inv_row_2_scale
        CODE
// 2913 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 2914     unsigned short b;
// 2915 
// 2916     if (row[0] > 0)
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      ??inv_row_2_scale_0
// 2917         b = 0;
        MOV     R2,#0x0
        SJMP    ??inv_row_2_scale_1
// 2918     else if (row[0] < 0)
??inv_row_2_scale_0:
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??inv_row_2_scale_2
// 2919         b = 4;
        MOV     R2,#0x4
        SJMP    ??inv_row_2_scale_1
// 2920     else if (row[1] > 0)
??inv_row_2_scale_2:
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      ??inv_row_2_scale_3
// 2921         b = 1;
        MOV     R2,#0x1
        SJMP    ??inv_row_2_scale_1
// 2922     else if (row[1] < 0)
??inv_row_2_scale_3:
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??inv_row_2_scale_4
// 2923         b = 5;
        MOV     R2,#0x5
        SJMP    ??inv_row_2_scale_1
// 2924     else if (row[2] > 0)
??inv_row_2_scale_4:
        MOV     A,R2
        ADD     A,#0x2
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      ??inv_row_2_scale_5
// 2925         b = 2;
        MOV     R2,#0x2
        SJMP    ??inv_row_2_scale_1
// 2926     else if (row[2] < 0)
??inv_row_2_scale_5:
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??inv_row_2_scale_6
// 2927         b = 6;
        MOV     R2,#0x6
        SJMP    ??inv_row_2_scale_1
// 2928     else
// 2929         b = 7;      // error
??inv_row_2_scale_6:
        MOV     R2,#0x7
??inv_row_2_scale_1:
        MOV     R3,#0x0
// 2930     return b;
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock48
// 2931 }
// 2932 //¿Õº¯Êý,Î´ÓÃµ½.

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2933 void mget_ms(unsigned long *time)
mget_ms:
        CFI Block cfiBlock49 Using cfiCommon0
        CFI Function mget_ms
        CODE
// 2934 {
        ; Saved register size: 0
        ; Auto size: 0
// 2935 
// 2936 }
        LJMP    ?BRET
        CFI EndBlock cfiBlock49
// 2937 //mpu6050,dmp³õÊ¼»¯
// 2938 //·µ»ØÖµ:0,Õý³£
// 2939 //    ÆäËû,Ê§°Ü

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2940 u8 mpu_dmp_init(void)
mpu_dmp_init:
        CFI Block cfiBlock50 Using cfiCommon0
        CFI Function mpu_dmp_init
        CODE
// 2941 {
        FUNCALL mpu_dmp_init, MPU_IIC_Init
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_init
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_set_sensors
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, dmp_load_motion_driver_firmware
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, inv_orientation_matrix_to_scalar
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, dmp_set_orientation
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, dmp_enable_feature
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, dmp_set_fifo_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
// 2942   u8 res=0;
// 2943   MPU_IIC_Init(); 	//³õÊ¼»¯MPU_IIC×ÜÏß
        ; Setup parameters for call to function MPU_IIC_Init
        LCALL   ??MPU_IIC_Init?relay
// 2944   if(mpu_init()==0)	//³õÊ¼»¯MPU6050
        ; Setup parameters for call to function mpu_init
        LCALL   ??mpu_init?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JNZ     ??mpu_dmp_init_0
// 2945   {	 
// 2946       res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);    //ÉèÖÃËùÐèÒªµÄ´«¸ÐÆ÷
        ; Setup parameters for call to function mpu_set_sensors
        MOV     R1,#0x78
        LCALL   ??mpu_set_sensors?relay
        MOV     A,R2
// 2947       if(res)return 1; 
        JZ      ??mpu_dmp_init_1
        MOV     R1,#0x1
        SJMP    ??mpu_dmp_init_2
// 2948       res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL); //ÉèÖÃFIFO
??mpu_dmp_init_1:
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     R1,#0x78
        LCALL   ??mpu_configure_fifo?relay
        MOV     A,R2
// 2949       if(res)return 2; 
        JZ      ??mpu_dmp_init_3
        MOV     R1,#0x2
        SJMP    ??mpu_dmp_init_2
// 2950       res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	          //ÉèÖÃ²ÉÑùÂÊ
??mpu_dmp_init_3:
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     R2,#0x64
        MOV     R3,#0x0
        LCALL   ??mpu_set_sample_rate?relay
        MOV     A,R2
// 2951       if(res)return 3; 
        JZ      ??mpu_dmp_init_4
        MOV     R1,#0x3
        SJMP    ??mpu_dmp_init_2
// 2952       res=dmp_load_motion_driver_firmware();		  //¼ÓÔØdmp¹Ì¼þ
??mpu_dmp_init_4:
        ; Setup parameters for call to function dmp_load_motion_driver_firmware
        LCALL   ??dmp_load_motion_driver_firmware?relay
        MOV     A,R2
// 2953       if(res)return 4; 
        JZ      ??mpu_dmp_init_5
        MOV     R1,#0x4
        SJMP    ??mpu_dmp_init_2
// 2954       res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//ÉèÖÃÍÓÂÝÒÇ·½Ïò
??mpu_dmp_init_5:
        ; Setup parameters for call to function dmp_set_orientation
        ; Setup parameters for call to function inv_orientation_matrix_to_scalar
        MOV     R2,#gyro_orientation & 0xff
        MOV     R3,#(gyro_orientation >> 8) & 0xff
        LCALL   ??inv_orientation_matrix_to_scalar?relay
        LCALL   ??dmp_set_orientation?relay
        MOV     A,R2
// 2955       if(res)return 5; 
        JZ      ??mpu_dmp_init_6
        MOV     R1,#0x5
        SJMP    ??mpu_dmp_init_2
// 2956       res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	          //ÉèÖÃdmp¹¦ÄÜ
// 2957           DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
// 2958           DMP_FEATURE_GYRO_CAL);
??mpu_dmp_init_6:
        ; Setup parameters for call to function dmp_enable_feature
        MOV     R2,#0x73
        MOV     R3,#0x1
        LCALL   ??dmp_enable_feature?relay
        MOV     A,R2
// 2959       if(res)return 6; 
        JZ      ??mpu_dmp_init_7
        MOV     R1,#0x6
        SJMP    ??mpu_dmp_init_2
// 2960       res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);  //ÉèÖÃDMPÊä³öËÙÂÊ(×î´ó²»³¬¹ý200Hz)
??mpu_dmp_init_7:
        ; Setup parameters for call to function dmp_set_fifo_rate
        MOV     R2,#0x64
        MOV     R3,#0x0
        LCALL   ??dmp_set_fifo_rate?relay
        MOV     A,R2
// 2961       if(res)return 7;   
        JZ      ??mpu_dmp_init_8
        MOV     R1,#0x7
        SJMP    ??mpu_dmp_init_2
// 2962 //      res=run_self_test();		      //×Ô¼ì
// 2963 //      if(res)return 8;    
// 2964       res=mpu_set_dmp_state(1);	              //Ê¹ÄÜDMP
??mpu_dmp_init_8:
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x1
        LCALL   ??mpu_set_dmp_state?relay
        MOV     A,R2
// 2965       if(res)return 9;     
        JZ      ??mpu_dmp_init_9
        MOV     R1,#0x9
        SJMP    ??mpu_dmp_init_2
// 2966   }else return 10;
// 2967   return 0;
??mpu_dmp_init_9:
        MOV     R1,#0x0
        SJMP    ??mpu_dmp_init_2
??mpu_dmp_init_0:
        MOV     R1,#0xa
??mpu_dmp_init_2:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock50
// 2968 }
// 2969 
// 2970 //µÃµ½dmp´¦ÀíºóµÄÊý¾Ý(×¢Òâ,±¾º¯ÊýÐèÒª±È½Ï¶à¶ÑÕ»,¾Ö²¿±äÁ¿ÓÐµã¶à)
// 2971 //pitch:¸©Ñö½Ç ¾«¶È:0.1¡ã   ·¶Î§:-90.0¡ã <---> +90.0¡ã
// 2972 //roll:ºá¹ö½Ç  ¾«¶È:0.1¡ã   ·¶Î§:-180.0¡ã<---> +180.0¡ã
// 2973 //yaw:º½Ïò½Ç   ¾«¶È:0.1¡ã   ·¶Î§:-180.0¡ã<---> +180.0¡ã
// 2974 //·µ»ØÖµ:0,Õý³£
// 2975 //    ÆäËû,Ê§°Ü

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2976 u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
mpu_dmp_get_data:
        CFI Block cfiBlock51 Using cfiCommon0
        CFI Function mpu_dmp_get_data
        CODE
// 2977 {
        FUNCALL mpu_dmp_get_data, dmp_read_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 87, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 87, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_get_data, asin
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 79, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 79, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_get_data, atan2
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 83, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 83, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_get_data, atan2
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 83, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 83, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 55
        MOV     A,#-0x37
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 79)
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2978 	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
// 2979 	unsigned long sensor_timestamp;
// 2980 	short gyro[3], accel[3], sensors;
// 2981 	unsigned char more;
// 2982 	long quat[4]; 
// 2983 	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))
        ; Setup parameters for call to function dmp_read_fifo
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 81)
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 83)
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 85)
        MOV     A,#0x21
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 87)
        MOV     A,#0x33
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x39
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??dmp_read_fifo?relay
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 79)
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      ??mpu_dmp_get_data_0
// 2984         {
// 2985           //printf("read dmp_read_fifo error\r\n");
// 2986           return 1;	 //gyro
        MOV     R1,#0x1
        LJMP    ??mpu_dmp_get_data_1 & 0xFFFF
// 2987         }
// 2988 	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
// 2989 	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
// 2990 	**/
// 2991 	/*if (sensors & INV_XYZ_GYRO )
// 2992 	send_packet(PACKET_TYPE_GYRO, gyro);
// 2993 	if (sensors & INV_XYZ_ACCEL)
// 2994 	send_packet(PACKET_TYPE_ACCEL, accel); */
// 2995 	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
// 2996 	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
// 2997 	**/
// 2998 	if(sensors&INV_WXYZ_QUAT) 
??mpu_dmp_get_data_0:
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x1
        JNZ     $+5
        LJMP    ??mpu_dmp_get_data_2 & 0xFFFF
// 2999 	{
// 3000 		q0 = quat[0] / q30;	//q30¸ñÊ½×ª»»Îª¸¡µãÊý
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_30800000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3001 		q1 = quat[1] / q30;
        MOV     A,#0x1f
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_30800000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3002 		q2 = quat[2] / q30;
        MOV     A,#0x23
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_30800000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3003 		q3 = quat[3] / q30; 
        MOV     A,#0x27
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_30800000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3004 		//¼ÆËãµÃµ½¸©Ñö½Ç/ºá¹ö½Ç/º½Ïò½Ç
// 3005 		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_40000000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 12
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_c0000000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        ; Setup parameters for call to function asin
        MOV     ?V0 + 0,?V0 + 12
        MOV     ?V0 + 1,?V0 + 13
        MOV     ?V0 + 2,?V0 + 14
        MOV     ?V0 + 3,?V0 + 15
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        PUSH    ?V0 + 0
        CFI CFA_SP SP+-1
        PUSH    ?V0 + 1
        CFI CFA_SP SP+-2
        PUSH    ?V0 + 2
        CFI CFA_SP SP+-3
        PUSH    ?V0 + 3
        CFI CFA_SP SP+-4
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
        MOV     ?V0 + 2,?V0 + 6
        MOV     ?V0 + 3,?V0 + 7
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        POP     ?V0 + 11
        CFI CFA_SP SP+-3
        POP     ?V0 + 10
        CFI CFA_SP SP+-2
        POP     ?V0 + 9
        CFI CFA_SP SP+-1
        POP     ?V0 + 8
        CFI CFA_SP SP+0
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_ADD
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        LCALL   ??asin?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     DPTR,#__Constant_42653333
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3006 		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_40000000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        ; Setup parameters for call to function atan2
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        PUSH    ?V0 + 12
        CFI CFA_SP SP+-1
        PUSH    ?V0 + 13
        CFI CFA_SP SP+-2
        PUSH    ?V0 + 14
        CFI CFA_SP SP+-3
        PUSH    ?V0 + 15
        CFI CFA_SP SP+-4
        MOV     ?V0 + 0,?V0 + 8
        MOV     ?V0 + 1,?V0 + 9
        MOV     ?V0 + 2,?V0 + 10
        MOV     ?V0 + 3,?V0 + 11
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 12
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 12
        LCALL   ?FLT_MUL
        POP     ?V0 + 15
        CFI CFA_SP SP+-3
        POP     ?V0 + 14
        CFI CFA_SP SP+-2
        POP     ?V0 + 13
        CFI CFA_SP SP+-1
        POP     ?V0 + 12
        CFI CFA_SP SP+0
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_SUB
        MOV     DPTR,#__Constant_3f800000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_ADD
        MOV     R0,#?V0 + 12
        LCALL   ?PUSH_XSTACK_I_FOUR
        CFI CFA_XSP16 add(XSP16, 83)
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_ADD
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        LCALL   ??atan2?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 79)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     DPTR,#__Constant_42653333
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3007 		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
        ; Setup parameters for call to function atan2
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_ADD
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_SUB
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_SUB
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_FOUR
        CFI CFA_XSP16 add(XSP16, 83)
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_ADD
        MOV     DPTR,#__Constant_40000000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        LCALL   ??atan2?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 79)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     DPTR,#__Constant_42653333
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x4f
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3008 	}else return 2;
// 3009 	return 0;
        MOV     R1,#0x0
        SJMP    ??mpu_dmp_get_data_1
??mpu_dmp_get_data_2:
        MOV     R1,#0x2
??mpu_dmp_get_data_1:
        MOV     A,#0x37
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock51
// 3010 }

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for st>`:
        DATA16
        DW reg
        DW hw
        DATA8
        DB 0
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0
        DATA16
        DW test

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for gyro_orientation>`:
        DATA8
        DB 1
        DB 0
        DB 0
        DB 0
        DB 1
        DB 0
        DB 0
        DB 0
        DB 1

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??set_int_enable?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    set_int_enable

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_reg_dump?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_reg_dump

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_read_reg?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_read_reg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_init?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_lp_accel_mode?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_lp_accel_mode

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_gyro_reg?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_gyro_reg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_accel_reg?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_accel_reg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_temperature?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_temperature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_accel_bias?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_accel_bias

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_reset_fifo?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_reset_fifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_gyro_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_gyro_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_gyro_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_gyro_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_accel_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_accel_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_accel_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_accel_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_lpf?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_lpf

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_lpf?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_lpf

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_sample_rate?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_sample_rate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_sample_rate?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_sample_rate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_compass_sample_rate?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_compass_sample_rate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_compass_sample_rate?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_compass_sample_rate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_gyro_sens?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_gyro_sens

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_accel_sens?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_accel_sens

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_fifo_config?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_fifo_config

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_configure_fifo?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_configure_fifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_power_state?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_power_state

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_sensors?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_sensors

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_int_status?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_int_status

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_read_fifo?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_read_fifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_read_fifo_stream?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_read_fifo_stream

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_bypass?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_bypass

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_int_level?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_int_level

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_int_latched?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_int_latched

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??get_accel_prod_shift?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    get_accel_prod_shift

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??accel_self_test?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    accel_self_test

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gyro_self_test?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    gyro_self_test

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??get_st_biases?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    get_st_biases

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_run_self_test?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_run_self_test

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_write_mem?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_write_mem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_read_mem?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_read_mem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_load_firmware?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_load_firmware

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_dmp_state?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_dmp_state

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_dmp_state?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_dmp_state

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??setup_compass?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    setup_compass

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_compass_reg?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_compass_reg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_compass_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_compass_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_lp_motion_interrupt?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_lp_motion_interrupt

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??run_self_test?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    run_self_test

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??inv_orientation_matrix_to_scalar?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    inv_orientation_matrix_to_scalar

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??inv_row_2_scale?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    inv_row_2_scale

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mget_ms?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mget_ms

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_dmp_init?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_dmp_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_dmp_get_data?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_dmp_get_data

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant "%#5x: %#5x\\r\\n">`:
        DB "%#5x: %#5x\015\012"

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant "Unsupported software ...">`:
        DB "Unsupported software product rev %d.\012"

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant "Product ID read as 0 ...">`:
        DB 50H, 72H, 6FH, 64H, 75H, 63H, 74H, 20H
        DB 49H, 44H, 20H, 72H, 65H, 61H, 64H, 20H
        DB 61H, 73H, 20H, 30H, 20H, 69H, 6EH, 64H
        DB 69H, 63H, 61H, 74H, 65H, 73H, 20H, 64H
        DB 65H, 76H, 69H, 63H, 65H, 20H, 69H, 73H
        DB 20H, 65H, 69H, 74H, 68H, 65H, 72H, 20H
        DB 69H, 6EH, 63H, 6FH, 6DH, 70H, 61H, 74H
        DB 69H, 62H, 6CH, 65H, 20H, 6FH, 72H, 20H
        DB 61H, 6EH, 20H, 4DH, 50H, 55H, 33H, 30H
        DB 35H, 30H, 2EH, 0AH, 0

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant "Half sensitivity part...">`:
        DB "Half sensitivity part found.\012"

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_64:
        DD 100

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_420c0000:
        DD 420C0000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_47800000:
        DD 47800000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_32:
        DD 50

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_43030000:
        DD 43030000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_42830000:
        DD 42830000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_42033333:
        DD 42033333H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_41833333:
        DD 41833333H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3:
        DD 3

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3f845a1d:
        DD 3F845A1DH

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_0:
        DD 0H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3eae147b:
        DD 3EAE147BH

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3e99999a:
        DD 3E99999AH

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3f733334:
        DD 3F733334H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_37800000:
        DD 37800000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_bf800000:
        DD 0BF800000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3e0f5c2a:
        DD 3E0F5C2AH

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_41200000:
        DD 41200000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_42d20001:
        DD 42D20001H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_41c80000:
        DD 41C80000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3f85e354:
        DD 3F85E354H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_c8:
        DD 200

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_f:
        DD 15

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_83:
        DD 131

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_1:
        DD 1

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_ffff0000:
        DD -65536

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_10000:
        DD 65536

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_5:
        DD 5

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_30800000:
        DD 30800000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_40000000:
        DD 40000000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_c0000000:
        DD 0C0000000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_42653333:
        DD 42653333H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3f800000:
        DD 3F800000H

        END
// 3011 
// 3012 
// 3013 
// 3014 
// 3015 
// 3016 
// 3017 
// 3018 
// 3019 
// 3020 
// 3021 
// 3022 
// 3023 
// 3024 
// 3025 
// 3026 
// 3027 
// 3028 
// 3029 
// 3030 
// 3031 
// 3032 
// 
// 13 618 bytes in segment BANKED_CODE
//    312 bytes in segment BANK_RELAYS
//     44 bytes in segment XDATA_I
//     44 bytes in segment XDATA_ID
//    366 bytes in segment XDATA_ROM_C
// 
// 13 974 bytes of CODE  memory
//    234 bytes of CONST memory (+ 132 bytes shared)
//     44 bytes of XDATA memory
//
//Errors: none
//Warnings: none
