###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         02/Jan/2020  15:18:22 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ\ #
#                          µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                 #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Components\HARDWARE\MPU6050\eMP #
#                          L\inv_mpu.c                                        #
#    Command line       =  -f "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé× #
#                          °ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7             #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"  #
#                          (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS) -f    #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg" #
#                           (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR     #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFF11                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE      #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Components\HARDWARE\MPU6050\eMP #
#                          L\inv_mpu.c" -D NWK_AUTO_POLL -D ZTOOL_P1 -D       #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé #
#                          ×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7            #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB-TeHu\List\" -lA            #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB-TeHu\List\"                #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB-TeHu\Obj\" -e --no_unroll  #
#                          --no_inline --no_tbaa --debug --core=plain         #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\OuYangDong\Project\ÊµÑ #
#                          éÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµ #
#                          ÄÊµÑé\3.7 ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Sampl #
#                          es\SampleApp\CC2530DB\" -I                         #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\SOURCE\" -I                         #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I           #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I      #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\ #
#                          " -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑ #
#                          é×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7           #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\C #
#                          C2530EB\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍ #
#                          øÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7   #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCS #
#                          OC\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏ #
#                          ÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7        #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE #
#                          \" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµ #
#                          Ñé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7          #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\"   #
#                          -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé× #
#                          °ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7             #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\"  #
#                          -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé× #
#                          °ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7             #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\"  #
#                          -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé× #
#                          °ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7             #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\" #
#                           -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé #
#                          ×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7            #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\"  #
#                          -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé× #
#                          °ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7             #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\"  #
#                          -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé× #
#                          °ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7             #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\"   #
#                          -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé× #
#                          °ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7             #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I    #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SAD #
#                          DR\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏ #
#                          ÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7        #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDA #
#                          TA\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏ #
#                          ÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7        #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\ #
#                          " -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑ #
#                          é×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7           #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEV #
#                          EL\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏ #
#                          ÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7        #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVE #
#                          L\srf04\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍ #
#                          øÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7   #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVE #
#                          L\srf04\SINGLE_CHIP\" -I                           #
#                          "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ #
#                          \µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\HARDWARE\"   #
#                          -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé× #
#                          °ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7             #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\HARDWARE\MPU #
#                          6050\" -I "D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚ #
#                          ºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7      #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\HARDWARE\MPU #
#                          6050\eMPL\" -Om                                    #
#    List file          =  D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ\ #
#                          µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                 #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB-TeHu\List\inv_mpu.lst      #
#    Object file        =  D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ\ #
#                          µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7                 #
#                          ZigBee¹ã²¥Í¨ÐÅÊµÑé\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB-TeHu\Obj\inv_mpu.r51       #
#                                                                             #
#                                                                             #
###############################################################################

D:\OuYangDong\Project\ÊµÑéÏä½¨Éè\¶àÍøÈÚºÏÊµÑé×°ÖÃ\µÚÈýÕÂ¡¢»ùÓÚÎÞÏß´«¸ÐÍøÂçµÄÊµÑé\3.7 ZigBee¹ã²¥Í¨ÐÅÊµÑé\Components\HARDWARE\MPU6050\eMPL\inv_mpu.c
      1          /*
      2           $License:
      3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
      4              See included License.txt for License information.
      5           $
      6           */
      7          /**
      8           *  @addtogroup  DRIVERS Sensor Driver Layer
      9           *  @brief       Hardware drivers to communicate with sensors via I2C.
     10           *
     11           *  @{
     12           *      @file       inv_mpu.c
     13           *      @brief      An I2C-based driver for Invensense gyroscopes.
     14           *      @details    This driver currently works for the following devices:
     15           *                  MPU6050
     16           *                  MPU6500
     17           *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
     18           *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
     19           */
     20          #include <stdio.h>
     21          //#include <stdint.h>
     22          #include <stdlib.h>
     23          #include <string.h>
     24          #include <math.h>
     25          #include "inv_mpu.h"
     26          #include "inv_mpu_dmp_motion_driver.h"
     27          #include "mpu6050.h"
     28          #include "delay.h"
     29          
     30          #define MPU6050					//¶¨ÒåÎÒÃÇÊ¹ÓÃµÄ´«¸ÐÆ÷ÎªMPU6050
     31          #define MOTION_DRIVER_TARGET_MSP430		//¶¨ÒåÇý¶¯²¿·Ö,²ÉÓÃMSP430µÄÇý¶¯(ÒÆÖ²µ½STM32F1)
     32          
     33          /* The following functions must be defined for this platform:
     34           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
     35           *      unsigned char length, unsigned char const *data)
     36           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
     37           *      unsigned char length, unsigned char *data)
     38           * delay_ms(unsigned long num_ms)
     39           * get_ms(unsigned long *count)
     40           * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
     41           * labs(long x)
     42           * fabsf(float x)
     43           * min(int a, int b)
     44           */
     45          #if defined MOTION_DRIVER_TARGET_MSP430
     46          //#include "msp430.h"
     47          //#include "msp430_i2c.h"
     48          //#include "msp430_clock.h"
     49          //#include "msp430_interrupt.h"
     50          
     51          #define i2c_write   MPU_Write_Len
     52          #define i2c_read    MPU_Read_Len
     53          #define delay_ms    delay_ms
     54          #define get_ms      mget_ms
     55          //static inline int reg_int_cb(struct int_param_s *int_param)
     56          //{
     57          //    return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
     58          //        int_param->active_low);
     59          //}
     60          #define log_i 	printf	//´òÓ¡ÐÅÏ¢
     61          #define log_e  	printf	//´òÓ¡ÐÅÏ¢
     62          /* labs is already defined by TI's toolchain. */
     63          /* fabs is for doubles. fabsf is for floats. */
     64          //#define fabs  fabsf
     65          #define min(a,b) ((a<b)?a:b)
     66          #elif defined EMPL_TARGET_MSP430
     67          #include "msp430.h"
     68          #include "msp430_i2c.h"
     69          #include "msp430_clock.h"
     70          #include "msp430_interrupt.h"
     71          #include "log.h"
     72          #define i2c_write   msp430_i2c_write
     73          #define i2c_read    msp430_i2c_read
     74          #define delay_ms    msp430_delay_ms
     75          #define get_ms      msp430_get_clock_ms
     76          static inline int reg_int_cb(struct int_param_s *int_param)
     77          {
     78              return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
     79                  int_param->active_low);
     80          }
     81          #define log_i       MPL_LOGI
     82          #define log_e       MPL_LOGE
     83          /* labs is already defined by TI's toolchain. */
     84          /* fabs is for doubles. fabsf is for floats. */
     85          #define fabs   fabsf
     86          #define min(a,b) ((a<b)?a:b)
     87          #elif defined EMPL_TARGET_UC3L0
     88          /* Instead of using the standard TWI driver from the ASF library, we're using
     89           * a TWI driver that follows the slave address + register address convention.
     90           */
     91          #include "twi.h"
     92          #include "delay.h"
     93          #include "sysclk.h"
     94          #include "log.h"
     95          #include "sensors_xplained.h"
     96          #include "uc3l0_clock.h"
     97          #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
     98          #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
     99          /* delay_ms is a function already defined in ASF. */
    100          #define get_ms  uc3l0_get_clock_ms
    101          static inline int reg_int_cb(struct int_param_s *int_param)
    102          {
    103              sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
    104              return 0;
    105          }
    106          #define log_i       MPL_LOGI
    107          #define log_e       MPL_LOGE
    108          /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
    109          #define labs        abs
    110          #define fabs(x)     (((x)>0)?(x):-(x))
    111          #else
    112          #error  Gyro driver is missing the system layer implementations.
    113          #endif
    114          
    115          #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
    116          #error  Which gyro are you using? Define MPUxxxx in your compiler options.
    117          #endif
    118          
    119          /* Time for some messy macro work. =]
    120           * #define MPU9150
    121           * is equivalent to..
    122           * #define MPU6050
    123           * #define AK8975_SECONDARY
    124           *
    125           * #define MPU9250
    126           * is equivalent to..
    127           * #define MPU6500
    128           * #define AK8963_SECONDARY
    129           */
    130          #if defined MPU9150
    131          #ifndef MPU6050
    132          #define MPU6050
    133          #endif                          /* #ifndef MPU6050 */
    134          #if defined AK8963_SECONDARY
    135          #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
    136          #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
    137          #define AK8975_SECONDARY
    138          #endif                          /* #if defined AK8963_SECONDARY */
    139          #elif defined MPU9250           /* #if defined MPU9150 */
    140          #ifndef MPU6500
    141          #define MPU6500
    142          #endif                          /* #ifndef MPU6500 */
    143          #if defined AK8975_SECONDARY
    144          #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
    145          #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
    146          #define AK8963_SECONDARY
    147          #endif                          /* #if defined AK8975_SECONDARY */
    148          #endif                          /* #if defined MPU9150 */
    149          
    150          #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
    151          #define AK89xx_SECONDARY
    152          #else
    153          /* #warning "No compass = less profit for Invensense. Lame." */
    154          #endif
    155          
    156          static int set_int_enable(unsigned char enable);
    157          
    158          /* Hardware registers needed by driver. */
    159          struct gyro_reg_s {
    160              unsigned char who_am_i;
    161              unsigned char rate_div;
    162              unsigned char lpf;
    163              unsigned char prod_id;
    164              unsigned char user_ctrl;
    165              unsigned char fifo_en;
    166              unsigned char gyro_cfg;
    167              unsigned char accel_cfg;
    168          //    unsigned char accel_cfg2;
    169          //    unsigned char lp_accel_odr;
    170              unsigned char motion_thr;
    171              unsigned char motion_dur;
    172              unsigned char fifo_count_h;
    173              unsigned char fifo_r_w;
    174              unsigned char raw_gyro;
    175              unsigned char raw_accel;
    176              unsigned char temp;
    177              unsigned char int_enable;
    178              unsigned char dmp_int_status;
    179              unsigned char int_status;
    180          //    unsigned char accel_intel;
    181              unsigned char pwr_mgmt_1;
    182              unsigned char pwr_mgmt_2;
    183              unsigned char int_pin_cfg;
    184              unsigned char mem_r_w;
    185              unsigned char accel_offs;
    186              unsigned char i2c_mst;
    187              unsigned char bank_sel;
    188              unsigned char mem_start_addr;
    189              unsigned char prgm_start_h;
    190          #if defined AK89xx_SECONDARY
    191              unsigned char s0_addr;
    192              unsigned char s0_reg;
    193              unsigned char s0_ctrl;
    194              unsigned char s1_addr;
    195              unsigned char s1_reg;
    196              unsigned char s1_ctrl;
    197              unsigned char s4_ctrl;
    198              unsigned char s0_do;
    199              unsigned char s1_do;
    200              unsigned char i2c_delay_ctrl;
    201              unsigned char raw_compass;
    202              /* The I2C_MST_VDDIO bit is in this register. */
    203              unsigned char yg_offs_tc;
    204          #endif
    205          };
    206          
    207          /* Information specific to a particular device. */
    208          struct hw_s {
    209              unsigned char addr;
    210              unsigned short max_fifo;
    211              unsigned char num_reg;
    212              unsigned short temp_sens;
    213              short temp_offset;
    214              unsigned short bank_size;
    215          #if defined AK89xx_SECONDARY
    216              unsigned short compass_fsr;
    217          #endif
    218          };
    219          
    220          /* When entering motion interrupt mode, the driver keeps track of the
    221           * previous state so that it can be restored at a later time.
    222           * TODO: This is tacky. Fix it.
    223           */
    224          struct motion_int_cache_s {
    225              unsigned short gyro_fsr;
    226              unsigned char accel_fsr;
    227              unsigned short lpf;
    228              unsigned short sample_rate;
    229              unsigned char sensors_on;
    230              unsigned char fifo_sensors;
    231              unsigned char dmp_on;
    232          };
    233          
    234          /* Cached chip configuration data.
    235           * TODO: A lot of these can be handled with a bitmask.
    236           */
    237          struct chip_cfg_s {
    238              /* Matches gyro_cfg >> 3 & 0x03 */
    239              unsigned char gyro_fsr;
    240              /* Matches accel_cfg >> 3 & 0x03 */
    241              unsigned char accel_fsr;
    242              /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
    243              unsigned char sensors;
    244              /* Matches config register. */
    245              unsigned char lpf;
    246              unsigned char clk_src;
    247              /* Sample rate, NOT rate divider. */
    248              unsigned short sample_rate;
    249              /* Matches fifo_en register. */
    250              unsigned char fifo_enable;
    251              /* Matches int enable register. */
    252              unsigned char int_enable;
    253              /* 1 if devices on auxiliary I2C bus appear on the primary. */
    254              unsigned char bypass_mode;
    255              /* 1 if half-sensitivity.
    256               * NOTE: This doesn't belong here, but everything else in hw_s is const,
    257               * and this allows us to save some precious RAM.
    258               */
    259              unsigned char accel_half;
    260              /* 1 if device in low-power accel-only mode. */
    261              unsigned char lp_accel_mode;
    262              /* 1 if interrupts are only triggered on motion events. */
    263              unsigned char int_motion_only;
    264              struct motion_int_cache_s cache;
    265              /* 1 for active low interrupts. */
    266              unsigned char active_low_int;
    267              /* 1 for latched interrupts. */
    268              unsigned char latched_int;
    269              /* 1 if DMP is enabled. */
    270              unsigned char dmp_on;
    271              /* Ensures that DMP will only be loaded once. */
    272              unsigned char dmp_loaded;
    273              /* Sampling rate used when DMP is enabled. */
    274              unsigned short dmp_sample_rate;
    275          #ifdef AK89xx_SECONDARY
    276              /* Compass sample rate. */
    277              unsigned short compass_sample_rate;
    278              unsigned char compass_addr;
    279              short mag_sens_adj[3];
    280          #endif
    281          };
    282          
    283          /* Information for self-test. */
    284          struct test_s {
    285              unsigned long gyro_sens;
    286              unsigned long accel_sens;
    287              unsigned char reg_rate_div;
    288              unsigned char reg_lpf;
    289              unsigned char reg_gyro_fsr;
    290              unsigned char reg_accel_fsr;
    291              unsigned short wait_ms;
    292              unsigned char packet_thresh;
    293              float min_dps;
    294              float max_dps;
    295              float max_gyro_var;
    296              float min_g;
    297              float max_g;
    298              float max_accel_var;
    299          };
    300          
    301          /* Gyro driver state variables. */
    302          struct gyro_state_s {
    303              const struct gyro_reg_s *reg;
    304              const struct hw_s *hw;
    305              struct chip_cfg_s chip_cfg;
    306              const struct test_s *test;
    307          };
    308          
    309          /* Filter configurations. */
    310          enum lpf_e {
    311              INV_FILTER_256HZ_NOLPF2 = 0,
    312              INV_FILTER_188HZ,
    313              INV_FILTER_98HZ,
    314              INV_FILTER_42HZ,
    315              INV_FILTER_20HZ,
    316              INV_FILTER_10HZ,
    317              INV_FILTER_5HZ,
    318              INV_FILTER_2100HZ_NOLPF,
    319              NUM_FILTER
    320          };
    321          
    322          /* Full scale ranges. */
    323          enum gyro_fsr_e {
    324              INV_FSR_250DPS = 0,
    325              INV_FSR_500DPS,
    326              INV_FSR_1000DPS,
    327              INV_FSR_2000DPS,
    328              NUM_GYRO_FSR
    329          };
    330          
    331          /* Full scale ranges. */
    332          enum accel_fsr_e {
    333              INV_FSR_2G = 0,
    334              INV_FSR_4G,
    335              INV_FSR_8G,
    336              INV_FSR_16G,
    337              NUM_ACCEL_FSR
    338          };
    339          
    340          /* Clock sources. */
    341          enum clock_sel_e {
    342              INV_CLK_INTERNAL = 0,
    343              INV_CLK_PLL,
    344              NUM_CLK
    345          };
    346          
    347          /* Low-power accel wakeup rates. */
    348          enum lp_accel_rate_e {
    349          #if defined MPU6050
    350              INV_LPA_1_25HZ,
    351              INV_LPA_5HZ,
    352              INV_LPA_20HZ,
    353              INV_LPA_40HZ
    354          #elif defined MPU6500
    355              INV_LPA_0_3125HZ,
    356              INV_LPA_0_625HZ,
    357              INV_LPA_1_25HZ,
    358              INV_LPA_2_5HZ,
    359              INV_LPA_5HZ,
    360              INV_LPA_10HZ,
    361              INV_LPA_20HZ,
    362              INV_LPA_40HZ,
    363              INV_LPA_80HZ,
    364              INV_LPA_160HZ,
    365              INV_LPA_320HZ,
    366              INV_LPA_640HZ
    367          #endif
    368          };
    369          
    370          #define BIT_I2C_MST_VDDIO   (0x80)
    371          #define BIT_FIFO_EN         (0x40)
    372          #define BIT_DMP_EN          (0x80)
    373          #define BIT_FIFO_RST        (0x04)
    374          #define BIT_DMP_RST         (0x08)
    375          #define BIT_FIFO_OVERFLOW   (0x10)
    376          #define BIT_DATA_RDY_EN     (0x01)
    377          #define BIT_DMP_INT_EN      (0x02)
    378          #define BIT_MOT_INT_EN      (0x40)
    379          #define BITS_FSR            (0x18)
    380          #define BITS_LPF            (0x07)
    381          #define BITS_HPF            (0x07)
    382          #define BITS_CLK            (0x07)
    383          #define BIT_FIFO_SIZE_1024  (0x40)
    384          #define BIT_FIFO_SIZE_2048  (0x80)
    385          #define BIT_FIFO_SIZE_4096  (0xC0)
    386          #define BIT_RESET           (0x80)
    387          #define BIT_SLEEP           (0x40)
    388          #define BIT_S0_DELAY_EN     (0x01)
    389          #define BIT_S2_DELAY_EN     (0x04)
    390          #define BITS_SLAVE_LENGTH   (0x0F)
    391          #define BIT_SLAVE_BYTE_SW   (0x40)
    392          #define BIT_SLAVE_GROUP     (0x10)
    393          #define BIT_SLAVE_EN        (0x80)
    394          #define BIT_I2C_READ        (0x80)
    395          #define BITS_I2C_MASTER_DLY (0x1F)
    396          #define BIT_AUX_IF_EN       (0x20)
    397          #define BIT_ACTL            (0x80)
    398          #define BIT_LATCH_EN        (0x20)
    399          #define BIT_ANY_RD_CLR      (0x10)
    400          #define BIT_BYPASS_EN       (0x02)
    401          #define BITS_WOM_EN         (0xC0)
    402          #define BIT_LPA_CYCLE       (0x20)
    403          #define BIT_STBY_XA         (0x20)
    404          #define BIT_STBY_YA         (0x10)
    405          #define BIT_STBY_ZA         (0x08)
    406          #define BIT_STBY_XG         (0x04)
    407          #define BIT_STBY_YG         (0x02)
    408          #define BIT_STBY_ZG         (0x01)
    409          #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
    410          #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
    411          
    412          #if defined AK8975_SECONDARY
    413          #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
    414          #define AK89xx_FSR                  (9830)
    415          #elif defined AK8963_SECONDARY
    416          #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
    417          #define AK89xx_FSR                  (4915)
    418          #endif
    419          
    420          #ifdef AK89xx_SECONDARY
    421          #define AKM_REG_WHOAMI      (0x00)
    422          
    423          #define AKM_REG_ST1         (0x02)
    424          #define AKM_REG_HXL         (0x03)
    425          #define AKM_REG_ST2         (0x09)
    426          
    427          #define AKM_REG_CNTL        (0x0A)
    428          #define AKM_REG_ASTC        (0x0C)
    429          #define AKM_REG_ASAX        (0x10)
    430          #define AKM_REG_ASAY        (0x11)
    431          #define AKM_REG_ASAZ        (0x12)
    432          
    433          #define AKM_DATA_READY      (0x01)
    434          #define AKM_DATA_OVERRUN    (0x02)
    435          #define AKM_OVERFLOW        (0x80)
    436          #define AKM_DATA_ERROR      (0x40)
    437          
    438          #define AKM_BIT_SELF_TEST   (0x40)
    439          
    440          #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
    441          #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
    442          #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
    443          #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
    444          
    445          #define AKM_WHOAMI      (0x48)
    446          #endif
    447          
    448          #if defined MPU6050
    449          //const struct gyro_reg_s reg = {
    450          //    .who_am_i       = 0x75,
    451          //    .rate_div       = 0x19,
    452          //    .lpf            = 0x1A,
    453          //    .prod_id        = 0x0C,
    454          //    .user_ctrl      = 0x6A,
    455          //    .fifo_en        = 0x23,
    456          //    .gyro_cfg       = 0x1B,
    457          //    .accel_cfg      = 0x1C,
    458          //    .motion_thr     = 0x1F,
    459          //    .motion_dur     = 0x20,
    460          //    .fifo_count_h   = 0x72,
    461          //    .fifo_r_w       = 0x74,
    462          //    .raw_gyro       = 0x43,
    463          //    .raw_accel      = 0x3B,
    464          //    .temp           = 0x41,
    465          //    .int_enable     = 0x38,
    466          //    .dmp_int_status = 0x39,
    467          //    .int_status     = 0x3A,
    468          //    .pwr_mgmt_1     = 0x6B,
    469          //    .pwr_mgmt_2     = 0x6C,
    470          //    .int_pin_cfg    = 0x37,
    471          //    .mem_r_w        = 0x6F,
    472          //    .accel_offs     = 0x06,
    473          //    .i2c_mst        = 0x24,
    474          //    .bank_sel       = 0x6D,
    475          //    .mem_start_addr = 0x6E,
    476          //    .prgm_start_h   = 0x70
    477          //#ifdef AK89xx_SECONDARY
    478          //    ,.raw_compass   = 0x49,
    479          //    .yg_offs_tc     = 0x01,
    480          //    .s0_addr        = 0x25,
    481          //    .s0_reg         = 0x26,
    482          //    .s0_ctrl        = 0x27,
    483          //    .s1_addr        = 0x28,
    484          //    .s1_reg         = 0x29,
    485          //    .s1_ctrl        = 0x2A,
    486          //    .s4_ctrl        = 0x34,
    487          //    .s0_do          = 0x63,
    488          //    .s1_do          = 0x64,
    489          //    .i2c_delay_ctrl = 0x67
    490          //#endif
    491          //};

   \                                 In  segment XDATA_ROM_C, align 1
    492          const struct gyro_reg_s reg = {
   \                     reg:
   \   000000   75           DB 117
   \   000001   19           DB 25
   \   000002   1A           DB 26
   \   000003   0C           DB 12
   \   000004   6A           DB 106
   \   000005   23           DB 35
   \   000006   1B           DB 27
   \   000007   1C           DB 28
   \   000008   1F           DB 31
   \   000009   20           DB 32
   \   00000A   72           DB 114
   \   00000B   74           DB 116
   \   00000C   43           DB 67
   \   00000D   3B           DB 59
   \   00000E   41           DB 65
   \   00000F   38           DB 56
   \   000010   39           DB 57
   \   000011   3A           DB 58
   \   000012   6B           DB 107
   \   000013   6C           DB 108
   \   000014   37           DB 55
   \   000015   6F           DB 111
   \   000016   06           DB 6
   \   000017   24           DB 36
   \   000018   6D           DB 109
   \   000019   6E           DB 110
   \   00001A   70           DB 112
    493          0x75,  //who_am_i
    494          0x19,  //rate_div
    495          0x1A,  //lpf
    496          0x0C,  //prod_id
    497          0x6A,  //user_ctrl
    498          0x23,  //fifo_en
    499          0x1B,  //gyro_cfg
    500          0x1C,  //accel_cfg
    501          0x1F,  // motion_thr
    502          0x20,  // motion_dur
    503          0x72,  // fifo_count_h
    504          0x74,  // fifo_r_w
    505          0x43,  // raw_gyro
    506          0x3B,  // raw_accel
    507          0x41,  // temp
    508          0x38,  // int_enable
    509          0x39,  //  dmp_int_status
    510          0x3A,  //  int_status
    511          0x6B,  // pwr_mgmt_1
    512          0x6C,  // pwr_mgmt_2
    513          0x37,  // int_pin_cfg
    514          0x6F,  // mem_r_w
    515          0x06,  // accel_offs
    516          0x24,  // i2c_mst
    517          0x6D,  // bank_sel
    518          0x6E,  // mem_start_addr
    519          0x70   // prgm_start_h
    520          };
    521          
    522          //const struct hw_s hw = {
    523          //    .addr           = 0x68,
    524          //    .max_fifo       = 1024,
    525          //    .num_reg        = 118,
    526          //    .temp_sens      = 340,
    527          //    .temp_offset    = -521,
    528          //    .bank_size      = 256
    529          //#if defined AK89xx_SECONDARY
    530          //    ,.compass_fsr    = AK89xx_FSR
    531          //#endif
    532          //};

   \                                 In  segment XDATA_ROM_C, align 1
    533          const struct hw_s hw={
   \                     hw:
   \   000000   68           DB 104
   \   000001   0004         DW 1024
   \   000003   76           DB 118
   \   000004   5401         DW 340
   \   000006   F7FD         DW -521
   \   000008   0001         DW 256
    534            0x68,	 //addr
    535            1024,	 //max_fifo
    536            118,	 //num_reg
    537            340,	 //temp_sens
    538            -521,	 //temp_offset
    539            256	 //bank_size
    540          };
    541          
    542          //const struct test_s test = {
    543          //    .gyro_sens      = 32768/250,
    544          //    .accel_sens     = 32768/16,
    545          //    .reg_rate_div   = 0,    /* 1kHz. */
    546          //    .reg_lpf        = 1,    /* 188Hz. */
    547          //    .reg_gyro_fsr   = 0,    /* 250dps. */
    548          //    .reg_accel_fsr  = 0x18, /* 16g. */
    549          //    .wait_ms        = 50,
    550          //    .packet_thresh  = 5,    /* 5% */
    551          //    .min_dps        = 10.f,
    552          //    .max_dps        = 105.f,
    553          //    .max_gyro_var   = 0.14f,
    554          //    .min_g          = 0.3f,
    555          //    .max_g          = 0.95f,
    556          //    .max_accel_var  = 0.14f
    557          //};

   \                                 In  segment XDATA_ROM_C, align 1
    558          const struct test_s test={
   \                     test:
   \   000000   83000000     DD 131
   \   000004   00080000     DD 2048
   \   000008   00           DB 0
   \   000009   01           DB 1
   \   00000A   00           DB 0
   \   00000B   18           DB 24
   \   00000C   3200         DW 50
   \   00000E   05           DB 5
   \   00000F   00002041     DD 41200000H
   \   000013   0000D242     DD 42D20000H
   \   000017   295C0F3E     DD 3E0F5C29H
   \   00001B   9A99993E     DD 3E99999AH
   \   00001F   3333733F     DD 3F733333H
   \   000023   295C0F3E     DD 3E0F5C29H
    559          32768/250,		 //gyro_sens
    560          32768/16,		 //	accel_sens
    561          0,				 //	reg_rate_div
    562          1,				//	reg_lpf
    563          0,				 //	reg_gyro_fsr
    564          0x18,			//	reg_accel_fsr
    565          50,				//	wait_ms
    566          5,				//	packet_thresh
    567          10.0f,			 //	min_dps
    568          105.0f,			 //	max_dps
    569          0.14f,			//	max_gyro_var
    570          0.3f,		   //	min_g
    571          0.95f,		   //	max_g
    572          0.14f		   //	max_accel_var
    573          };
    574          
    575          //static struct gyro_state_s st = {
    576          //    .reg = &reg,
    577          //    .hw = &hw,
    578          //    .test = &test
    579          //};

   \                                 In  segment XDATA_I, align 1, keep-with-next
    580          static struct gyro_state_s st={
   \                     st:
   \   000000                DS 35
   \   000023                REQUIRE `?<Initializer for st>`
   \   000023                REQUIRE __INIT_XDATA_I
    581            &reg,
    582            &hw,
    583            {0},
    584            &test
    585          };
    586          
    587          
    588          #elif defined MPU6500
    589          const struct gyro_reg_s reg = {
    590              .who_am_i       = 0x75,
    591              .rate_div       = 0x19,
    592              .lpf            = 0x1A,
    593              .prod_id        = 0x0C,
    594              .user_ctrl      = 0x6A,
    595              .fifo_en        = 0x23,
    596              .gyro_cfg       = 0x1B,
    597              .accel_cfg      = 0x1C,
    598              .accel_cfg2     = 0x1D,
    599              .lp_accel_odr   = 0x1E,
    600              .motion_thr     = 0x1F,
    601              .motion_dur     = 0x20,
    602              .fifo_count_h   = 0x72,
    603              .fifo_r_w       = 0x74,
    604              .raw_gyro       = 0x43,
    605              .raw_accel      = 0x3B,
    606              .temp           = 0x41,
    607              .int_enable     = 0x38,
    608              .dmp_int_status = 0x39,
    609              .int_status     = 0x3A,
    610              .accel_intel    = 0x69,
    611              .pwr_mgmt_1     = 0x6B,
    612              .pwr_mgmt_2     = 0x6C,
    613              .int_pin_cfg    = 0x37,
    614              .mem_r_w        = 0x6F,
    615              .accel_offs     = 0x77,
    616              .i2c_mst        = 0x24,
    617              .bank_sel       = 0x6D,
    618              .mem_start_addr = 0x6E,
    619              .prgm_start_h   = 0x70
    620          #ifdef AK89xx_SECONDARY
    621              ,.raw_compass   = 0x49,
    622              .s0_addr        = 0x25,
    623              .s0_reg         = 0x26,
    624              .s0_ctrl        = 0x27,
    625              .s1_addr        = 0x28,
    626              .s1_reg         = 0x29,
    627              .s1_ctrl        = 0x2A,
    628              .s4_ctrl        = 0x34,
    629              .s0_do          = 0x63,
    630              .s1_do          = 0x64,
    631              .i2c_delay_ctrl = 0x67
    632          #endif
    633          };
    634          const struct hw_s hw = {
    635              .addr           = 0x68,
    636              .max_fifo       = 1024,
    637              .num_reg        = 128,
    638              .temp_sens      = 321,
    639              .temp_offset    = 0,
    640              .bank_size      = 256
    641          #if defined AK89xx_SECONDARY
    642              ,.compass_fsr    = AK89xx_FSR
    643          #endif
    644          };
    645          
    646          const struct test_s test = {
    647              .gyro_sens      = 32768/250,
    648              .accel_sens     = 32768/16,
    649              .reg_rate_div   = 0,    /* 1kHz. */
    650              .reg_lpf        = 1,    /* 188Hz. */
    651              .reg_gyro_fsr   = 0,    /* 250dps. */
    652              .reg_accel_fsr  = 0x18, /* 16g. */
    653              .wait_ms        = 50,
    654              .packet_thresh  = 5,    /* 5% */
    655              .min_dps        = 10.f,
    656              .max_dps        = 105.f,
    657              .max_gyro_var   = 0.14f,
    658              .min_g          = 0.3f,
    659              .max_g          = 0.95f,
    660              .max_accel_var  = 0.14f
    661          };
    662          
    663          static struct gyro_state_s st = {
    664              .reg = &reg,
    665              .hw = &hw,
    666              .test = &test
    667          };
    668          #endif
    669          
    670          #define MAX_PACKET_LENGTH (12)
    671          
    672          #ifdef AK89xx_SECONDARY
    673          static int setup_compass(void);
    674          #define MAX_COMPASS_SAMPLE_RATE (100)
    675          #endif
    676          
    677          /**
    678           *  @brief      Enable/disable data ready interrupt.
    679           *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
    680           *  interrupt is used.
    681           *  @param[in]  enable      1 to enable interrupt.
    682           *  @return     0 if successful.
    683           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    684          static int set_int_enable(unsigned char enable)
   \                     set_int_enable:
    685          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    686              unsigned char tmp;
    687          
    688              if (st.chip_cfg.dmp_on) {
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6048         JZ      ??set_int_enable_0
    689                  if (enable)
   \   000012   EE           MOV     A,R6
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   6004         JZ      ??set_int_enable_1
    690                      tmp = BIT_DMP_INT_EN;
   \   00001B   7402         MOV     A,#0x2
   \   00001D   8001         SJMP    ??set_int_enable_2
    691                  else
    692                      tmp = 0x00;
   \                     ??set_int_enable_1:
   \   00001F   E4           CLR     A
   \                     ??set_int_enable_2:
   \   000020   F0           MOVX    @DPTR,A
    693                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
   \   000021                ; Setup parameters for call to function MPU_Write_Len
   \   000021   AC82         MOV     R4,DPL
   \   000023   AD83         MOV     R5,DPH
   \   000025   7B01         MOV     R3,#0x1
   \   000027   90....       MOV     DPTR,#st
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   240F         ADD     A,#0xf
   \   00002D   F8           MOV     R0,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   3400         ADDC    A,#0x0
   \   000032   F9           MOV     R1,A
   \   000033   8882         MOV     DPL,R0
   \   000035   8983         MOV     DPH,R1
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FA           MOV     R2,A
   \   000039   90....       MOV     DPTR,#st + 2
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F583         MOV     DPH,A
   \   000042   8882         MOV     DPL,R0
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F9           MOV     R1,A
   \   000046   12....       LCALL   ??MPU_Write_Len?relay
   \   000049   E9           MOV     A,R1
   \   00004A   605D         JZ      ??set_int_enable_3
    694                      return -1;
   \                     ??set_int_enable_4:
   \   00004C   7AFF         MOV     R2,#-0x1
   \   00004E   7BFF         MOV     R3,#-0x1
   \                     ??set_int_enable_5:
   \   000050   7401         MOV     A,#0x1
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   \   000055   7F01         MOV     R7,#0x1
   \   000057   02....       LJMP    ?BANKED_LEAVE_XDATA
    695                  st.chip_cfg.int_enable = tmp;
    696              } else {
    697                  if (!st.chip_cfg.sensors)
   \                     ??set_int_enable_0:
   \   00005A   90....       MOV     DPTR,#st + 6
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   60EC         JZ      ??set_int_enable_4
    698                      return -1;
    699                  if (enable && st.chip_cfg.int_enable)
   \   000060   EE           MOV     A,R6
   \   000061   600C         JZ      ??set_int_enable_6
   \   000063   90....       MOV     DPTR,#st + 12
   \   000066   E0           MOVX    A,@DPTR
   \   000067   6006         JZ      ??set_int_enable_6
    700                      return 0;
   \                     ??set_int_enable_7:
   \   000069   7A00         MOV     R2,#0x0
   \   00006B   7B00         MOV     R3,#0x0
   \   00006D   80E1         SJMP    ??set_int_enable_5
    701                  if (enable)
   \                     ??set_int_enable_6:
   \   00006F   EE           MOV     A,R6
   \   000070   85..82       MOV     DPL,?XSP + 0
   \   000073   85..83       MOV     DPH,?XSP + 1
   \   000076   6004         JZ      ??set_int_enable_8
    702                      tmp = BIT_DATA_RDY_EN;
   \   000078   7401         MOV     A,#0x1
   \   00007A   8001         SJMP    ??set_int_enable_9
    703                  else
    704                      tmp = 0x00;
   \                     ??set_int_enable_8:
   \   00007C   E4           CLR     A
   \                     ??set_int_enable_9:
   \   00007D   F0           MOVX    @DPTR,A
    705                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
   \   00007E                ; Setup parameters for call to function MPU_Write_Len
   \   00007E   AC82         MOV     R4,DPL
   \   000080   AD83         MOV     R5,DPH
   \   000082   7B01         MOV     R3,#0x1
   \   000084   90....       MOV     DPTR,#st
   \   000087   E0           MOVX    A,@DPTR
   \   000088   240F         ADD     A,#0xf
   \   00008A   F8           MOV     R0,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   3400         ADDC    A,#0x0
   \   00008F   F9           MOV     R1,A
   \   000090   8882         MOV     DPL,R0
   \   000092   8983         MOV     DPH,R1
   \   000094   E0           MOVX    A,@DPTR
   \   000095   FA           MOV     R2,A
   \   000096   90....       MOV     DPTR,#st + 2
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   F8           MOV     R0,A
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   F583         MOV     DPH,A
   \   00009F   8882         MOV     DPL,R0
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   F9           MOV     R1,A
   \   0000A3   12....       LCALL   ??MPU_Write_Len?relay
   \   0000A6   E9           MOV     A,R1
   \   0000A7   70A3         JNZ     ??set_int_enable_4
    706                      return -1;
    707                  st.chip_cfg.int_enable = tmp;
    708              }
   \                     ??set_int_enable_3:
   \   0000A9   85..82       MOV     DPL,?XSP + 0
   \   0000AC   85..83       MOV     DPH,?XSP + 1
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   90....       MOV     DPTR,#st + 12
   \   0000B3   F0           MOVX    @DPTR,A
   \   0000B4   80B3         SJMP    ??set_int_enable_7
    709              return 0;
    710          }
    711          
    712          /**
    713           *  @brief      Register dump for testing.
    714           *  @return     0 if successful.
    715           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    716          int mpu_reg_dump(void)
   \                     mpu_reg_dump:
    717          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    718              unsigned char ii;
    719              unsigned char data;
    720          
    721              for (ii = 0; ii < st.hw->num_reg; ii++) {
   \   00000A   7E00         MOV     R6,#0x0
   \   00000C   8025         SJMP    ??mpu_reg_dump_0
    722                  if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
    723                      continue;
    724                  if (i2c_read(st.hw->addr, ii, 1, &data))
    725                      return -1;
    726                  log_i("%#5x: %#5x\r\n", ii, data);
   \                     ??mpu_reg_dump_1:
   \   00000E                ; Setup parameters for call to function printf
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 0,A
   \   000017   75..00       MOV     ?V0 + 1,#0x0
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F   8E..         MOV     ?V0 + 0,R6
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   7A..         MOV     R2,#`?<Constant "%#5x: %#5x\\r\\n">` & 0xff
   \   000028   7B..         MOV     R3,#(`?<Constant "%#5x: %#5x\\r\\n">` >> 8) & 0xff
   \   00002A   12....       LCALL   ??printf?relay
   \   00002D   7404         MOV     A,#0x4
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??mpu_reg_dump_2:
   \   000032   0E           INC     R6
   \                     ??mpu_reg_dump_0:
   \   000033   90....       MOV     DPTR,#st + 2
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F8           MOV     R0,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F9           MOV     R1,A
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FA           MOV     R2,A
   \   000044   EE           MOV     A,R6
   \   000045   C3           CLR     C
   \   000046   9A           SUBB    A,R2
   \   000047   5048         JNC     ??mpu_reg_dump_3
   \   000049   90....       MOV     DPTR,#st
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   240B         ADD     A,#0xb
   \   00004F   FA           MOV     R2,A
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   3400         ADDC    A,#0x0
   \   000054   FB           MOV     R3,A
   \   000055   8A82         MOV     DPL,R2
   \   000057   8B83         MOV     DPH,R3
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   6E           XRL     A,R6
   \   00005B   60D5         JZ      ??mpu_reg_dump_2
   \   00005D   90....       MOV     DPTR,#st
   \   000060   E0           MOVX    A,@DPTR
   \   000061   2415         ADD     A,#0x15
   \   000063   FA           MOV     R2,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   3400         ADDC    A,#0x0
   \   000068   FB           MOV     R3,A
   \   000069   8A82         MOV     DPL,R2
   \   00006B   8B83         MOV     DPH,R3
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   6E           XRL     A,R6
   \   00006F   60C1         JZ      ??mpu_reg_dump_2
   \   000071                ; Setup parameters for call to function MPU_Read_Len
   \   000071   85..82       MOV     DPL,?XSP + 0
   \   000074   85..83       MOV     DPH,?XSP + 1
   \   000077   AC82         MOV     R4,DPL
   \   000079   AD83         MOV     R5,DPH
   \   00007B   7B01         MOV     R3,#0x1
   \   00007D   EE           MOV     A,R6
   \   00007E   FA           MOV     R2,A
   \   00007F   8882         MOV     DPL,R0
   \   000081   8983         MOV     DPH,R1
   \   000083   E0           MOVX    A,@DPTR
   \   000084   F9           MOV     R1,A
   \   000085   12....       LCALL   ??MPU_Read_Len?relay
   \   000088   E9           MOV     A,R1
   \   000089   6083         JZ      ??mpu_reg_dump_1
   \   00008B   7AFF         MOV     R2,#-0x1
   \   00008D   7BFF         MOV     R3,#-0x1
   \   00008F   8004         SJMP    ??mpu_reg_dump_4
    727              }
    728              return 0;
   \                     ??mpu_reg_dump_3:
   \   000091   7A00         MOV     R2,#0x0
   \   000093   7B00         MOV     R3,#0x0
   \                     ??mpu_reg_dump_4:
   \   000095   7401         MOV     A,#0x1
   \   000097   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009A   7F02         MOV     R7,#0x2
   \   00009C   02....       LJMP    ?BANKED_LEAVE_XDATA
    729          }
    730          
    731          /**
    732           *  @brief      Read from a single register.
    733           *  NOTE: The memory and FIFO read/write registers cannot be accessed.
    734           *  @param[in]  reg     Register address.
    735           *  @param[out] data    Register data.
    736           *  @return     0 if successful.
    737           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    738          int mpu_read_reg(unsigned char reg, unsigned char *data)
   \                     mpu_read_reg:
    739          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
    740              if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
   \   00000B   90....       MOV     DPTR,#st
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   240B         ADD     A,#0xb
   \   000011   F8           MOV     R0,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   3400         ADDC    A,#0x0
   \   000016   F9           MOV     R1,A
   \   000017   8882         MOV     DPL,R0
   \   000019   8983         MOV     DPH,R1
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   6E           XRL     A,R6
   \   00001D   6014         JZ      ??mpu_read_reg_0
   \   00001F   90....       MOV     DPTR,#st
   \   000022   E0           MOVX    A,@DPTR
   \   000023   2415         ADD     A,#0x15
   \   000025   F8           MOV     R0,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   3400         ADDC    A,#0x0
   \   00002A   F9           MOV     R1,A
   \   00002B   8882         MOV     DPL,R0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6E           XRL     A,R6
   \   000031   7006         JNZ     ??mpu_read_reg_1
    741                  return -1;
   \                     ??mpu_read_reg_0:
   \   000033   7AFF         MOV     R2,#-0x1
   \   000035   7BFF         MOV     R3,#-0x1
   \   000037   8029         SJMP    ??mpu_read_reg_2
    742              if (reg >= st.hw->num_reg)
   \                     ??mpu_read_reg_1:
   \   000039   90....       MOV     DPTR,#st + 2
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   8882         MOV     DPL,R0
   \   000043   8983         MOV     DPH,R1
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   FA           MOV     R2,A
   \   00004A   EE           MOV     A,R6
   \   00004B   C3           CLR     C
   \   00004C   9A           SUBB    A,R2
   \   00004D   50E4         JNC     ??mpu_read_reg_0
    743                  return -1;
    744              return i2c_read(st.hw->addr, reg, 1, data);
   \   00004F                ; Setup parameters for call to function MPU_Read_Len
   \   00004F   7B01         MOV     R3,#0x1
   \   000051   EE           MOV     A,R6
   \   000052   FA           MOV     R2,A
   \   000053   8882         MOV     DPL,R0
   \   000055   8983         MOV     DPH,R1
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F9           MOV     R1,A
   \   000059   12....       LCALL   ??MPU_Read_Len?relay
   \   00005C   89..         MOV     ?V0 + 0,R1
   \   00005E   AA..         MOV     R2,?V0 + 0
   \   000060   7B00         MOV     R3,#0x0
   \                     ??mpu_read_reg_2:
   \   000062   7F01         MOV     R7,#0x1
   \   000064   02....       LJMP    ?BANKED_LEAVE_XDATA
    745          }
    746          
    747          /**
    748           *  @brief      Initialize hardware.
    749           *  Initial configuration:\n
    750           *  Gyro FSR: +/- 2000DPS\n
    751           *  Accel FSR +/- 2G\n
    752           *  DLPF: 42Hz\n
    753           *  FIFO rate: 50Hz\n
    754           *  Clock source: Gyro PLL\n
    755           *  FIFO: Disabled.\n
    756           *  Data ready interrupt: Disabled, active low, unlatched.
    757           *  @param[in]  int_param   Platform-specific parameters to interrupt API.
    758           *  @return     0 if successful.
    759           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    760          int mpu_init(void)
   \                     mpu_init:
    761          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    762              unsigned char data[6], rev;
    763          
    764              /* Reset device. */
    765              data[0] = BIT_RESET;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7480         MOV     A,#-0x80
   \   000012   F0           MOVX    @DPTR,A
    766              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \   000013                ; Setup parameters for call to function MPU_Write_Len
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   7B01         MOV     R3,#0x1
   \   000019   90....       MOV     DPTR,#st
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   2412         ADD     A,#0x12
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   3400         ADDC    A,#0x0
   \   000024   F9           MOV     R1,A
   \   000025   8882         MOV     DPL,R0
   \   000027   8983         MOV     DPH,R1
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FA           MOV     R2,A
   \   00002B   90....       MOV     DPTR,#st + 2
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F583         MOV     DPH,A
   \   000034   8882         MOV     DPL,R0
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   12....       LCALL   ??MPU_Write_Len?relay
   \   00003B   E9           MOV     A,R1
   \   00003C   6007         JZ      ??mpu_init_0
    767                  return -1;
   \                     ??mpu_init_1:
   \   00003E   7AFF         MOV     R2,#-0x1
   \   000040   7BFF         MOV     R3,#-0x1
   \   000042   02....       LJMP    ??mpu_init_2 & 0xFFFF
    768              delay_ms(100);
   \                     ??mpu_init_0:
   \   000045                ; Setup parameters for call to function delay_ms
   \   000045   90....       MOV     DPTR,#__Constant_64
   \   000048   12....       LCALL   ?XLOAD_R2345
   \   00004B   12....       LCALL   ??delay_ms?relay
    769          
    770              /* Wake up chip. */
    771              data[0] = 0x00;
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   E4           CLR     A
   \   000055   F0           MOVX    @DPTR,A
    772              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \   000056                ; Setup parameters for call to function MPU_Write_Len
   \   000056   AC82         MOV     R4,DPL
   \   000058   AD83         MOV     R5,DPH
   \   00005A   7B01         MOV     R3,#0x1
   \   00005C   90....       MOV     DPTR,#st
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   2412         ADD     A,#0x12
   \   000062   F8           MOV     R0,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   3400         ADDC    A,#0x0
   \   000067   F9           MOV     R1,A
   \   000068   8882         MOV     DPL,R0
   \   00006A   8983         MOV     DPH,R1
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   FA           MOV     R2,A
   \   00006E   90....       MOV     DPTR,#st + 2
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F8           MOV     R0,A
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F583         MOV     DPH,A
   \   000077   8882         MOV     DPL,R0
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   F9           MOV     R1,A
   \   00007B   12....       LCALL   ??MPU_Write_Len?relay
   \   00007E   E9           MOV     A,R1
   \   00007F   70BD         JNZ     ??mpu_init_1
    773                  return -1;
    774          
    775          #if defined MPU6050
    776              /* Check product revision. */
    777              if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
   \   000081                ; Setup parameters for call to function MPU_Read_Len
   \   000081   85..82       MOV     DPL,?XSP + 0
   \   000084   85..83       MOV     DPH,?XSP + 1
   \   000087   AC82         MOV     R4,DPL
   \   000089   AD83         MOV     R5,DPH
   \   00008B   7B06         MOV     R3,#0x6
   \   00008D   90....       MOV     DPTR,#st
   \   000090   E0           MOVX    A,@DPTR
   \   000091   2416         ADD     A,#0x16
   \   000093   F8           MOV     R0,A
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   3400         ADDC    A,#0x0
   \   000098   F9           MOV     R1,A
   \   000099   8882         MOV     DPL,R0
   \   00009B   8983         MOV     DPH,R1
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   FA           MOV     R2,A
   \   00009F   90....       MOV     DPTR,#st + 2
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F8           MOV     R0,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   F583         MOV     DPH,A
   \   0000A8   8882         MOV     DPL,R0
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F9           MOV     R1,A
   \   0000AC   12....       LCALL   ??MPU_Read_Len?relay
   \   0000AF   E9           MOV     A,R1
   \   0000B0   708C         JNZ     ??mpu_init_1
    778                  return -1;
    779              rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
    780                  (data[1] & 0x01);
   \   0000B2   7401         MOV     A,#0x1
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000BA   E4           CLR     A
   \   0000BB   33           RLC     A
   \   0000BC   F9           MOV     R1,A
   \   0000BD   7403         MOV     A,#0x3
   \   0000BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000C5   E4           CLR     A
   \   0000C6   33           RLC     A
   \   0000C7   33           RLC     A
   \   0000C8   F8           MOV     R0,A
   \   0000C9   7405         MOV     A,#0x5
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000D1   E4           CLR     A
   \   0000D2   33           RLC     A
   \   0000D3   33           RLC     A
   \   0000D4   33           RLC     A
   \   0000D5   48           ORL     A,R0
   \   0000D6   49           ORL     A,R1
   \   0000D7   F5..         MOV     ?V0 + 0,A
    781          
    782              if (rev) {
   \   0000D9   6029         JZ      ??mpu_init_3
    783                  /* Congrats, these parts are better. */
    784                  if (rev == 1)
   \   0000DB   7401         MOV     A,#0x1
   \   0000DD   65..         XRL     A,?V0 + 0
   \   0000DF   6079         JZ      ??mpu_init_4
    785                      st.chip_cfg.accel_half = 1;
    786                  else if (rev == 2)
   \   0000E1   7402         MOV     A,#0x2
   \   0000E3   65..         XRL     A,?V0 + 0
   \   0000E5   7006         JNZ     ??mpu_init_5
    787                      st.chip_cfg.accel_half = 0;
   \                     ??mpu_init_6:
   \   0000E7   90....       MOV     DPTR,#st + 14
   \   0000EA   E4           CLR     A
   \   0000EB   8072         SJMP    ??mpu_init_7
    788                  else {
    789                      log_e("Unsupported software product rev %d.\n", rev);
   \                     ??mpu_init_5:
   \   0000ED                ; Setup parameters for call to function printf
   \   0000ED   75..00       MOV     ?V0 + 1,#0x0
   \   0000F0   78..         MOV     R0,#?V0 + 0
   \   0000F2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F5   7A..         MOV     R2,#`?<Constant "Unsupported software ...">` & 0xff
   \   0000F7   7B..         MOV     R3,#(`?<Constant "Unsupported software ...">` >> 8) & 0xff
   \   0000F9   12....       LCALL   ??printf?relay
   \   0000FC   7402         MOV     A,#0x2
   \   0000FE   12....       LCALL   ?DEALLOC_XSTACK8
    790                      return -1;
   \   000101   02....       LJMP    ??mpu_init_1 & 0xFFFF
    791                  }
    792              } else {
    793                  if (i2c_read(st.hw->addr, st.reg->prod_id, 1, data))
   \                     ??mpu_init_3:
   \   000104                ; Setup parameters for call to function MPU_Read_Len
   \   000104   85..82       MOV     DPL,?XSP + 0
   \   000107   85..83       MOV     DPH,?XSP + 1
   \   00010A   AC82         MOV     R4,DPL
   \   00010C   AD83         MOV     R5,DPH
   \   00010E   7B01         MOV     R3,#0x1
   \   000110   90....       MOV     DPTR,#st
   \   000113   E0           MOVX    A,@DPTR
   \   000114   F8           MOV     R0,A
   \   000115   A3           INC     DPTR
   \   000116   E0           MOVX    A,@DPTR
   \   000117   F583         MOV     DPH,A
   \   000119   8882         MOV     DPL,R0
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   FA           MOV     R2,A
   \   000120   90....       MOV     DPTR,#st + 2
   \   000123   E0           MOVX    A,@DPTR
   \   000124   F8           MOV     R0,A
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   F583         MOV     DPH,A
   \   000129   8882         MOV     DPL,R0
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   F9           MOV     R1,A
   \   00012D   12....       LCALL   ??MPU_Read_Len?relay
   \   000130   E9           MOV     A,R1
   \   000131   6003         JZ      $+5
   \   000133   02....       LJMP    ??mpu_init_1 & 0xFFFF
    794                      return -1;
    795                  rev = data[0] & 0x0F;
   \   000136   85..82       MOV     DPL,?XSP + 0
   \   000139   85..83       MOV     DPH,?XSP + 1
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   540F         ANL     A,#0xf
   \   00013F   F5..         MOV     ?V0 + 0,A
    796                  if (!rev) {
   \   000141   700A         JNZ     ??mpu_init_8
    797                      log_e("Product ID read as 0 indicates device is either "
    798                          "incompatible or an MPU3050.\n");
   \   000143                ; Setup parameters for call to function printf
   \   000143   7A..         MOV     R2,#`?<Constant "Product ID read as 0 ...">` & 0xff
   \   000145   7B..         MOV     R3,#(`?<Constant "Product ID read as 0 ...">` >> 8) & 0xff
   \   000147   12....       LCALL   ??printf?relay
    799                      return -1;
   \   00014A   02....       LJMP    ??mpu_init_1 & 0xFFFF
    800                  } else if (rev == 4) {
   \                     ??mpu_init_8:
   \   00014D   7404         MOV     A,#0x4
   \   00014F   65..         XRL     A,?V0 + 0
   \   000151   7094         JNZ     ??mpu_init_6
    801                      log_i("Half sensitivity part found.\n");
   \   000153                ; Setup parameters for call to function printf
   \   000153   7A..         MOV     R2,#`?<Constant "Half sensitivity part...">` & 0xff
   \   000155   7B..         MOV     R3,#(`?<Constant "Half sensitivity part...">` >> 8) & 0xff
   \   000157   12....       LCALL   ??printf?relay
    802                      st.chip_cfg.accel_half = 1;
   \                     ??mpu_init_4:
   \   00015A   90....       MOV     DPTR,#st + 14
   \   00015D   7401         MOV     A,#0x1
   \                     ??mpu_init_7:
   \   00015F   F0           MOVX    @DPTR,A
    803                  } else
    804                      st.chip_cfg.accel_half = 0;
    805              }
    806          #elif defined MPU6500
    807          #define MPU6500_MEM_REV_ADDR    (0x17)
    808              if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
    809                  return -1;
    810              if (rev == 0x1)
    811                  st.chip_cfg.accel_half = 0;
    812              else {
    813                  log_e("Unsupported software product rev %d.\n", rev);
    814                  return -1;
    815              }
    816          
    817              /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
    818               * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
    819               */
    820              data[0] = BIT_FIFO_SIZE_1024 | 0x8;
    821              if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
    822                  return -1;
    823          #endif
    824          
    825              /* Set to invalid values to ensure no I2C writes are skipped. */
    826              st.chip_cfg.sensors = 0xFF;
   \   000160   90....       MOV     DPTR,#st + 6
   \   000163   74FF         MOV     A,#-0x1
   \   000165   F0           MOVX    @DPTR,A
    827              st.chip_cfg.gyro_fsr = 0xFF;
   \   000166   90....       MOV     DPTR,#st + 4
   \   000169   F0           MOVX    @DPTR,A
    828              st.chip_cfg.accel_fsr = 0xFF;
   \   00016A   A3           INC     DPTR
   \   00016B   F0           MOVX    @DPTR,A
    829              st.chip_cfg.lpf = 0xFF;
   \   00016C   90....       MOV     DPTR,#st + 7
   \   00016F   F0           MOVX    @DPTR,A
    830              st.chip_cfg.sample_rate = 0xFFFF;
   \   000170   90....       MOV     DPTR,#st + 9
   \   000173   F0           MOVX    @DPTR,A
   \   000174   A3           INC     DPTR
   \   000175   F0           MOVX    @DPTR,A
    831              st.chip_cfg.fifo_enable = 0xFF;
   \   000176   A3           INC     DPTR
   \   000177   F0           MOVX    @DPTR,A
    832              st.chip_cfg.bypass_mode = 0xFF;
   \   000178   90....       MOV     DPTR,#st + 13
   \   00017B   F0           MOVX    @DPTR,A
    833          #ifdef AK89xx_SECONDARY
    834              st.chip_cfg.compass_sample_rate = 0xFFFF;
    835          #endif
    836              /* mpu_set_sensors always preserves this setting. */
    837              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   00017C   90....       MOV     DPTR,#st + 8
   \   00017F   7401         MOV     A,#0x1
   \   000181   F0           MOVX    @DPTR,A
    838              /* Handled in next call to mpu_set_bypass. */
    839              st.chip_cfg.active_low_int = 1;
   \   000182   90....       MOV     DPTR,#st + 27
   \   000185   F0           MOVX    @DPTR,A
    840              st.chip_cfg.latched_int = 0;
   \   000186   A3           INC     DPTR
   \   000187   E4           CLR     A
   \   000188   F0           MOVX    @DPTR,A
    841              st.chip_cfg.int_motion_only = 0;
   \   000189   90....       MOV     DPTR,#st + 16
   \   00018C   F0           MOVX    @DPTR,A
    842              st.chip_cfg.lp_accel_mode = 0;
   \   00018D   90....       MOV     DPTR,#st + 15
   \   000190   F0           MOVX    @DPTR,A
    843              memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
   \   000191                ; Setup parameters for call to function memset
   \   000191   75..0A       MOV     ?V0 + 0,#0xa
   \   000194   F5..         MOV     ?V0 + 1,A
   \   000196   78..         MOV     R0,#?V0 + 0
   \   000198   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00019B   7C00         MOV     R4,#0x0
   \   00019D   7D00         MOV     R5,#0x0
   \   00019F   7A..         MOV     R2,#(st + 17) & 0xff
   \   0001A1   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   0001A3   12....       LCALL   ??memset?relay
   \   0001A6   7402         MOV     A,#0x2
   \   0001A8   12....       LCALL   ?DEALLOC_XSTACK8
    844              st.chip_cfg.dmp_on = 0;
   \   0001AB   90....       MOV     DPTR,#st + 29
   \   0001AE   E4           CLR     A
   \   0001AF   F0           MOVX    @DPTR,A
    845              st.chip_cfg.dmp_loaded = 0;
   \   0001B0   A3           INC     DPTR
   \   0001B1   F0           MOVX    @DPTR,A
    846              st.chip_cfg.dmp_sample_rate = 0;
   \   0001B2   A3           INC     DPTR
   \   0001B3   F0           MOVX    @DPTR,A
   \   0001B4   A3           INC     DPTR
   \   0001B5   F0           MOVX    @DPTR,A
    847          
    848              if (mpu_set_gyro_fsr(2000))
   \   0001B6                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   0001B6   7AD0         MOV     R2,#-0x30
   \   0001B8   7B07         MOV     R3,#0x7
   \   0001BA   12....       LCALL   ??mpu_set_gyro_fsr?relay
   \   0001BD   8B..         MOV     ?V0 + 1,R3
   \   0001BF   EA           MOV     A,R2
   \   0001C0   45..         ORL     A,?V0 + 1
   \   0001C2   6003         JZ      $+5
   \   0001C4   02....       LJMP    ??mpu_init_1 & 0xFFFF
    849                  return -1;
    850              if (mpu_set_accel_fsr(2))
   \   0001C7                ; Setup parameters for call to function mpu_set_accel_fsr
   \   0001C7   7902         MOV     R1,#0x2
   \   0001C9   12....       LCALL   ??mpu_set_accel_fsr?relay
   \   0001CC   8B..         MOV     ?V0 + 1,R3
   \   0001CE   EA           MOV     A,R2
   \   0001CF   45..         ORL     A,?V0 + 1
   \   0001D1   6003         JZ      $+5
   \   0001D3   02....       LJMP    ??mpu_init_1 & 0xFFFF
    851                  return -1;
    852              if (mpu_set_lpf(42))
   \   0001D6                ; Setup parameters for call to function mpu_set_lpf
   \   0001D6   7A2A         MOV     R2,#0x2a
   \   0001D8   7B00         MOV     R3,#0x0
   \   0001DA   12....       LCALL   ??mpu_set_lpf?relay
   \   0001DD   8B..         MOV     ?V0 + 1,R3
   \   0001DF   EA           MOV     A,R2
   \   0001E0   45..         ORL     A,?V0 + 1
   \   0001E2   6003         JZ      $+5
   \   0001E4   02....       LJMP    ??mpu_init_1 & 0xFFFF
    853                  return -1;
    854              if (mpu_set_sample_rate(50))
   \   0001E7                ; Setup parameters for call to function mpu_set_sample_rate
   \   0001E7   7A32         MOV     R2,#0x32
   \   0001E9   7B00         MOV     R3,#0x0
   \   0001EB   12....       LCALL   ??mpu_set_sample_rate?relay
   \   0001EE   8B..         MOV     ?V0 + 1,R3
   \   0001F0   EA           MOV     A,R2
   \   0001F1   45..         ORL     A,?V0 + 1
   \   0001F3   6003         JZ      $+5
   \   0001F5   02....       LJMP    ??mpu_init_1 & 0xFFFF
    855                  return -1;
    856              if (mpu_configure_fifo(0))
   \   0001F8                ; Setup parameters for call to function mpu_configure_fifo
   \   0001F8   7900         MOV     R1,#0x0
   \   0001FA   12....       LCALL   ??mpu_configure_fifo?relay
   \   0001FD   8B..         MOV     ?V0 + 1,R3
   \   0001FF   EA           MOV     A,R2
   \   000200   45..         ORL     A,?V0 + 1
   \   000202   6003         JZ      $+5
   \   000204   02....       LJMP    ??mpu_init_1 & 0xFFFF
    857                  return -1;
    858          
    859          //    if (int_param)
    860          //        reg_int_cb(int_param);
    861          
    862          #ifdef AK89xx_SECONDARY
    863              setup_compass();
    864              if (mpu_set_compass_sample_rate(10))
    865                  return -1;
    866          #else
    867              /* Already disabled by setup_compass. */
    868              if (mpu_set_bypass(0))
   \   000207                ; Setup parameters for call to function mpu_set_bypass
   \   000207   7900         MOV     R1,#0x0
   \   000209   12....       LCALL   ??mpu_set_bypass?relay
   \   00020C   8B..         MOV     ?V0 + 1,R3
   \   00020E   EA           MOV     A,R2
   \   00020F   45..         ORL     A,?V0 + 1
   \   000211   6003         JZ      $+5
   \   000213   02....       LJMP    ??mpu_init_1 & 0xFFFF
    869                  return -1;
    870          #endif
    871          
    872              mpu_set_sensors(0);
   \   000216                ; Setup parameters for call to function mpu_set_sensors
   \   000216   7900         MOV     R1,#0x0
   \   000218   12....       LCALL   ??mpu_set_sensors?relay
    873              return 0;
   \   00021B   7A00         MOV     R2,#0x0
   \   00021D   7B00         MOV     R3,#0x0
   \                     ??mpu_init_2:
   \   00021F   7406         MOV     A,#0x6
   \   000221   12....       LCALL   ?DEALLOC_XSTACK8
   \   000224   7F02         MOV     R7,#0x2
   \   000226   02....       LJMP    ?BANKED_LEAVE_XDATA
    874          }
    875          
    876          /**
    877           *  @brief      Enter low-power accel-only mode.
    878           *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
    879           *  the accelerometer at one of the following frequencies:
    880           *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
    881           *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
    882           *  \n If the requested rate is not one listed above, the device will be set to
    883           *  the next highest rate. Requesting a rate above the maximum supported
    884           *  frequency will result in an error.
    885           *  \n To select a fractional wake-up frequency, round down the value passed to
    886           *  @e rate.
    887           *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
    888           *                          accel mode.
    889           *  @return     0 if successful.
    890           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    891          int mpu_lp_accel_mode(unsigned char rate)
   \                     mpu_lp_accel_mode:
    892          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    893              unsigned char tmp[2];
    894          
    895              if (rate > 40)
   \   00000C   C3           CLR     C
   \   00000D   9429         SUBB    A,#0x29
   \   00000F   4007         JC      ??mpu_lp_accel_mode_0
    896                  return -1;
   \                     ??mpu_lp_accel_mode_1:
   \   000011   7AFF         MOV     R2,#-0x1
   \   000013   7BFF         MOV     R3,#-0x1
   \   000015   02....       LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
    897          
    898              if (!rate) {
   \                     ??mpu_lp_accel_mode_0:
   \   000018   EE           MOV     A,R6
   \   000019   704F         JNZ     ??mpu_lp_accel_mode_3
    899                  mpu_set_int_latched(0);
   \   00001B                ; Setup parameters for call to function mpu_set_int_latched
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   12....       LCALL   ??mpu_set_int_latched?relay
    900                  tmp[0] = 0;
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   E4           CLR     A
   \   000027   F0           MOVX    @DPTR,A
    901                  tmp[1] = BIT_STBY_XYZG;
   \   000028   04           INC     A
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   7407         MOV     A,#0x7
   \   00002E   F0           MOVX    @DPTR,A
    902                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \   00002F                ; Setup parameters for call to function MPU_Write_Len
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   AC82         MOV     R4,DPL
   \   000037   AD83         MOV     R5,DPH
   \   000039   7B02         MOV     R3,#0x2
   \   00003B   90....       MOV     DPTR,#st
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   2412         ADD     A,#0x12
   \   000041   F8           MOV     R0,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   3400         ADDC    A,#0x0
   \   000046   F9           MOV     R1,A
   \   000047   8882         MOV     DPL,R0
   \   000049   8983         MOV     DPH,R1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FA           MOV     R2,A
   \   00004D   90....       MOV     DPTR,#st + 2
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F583         MOV     DPH,A
   \   000056   8882         MOV     DPL,R0
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   12....       LCALL   ??MPU_Write_Len?relay
   \   00005D   E9           MOV     A,R1
   \   00005E   70B1         JNZ     ??mpu_lp_accel_mode_1
    903                      return -1;
    904                  st.chip_cfg.lp_accel_mode = 0;
   \   000060   90....       MOV     DPTR,#st + 15
   \   000063   E4           CLR     A
   \   000064   F0           MOVX    @DPTR,A
    905                  return 0;
   \   000065   FA           MOV     R2,A
   \   000066   FB           MOV     R3,A
   \   000067   02....       LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
    906              }
    907              /* For LP accel, we automatically configure the hardware to produce latched
    908               * interrupts. In LP accel mode, the hardware cycles into sleep mode before
    909               * it gets a chance to deassert the interrupt pin; therefore, we shift this
    910               * responsibility over to the MCU.
    911               *
    912               * Any register read will clear the interrupt.
    913               */
    914              mpu_set_int_latched(1);
   \                     ??mpu_lp_accel_mode_3:
   \   00006A                ; Setup parameters for call to function mpu_set_int_latched
   \   00006A   7901         MOV     R1,#0x1
   \   00006C   12....       LCALL   ??mpu_set_int_latched?relay
    915          #if defined MPU6050
    916              tmp[0] = BIT_LPA_CYCLE;
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   7420         MOV     A,#0x20
   \   000077   F0           MOVX    @DPTR,A
    917              if (rate == 1) {
   \   000078   7401         MOV     A,#0x1
   \   00007A   6E           XRL     A,R6
   \   00007B   700C         JNZ     ??mpu_lp_accel_mode_4
    918                  tmp[1] = INV_LPA_1_25HZ;
   \   00007D   7401         MOV     A,#0x1
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   E4           CLR     A
   \   000083   F0           MOVX    @DPTR,A
    919                  mpu_set_lpf(5);
   \   000084                ; Setup parameters for call to function mpu_set_lpf
   \   000084   7A05         MOV     R2,#0x5
   \   000086   FB           MOV     R3,A
   \   000087   802E         SJMP    ??mpu_lp_accel_mode_5
    920              } else if (rate <= 5) {
   \                     ??mpu_lp_accel_mode_4:
   \   000089   EE           MOV     A,R6
   \   00008A   C3           CLR     C
   \   00008B   9406         SUBB    A,#0x6
   \   00008D   500C         JNC     ??mpu_lp_accel_mode_6
    921                  tmp[1] = INV_LPA_5HZ;
   \   00008F   7401         MOV     A,#0x1
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   7401         MOV     A,#0x1
   \   000096   F0           MOVX    @DPTR,A
    922                  mpu_set_lpf(5);
   \   000097                ; Setup parameters for call to function mpu_set_lpf
   \   000097   7A05         MOV     R2,#0x5
   \   000099   801A         SJMP    ??mpu_lp_accel_mode_7
    923              } else if (rate <= 20) {
   \                     ??mpu_lp_accel_mode_6:
   \   00009B   EE           MOV     A,R6
   \   00009C   C3           CLR     C
   \   00009D   9415         SUBB    A,#0x15
   \   00009F   7401         MOV     A,#0x1
   \   0000A1   500A         JNC     ??mpu_lp_accel_mode_8
    924                  tmp[1] = INV_LPA_20HZ;
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   F0           MOVX    @DPTR,A
    925                  mpu_set_lpf(10);
   \   0000A9                ; Setup parameters for call to function mpu_set_lpf
   \   0000A9   7A0A         MOV     R2,#0xa
   \   0000AB   8008         SJMP    ??mpu_lp_accel_mode_7
    926              } else {
    927                  tmp[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_accel_mode_8:
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   7403         MOV     A,#0x3
   \   0000B2   F0           MOVX    @DPTR,A
    928                  mpu_set_lpf(20);
   \   0000B3                ; Setup parameters for call to function mpu_set_lpf
   \   0000B3   7A14         MOV     R2,#0x14
   \                     ??mpu_lp_accel_mode_7:
   \   0000B5   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_5:
   \   0000B7   12....       LCALL   ??mpu_set_lpf?relay
    929              }
    930              tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
   \   0000BA   7401         MOV     A,#0x1
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   C4           SWAP    A
   \   0000C1   33           RLC     A
   \   0000C2   33           RLC     A
   \   0000C3   54C0         ANL     A,#0xc0
   \   0000C5   4407         ORL     A,#0x7
   \   0000C7   F0           MOVX    @DPTR,A
    931              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \   0000C8                ; Setup parameters for call to function MPU_Write_Len
   \   0000C8   85..82       MOV     DPL,?XSP + 0
   \   0000CB   85..83       MOV     DPH,?XSP + 1
   \   0000CE   AC82         MOV     R4,DPL
   \   0000D0   AD83         MOV     R5,DPH
   \   0000D2   7B02         MOV     R3,#0x2
   \   0000D4   90....       MOV     DPTR,#st
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   2412         ADD     A,#0x12
   \   0000DA   F8           MOV     R0,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   3400         ADDC    A,#0x0
   \   0000DF   F9           MOV     R1,A
   \   0000E0   8882         MOV     DPL,R0
   \   0000E2   8983         MOV     DPH,R1
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   FA           MOV     R2,A
   \   0000E6   90....       MOV     DPTR,#st + 2
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   F8           MOV     R0,A
   \   0000EB   A3           INC     DPTR
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   F583         MOV     DPH,A
   \   0000EF   8882         MOV     DPL,R0
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   F9           MOV     R1,A
   \   0000F3   12....       LCALL   ??MPU_Write_Len?relay
   \   0000F6   E9           MOV     A,R1
   \   0000F7   6003         JZ      $+5
   \   0000F9   02....       LJMP    ??mpu_lp_accel_mode_1 & 0xFFFF
    932                  return -1;
    933          #elif defined MPU6500
    934              /* Set wake frequency. */
    935              if (rate == 1)
    936                  tmp[0] = INV_LPA_1_25HZ;
    937              else if (rate == 2)
    938                  tmp[0] = INV_LPA_2_5HZ;
    939              else if (rate <= 5)
    940                  tmp[0] = INV_LPA_5HZ;
    941              else if (rate <= 10)
    942                  tmp[0] = INV_LPA_10HZ;
    943              else if (rate <= 20)
    944                  tmp[0] = INV_LPA_20HZ;
    945              else if (rate <= 40)
    946                  tmp[0] = INV_LPA_40HZ;
    947              else if (rate <= 80)
    948                  tmp[0] = INV_LPA_80HZ;
    949              else if (rate <= 160)
    950                  tmp[0] = INV_LPA_160HZ;
    951              else if (rate <= 320)
    952                  tmp[0] = INV_LPA_320HZ;
    953              else
    954                  tmp[0] = INV_LPA_640HZ;
    955              if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
    956                  return -1;
    957              tmp[0] = BIT_LPA_CYCLE;
    958              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
    959                  return -1;
    960          #endif
    961              st.chip_cfg.sensors = INV_XYZ_ACCEL;
   \   0000FC   90....       MOV     DPTR,#st + 6
   \   0000FF   7408         MOV     A,#0x8
   \   000101   F0           MOVX    @DPTR,A
    962              st.chip_cfg.clk_src = 0;
   \   000102   90....       MOV     DPTR,#st + 8
   \   000105   E4           CLR     A
   \   000106   F0           MOVX    @DPTR,A
    963              st.chip_cfg.lp_accel_mode = 1;
   \   000107   90....       MOV     DPTR,#st + 15
   \   00010A   04           INC     A
   \   00010B   F0           MOVX    @DPTR,A
    964              mpu_configure_fifo(0);
   \   00010C                ; Setup parameters for call to function mpu_configure_fifo
   \   00010C   7900         MOV     R1,#0x0
   \   00010E   12....       LCALL   ??mpu_configure_fifo?relay
    965          
    966              return 0;
   \   000111   7A00         MOV     R2,#0x0
   \   000113   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_2:
   \   000115   7402         MOV     A,#0x2
   \   000117   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011A   7F01         MOV     R7,#0x1
   \   00011C   02....       LJMP    ?BANKED_LEAVE_XDATA
    967          }
    968          
    969          /**
    970           *  @brief      Read raw gyro data directly from the registers.
    971           *  @param[out] data        Raw data in hardware units.
    972           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
    973           *  @return     0 if successful.
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_gyro_reg:
    976          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
    977              unsigned char tmp[6];
    978          
    979              if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
   \   000012   90....       MOV     DPTR,#st + 6
   \   000015   E0           MOVX    A,@DPTR
   \   000016   5470         ANL     A,#0x70
   \   000018   7007         JNZ     ??mpu_get_gyro_reg_0
    980                  return -1;
   \                     ??mpu_get_gyro_reg_1:
   \   00001A   7AFF         MOV     R2,#-0x1
   \   00001C   7BFF         MOV     R3,#-0x1
   \   00001E   02....       LJMP    ??mpu_get_gyro_reg_2 & 0xFFFF
    981          
    982              if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
   \                     ??mpu_get_gyro_reg_0:
   \   000021                ; Setup parameters for call to function MPU_Read_Len
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   AC82         MOV     R4,DPL
   \   000029   AD83         MOV     R5,DPH
   \   00002B   7B06         MOV     R3,#0x6
   \   00002D   90....       MOV     DPTR,#st
   \   000030   E0           MOVX    A,@DPTR
   \   000031   240C         ADD     A,#0xc
   \   000033   F8           MOV     R0,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   3400         ADDC    A,#0x0
   \   000038   F9           MOV     R1,A
   \   000039   8882         MOV     DPL,R0
   \   00003B   8983         MOV     DPH,R1
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   90....       MOV     DPTR,#st + 2
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F583         MOV     DPH,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F9           MOV     R1,A
   \   00004C   12....       LCALL   ??MPU_Read_Len?relay
   \   00004F   E9           MOV     A,R1
   \   000050   70C8         JNZ     ??mpu_get_gyro_reg_1
    983                  return -1;
    984              data[0] = (tmp[0] << 8) | tmp[1];
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   7401         MOV     A,#0x1
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   E9           MOV     A,R1
   \   000067   F0           MOVX    @DPTR,A
    985              data[1] = (tmp[2] << 8) | tmp[3];
   \   000068   7402         MOV     A,#0x2
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F9           MOV     R1,A
   \   00006F   7403         MOV     A,#0x3
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   8E82         MOV     DPL,R6
   \   000077   8F83         MOV     DPH,R7
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   E9           MOV     A,R1
   \   00007E   F0           MOVX    @DPTR,A
    986              data[2] = (tmp[4] << 8) | tmp[5];
   \   00007F   7404         MOV     A,#0x4
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F9           MOV     R1,A
   \   000086   7405         MOV     A,#0x5
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   8E82         MOV     DPL,R6
   \   00008E   8F83         MOV     DPH,R7
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   F0           MOVX    @DPTR,A
   \   000095   A3           INC     DPTR
   \   000096   E9           MOV     A,R1
   \   000097   F0           MOVX    @DPTR,A
    987              if (timestamp)
   \   000098   E5..         MOV     A,?V0 + 0
   \   00009A   45..         ORL     A,?V0 + 1
   \   00009C   6007         JZ      ??mpu_get_gyro_reg_3
    988                  get_ms(timestamp);
   \   00009E                ; Setup parameters for call to function mget_ms
   \   00009E   AA..         MOV     R2,?V0 + 0
   \   0000A0   AB..         MOV     R3,?V0 + 1
   \   0000A2   12....       LCALL   ??mget_ms?relay
    989              return 0;
   \                     ??mpu_get_gyro_reg_3:
   \   0000A5   7A00         MOV     R2,#0x0
   \   0000A7   7B00         MOV     R3,#0x0
   \                     ??mpu_get_gyro_reg_2:
   \   0000A9   7406         MOV     A,#0x6
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AE   7F02         MOV     R7,#0x2
   \   0000B0   02....       LJMP    ?BANKED_LEAVE_XDATA
    990          }
    991          
    992          /**
    993           *  @brief      Read raw accel data directly from the registers.
    994           *  @param[out] data        Raw data in hardware units.
    995           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
    996           *  @return     0 if successful.
    997           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    998          int mpu_get_accel_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_accel_reg:
    999          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   1000              unsigned char tmp[6];
   1001          
   1002              if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
   \   000012   90....       MOV     DPTR,#st + 6
   \   000015   E0           MOVX    A,@DPTR
   \   000016   A2E3         MOV     C,0xE0 /* A   */.3
   \   000018   4007         JC      ??mpu_get_accel_reg_0
   1003                  return -1;
   \                     ??mpu_get_accel_reg_1:
   \   00001A   7AFF         MOV     R2,#-0x1
   \   00001C   7BFF         MOV     R3,#-0x1
   \   00001E   02....       LJMP    ??mpu_get_accel_reg_2 & 0xFFFF
   1004          
   1005              if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
   \                     ??mpu_get_accel_reg_0:
   \   000021                ; Setup parameters for call to function MPU_Read_Len
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   AC82         MOV     R4,DPL
   \   000029   AD83         MOV     R5,DPH
   \   00002B   7B06         MOV     R3,#0x6
   \   00002D   90....       MOV     DPTR,#st
   \   000030   E0           MOVX    A,@DPTR
   \   000031   240D         ADD     A,#0xd
   \   000033   F8           MOV     R0,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   3400         ADDC    A,#0x0
   \   000038   F9           MOV     R1,A
   \   000039   8882         MOV     DPL,R0
   \   00003B   8983         MOV     DPH,R1
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   90....       MOV     DPTR,#st + 2
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F583         MOV     DPH,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F9           MOV     R1,A
   \   00004C   12....       LCALL   ??MPU_Read_Len?relay
   \   00004F   E9           MOV     A,R1
   \   000050   70C8         JNZ     ??mpu_get_accel_reg_1
   1006                  return -1;
   1007              data[0] = (tmp[0] << 8) | tmp[1];
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   7401         MOV     A,#0x1
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   E9           MOV     A,R1
   \   000067   F0           MOVX    @DPTR,A
   1008              data[1] = (tmp[2] << 8) | tmp[3];
   \   000068   7402         MOV     A,#0x2
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F9           MOV     R1,A
   \   00006F   7403         MOV     A,#0x3
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   8E82         MOV     DPL,R6
   \   000077   8F83         MOV     DPH,R7
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   E9           MOV     A,R1
   \   00007E   F0           MOVX    @DPTR,A
   1009              data[2] = (tmp[4] << 8) | tmp[5];
   \   00007F   7404         MOV     A,#0x4
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F9           MOV     R1,A
   \   000086   7405         MOV     A,#0x5
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   8E82         MOV     DPL,R6
   \   00008E   8F83         MOV     DPH,R7
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   F0           MOVX    @DPTR,A
   \   000095   A3           INC     DPTR
   \   000096   E9           MOV     A,R1
   \   000097   F0           MOVX    @DPTR,A
   1010              if (timestamp)
   \   000098   E5..         MOV     A,?V0 + 0
   \   00009A   45..         ORL     A,?V0 + 1
   \   00009C   6007         JZ      ??mpu_get_accel_reg_3
   1011                  get_ms(timestamp);
   \   00009E                ; Setup parameters for call to function mget_ms
   \   00009E   AA..         MOV     R2,?V0 + 0
   \   0000A0   AB..         MOV     R3,?V0 + 1
   \   0000A2   12....       LCALL   ??mget_ms?relay
   1012              return 0;
   \                     ??mpu_get_accel_reg_3:
   \   0000A5   7A00         MOV     R2,#0x0
   \   0000A7   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_reg_2:
   \   0000A9   7406         MOV     A,#0x6
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AE   7F02         MOV     R7,#0x2
   \   0000B0   02....       LJMP    ?BANKED_LEAVE_XDATA
   1013          }
   1014          
   1015          /**
   1016           *  @brief      Read temperature data directly from the registers.
   1017           *  @param[out] data        Data in q16 format.
   1018           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1019           *  @return     0 if successful.
   1020           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1021          int mpu_get_temperature(long *data, unsigned long *timestamp)
   \                     mpu_get_temperature:
   1022          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1023              unsigned char tmp[2];
   1024              short raw;
   1025          
   1026              if (!(st.chip_cfg.sensors))
   \   000012   90....       MOV     DPTR,#st + 6
   \   000015   E0           MOVX    A,@DPTR
   \   000016   7007         JNZ     ??mpu_get_temperature_0
   1027                  return -1;
   \                     ??mpu_get_temperature_1:
   \   000018   7AFF         MOV     R2,#-0x1
   \   00001A   7BFF         MOV     R3,#-0x1
   \   00001C   02....       LJMP    ??mpu_get_temperature_2 & 0xFFFF
   1028          
   1029              if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
   \                     ??mpu_get_temperature_0:
   \   00001F                ; Setup parameters for call to function MPU_Read_Len
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   AC82         MOV     R4,DPL
   \   000027   AD83         MOV     R5,DPH
   \   000029   7B02         MOV     R3,#0x2
   \   00002B   90....       MOV     DPTR,#st
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   240E         ADD     A,#0xe
   \   000031   F8           MOV     R0,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   3400         ADDC    A,#0x0
   \   000036   F9           MOV     R1,A
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FA           MOV     R2,A
   \   00003D   90....       MOV     DPTR,#st + 2
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F8           MOV     R0,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F583         MOV     DPH,A
   \   000046   8882         MOV     DPL,R0
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F9           MOV     R1,A
   \   00004A   12....       LCALL   ??MPU_Read_Len?relay
   \   00004D   E9           MOV     A,R1
   \   00004E   70C8         JNZ     ??mpu_get_temperature_1
   1030                  return -1;
   1031              raw = (tmp[0] << 8) | tmp[1];
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F9           MOV     R1,A
   \   000058   7401         MOV     A,#0x1
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F5..         MOV     ?V0 + 4,A
   \   000060   E9           MOV     A,R1
   \   000061   F5..         MOV     ?V0 + 5,A
   1032              if (timestamp)
   \   000063   EE           MOV     A,R6
   \   000064   4F           ORL     A,R7
   \   000065   6007         JZ      ??mpu_get_temperature_3
   1033                  get_ms(timestamp);
   \   000067                ; Setup parameters for call to function mget_ms
   \   000067   EE           MOV     A,R6
   \   000068   FA           MOV     R2,A
   \   000069   EF           MOV     A,R7
   \   00006A   FB           MOV     R3,A
   \   00006B   12....       LCALL   ??mget_ms?relay
   1034          
   1035              data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
   \                     ??mpu_get_temperature_3:
   \   00006E   90....       MOV     DPTR,#st + 2
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F8           MOV     R0,A
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F9           MOV     R1,A
   \   000076   E8           MOV     A,R0
   \   000077   FA           MOV     R2,A
   \   000078   E9           MOV     A,R1
   \   000079   FB           MOV     R3,A
   \   00007A   E5..         MOV     A,?V0 + 5
   \   00007C   33           RLC     A
   \   00007D   95E0         SUBB    A,0xE0 /* A   */
   \   00007F   F5..         MOV     ?V0 + 6,A
   \   000081   F5..         MOV     ?V0 + 7,A
   \   000083   78..         MOV     R0,#?V0 + 4
   \   000085   12....       LCALL   ?L_TO_FLT
   \   000088   8A82         MOV     DPL,R2
   \   00008A   8B83         MOV     DPH,R3
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   F5..         MOV     ?V0 + 8,A
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   F5..         MOV     ?V0 + 9,A
   \   000099   33           RLC     A
   \   00009A   95E0         SUBB    A,0xE0 /* A   */
   \   00009C   F5..         MOV     ?V0 + 10,A
   \   00009E   F5..         MOV     ?V0 + 11,A
   \   0000A0   78..         MOV     R0,#?V0 + 8
   \   0000A2   12....       LCALL   ?L_TO_FLT
   \   0000A5   78..         MOV     R0,#?V0 + 4
   \   0000A7   79..         MOV     R1,#?V0 + 8
   \   0000A9   12....       LCALL   ?FLT_SUB
   \   0000AC   8A82         MOV     DPL,R2
   \   0000AE   8B83         MOV     DPH,R3
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   F5..         MOV     ?V0 + 8,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F5..         MOV     ?V0 + 9,A
   \   0000BB   E4           CLR     A
   \   0000BC   F5..         MOV     ?V0 + 10,A
   \   0000BE   F5..         MOV     ?V0 + 11,A
   \   0000C0   78..         MOV     R0,#?V0 + 8
   \   0000C2   12....       LCALL   ?UL_TO_FLT
   \   0000C5   78..         MOV     R0,#?V0 + 4
   \   0000C7   79..         MOV     R1,#?V0 + 8
   \   0000C9   12....       LCALL   ?FLT_DIV
   \   0000CC   90....       MOV     DPTR,#__Constant_420c0000
   \   0000CF   78..         MOV     R0,#?V0 + 8
   \   0000D1   12....       LCALL   ?L_MOV_X
   \   0000D4   78..         MOV     R0,#?V0 + 4
   \   0000D6   79..         MOV     R1,#?V0 + 8
   \   0000D8   12....       LCALL   ?FLT_ADD
   \   0000DB   90....       MOV     DPTR,#__Constant_47800000
   \   0000DE   78..         MOV     R0,#?V0 + 8
   \   0000E0   12....       LCALL   ?L_MOV_X
   \   0000E3   78..         MOV     R0,#?V0 + 4
   \   0000E5   79..         MOV     R1,#?V0 + 8
   \   0000E7   12....       LCALL   ?FLT_MUL
   \   0000EA   78..         MOV     R0,#?V0 + 4
   \   0000EC   12....       LCALL   ?FLT_TO_L
   \   0000EF   85..82       MOV     DPL,?V0 + 0
   \   0000F2   85..83       MOV     DPH,?V0 + 1
   \   0000F5   78..         MOV     R0,#?V0 + 4
   \   0000F7   12....       LCALL   ?L_MOV_TO_X
   1036              return 0;
   \   0000FA   7A00         MOV     R2,#0x0
   \   0000FC   7B00         MOV     R3,#0x0
   \                     ??mpu_get_temperature_2:
   \   0000FE   7402         MOV     A,#0x2
   \   000100   12....       LCALL   ?DEALLOC_XSTACK8
   \   000103   7F0C         MOV     R7,#0xc
   \   000105   02....       LJMP    ?BANKED_LEAVE_XDATA
   1037          }
   1038          
   1039          /**
   1040           *  @brief      Push biases to the accel bias registers.
   1041           *  This function expects biases relative to the current sensor output, and
   1042           *  these biases will be added to the factory-supplied values.
   1043           *  @param[in]  accel_bias  New biases.
   1044           *  @return     0 if successful.
   1045           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1046          int mpu_set_accel_bias(const long *accel_bias)
   \                     mpu_set_accel_bias:
   1047          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1048              unsigned char data[6];
   1049              short accel_hw[3];
   1050              short got_accel[3];
   1051              short fg[3];
   1052          
   1053              if (!accel_bias)
   \   00000E   EE           MOV     A,R6
   \   00000F   4F           ORL     A,R7
   \   000010   700E         JNZ     ??mpu_set_accel_bias_0
   1054                  return -1;
   \                     ??mpu_set_accel_bias_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \                     ??mpu_set_accel_bias_2:
   \   000016   7418         MOV     A,#0x18
   \   000018   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001B   7F08         MOV     R7,#0x8
   \   00001D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1055              if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
   \                     ??mpu_set_accel_bias_0:
   \   000020   8E82         MOV     DPL,R6
   \   000022   8F83         MOV     DPH,R7
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?L_MOV_X
   \   000029   E5..         MOV     A,?V0 + 0
   \   00002B   45..         ORL     A,?V0 + 1
   \   00002D   45..         ORL     A,?V0 + 2
   \   00002F   45..         ORL     A,?V0 + 3
   \   000031   7038         JNZ     ??mpu_set_accel_bias_3
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   78..         MOV     R0,#?V0 + 0
   \   00003D   12....       LCALL   ?L_MOV_X
   \   000040   E5..         MOV     A,?V0 + 0
   \   000042   45..         ORL     A,?V0 + 1
   \   000044   45..         ORL     A,?V0 + 2
   \   000046   45..         ORL     A,?V0 + 3
   \   000048   7021         JNZ     ??mpu_set_accel_bias_3
   \   00004A   8E82         MOV     DPL,R6
   \   00004C   8F83         MOV     DPH,R7
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?L_MOV_X
   \   00005B   E5..         MOV     A,?V0 + 0
   \   00005D   45..         ORL     A,?V0 + 1
   \   00005F   45..         ORL     A,?V0 + 2
   \   000061   45..         ORL     A,?V0 + 3
   \   000063   7006         JNZ     ??mpu_set_accel_bias_3
   1056                  return 0;
   \                     ??mpu_set_accel_bias_4:
   \   000065   7A00         MOV     R2,#0x0
   \   000067   7B00         MOV     R3,#0x0
   \   000069   80AB         SJMP    ??mpu_set_accel_bias_2
   1057          
   1058              if (i2c_read(st.hw->addr, 3, 3, data))
   \                     ??mpu_set_accel_bias_3:
   \   00006B                ; Setup parameters for call to function MPU_Read_Len
   \   00006B   85..82       MOV     DPL,?XSP + 0
   \   00006E   85..83       MOV     DPH,?XSP + 1
   \   000071   AC82         MOV     R4,DPL
   \   000073   AD83         MOV     R5,DPH
   \   000075   7B03         MOV     R3,#0x3
   \   000077   7A03         MOV     R2,#0x3
   \   000079   90....       MOV     DPTR,#st + 2
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   F8           MOV     R0,A
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F583         MOV     DPH,A
   \   000082   8882         MOV     DPL,R0
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F9           MOV     R1,A
   \   000086   12....       LCALL   ??MPU_Read_Len?relay
   \   000089   E9           MOV     A,R1
   \   00008A   7086         JNZ     ??mpu_set_accel_bias_1
   1059                  return -1;
   1060              fg[0] = ((data[0] >> 4) + 8) & 0xf;
   \   00008C   85..82       MOV     DPL,?XSP + 0
   \   00008F   85..83       MOV     DPH,?XSP + 1
   \   000092   E0           MOVX    A,@DPTR
   \   000093   C4           SWAP    A
   \   000094   540F         ANL     A,#0xf
   \   000096   2408         ADD     A,#0x8
   \   000098   540F         ANL     A,#0xf
   \   00009A   F8           MOV     R0,A
   \   00009B   740C         MOV     A,#0xc
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   E8           MOV     A,R0
   \   0000A1   F0           MOVX    @DPTR,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   E4           CLR     A
   \   0000A4   F0           MOVX    @DPTR,A
   1061              fg[1] = ((data[1] >> 4) + 8) & 0xf;
   \   0000A5   04           INC     A
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   C4           SWAP    A
   \   0000AB   540F         ANL     A,#0xf
   \   0000AD   2408         ADD     A,#0x8
   \   0000AF   540F         ANL     A,#0xf
   \   0000B1   FC           MOV     R4,A
   \   0000B2   740E         MOV     A,#0xe
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   EC           MOV     A,R4
   \   0000B8   F0           MOVX    @DPTR,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   E4           CLR     A
   \   0000BB   F0           MOVX    @DPTR,A
   1062              fg[2] = ((data[2] >> 4) + 8) & 0xf;
   \   0000BC   7402         MOV     A,#0x2
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   C4           SWAP    A
   \   0000C3   540F         ANL     A,#0xf
   \   0000C5   2408         ADD     A,#0x8
   \   0000C7   540F         ANL     A,#0xf
   \   0000C9   FA           MOV     R2,A
   \   0000CA   7410         MOV     A,#0x10
   \   0000CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CF   EA           MOV     A,R2
   \   0000D0   F0           MOVX    @DPTR,A
   \   0000D1   A3           INC     DPTR
   \   0000D2   E4           CLR     A
   \   0000D3   F0           MOVX    @DPTR,A
   1063          
   1064              accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
   \   0000D4   8E82         MOV     DPL,R6
   \   0000D6   8F83         MOV     DPH,R7
   \   0000D8   78..         MOV     R0,#?V0 + 4
   \   0000DA   12....       LCALL   ?L_MOV_X
   \   0000DD   7401         MOV     A,#0x1
   \   0000DF   78..         MOV     R0,#?V0 + 4
   \   0000E1   12....       LCALL   ?L_SHL
   \   0000E4   740C         MOV     A,#0xc
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   2440         ADD     A,#0x40
   \   0000EC   F5..         MOV     ?V0 + 0,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   3400         ADDC    A,#0x0
   \   0000F2   F5..         MOV     ?V0 + 1,A
   \   0000F4   33           RLC     A
   \   0000F5   95E0         SUBB    A,0xE0 /* A   */
   \   0000F7   F5..         MOV     ?V0 + 2,A
   \   0000F9   F5..         MOV     ?V0 + 3,A
   \   0000FB   78..         MOV     R0,#?V0 + 4
   \   0000FD   79..         MOV     R1,#?V0 + 0
   \   0000FF   12....       LCALL   ?L_DIV_MOD
   \   000102   7406         MOV     A,#0x6
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   E5..         MOV     A,?V0 + 4
   \   000109   F0           MOVX    @DPTR,A
   \   00010A   A3           INC     DPTR
   \   00010B   E5..         MOV     A,?V0 + 5
   \   00010D   F0           MOVX    @DPTR,A
   1065              accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
   \   00010E   8E82         MOV     DPL,R6
   \   000110   8F83         MOV     DPH,R7
   \   000112   A3           INC     DPTR
   \   000113   A3           INC     DPTR
   \   000114   A3           INC     DPTR
   \   000115   A3           INC     DPTR
   \   000116   78..         MOV     R0,#?V0 + 0
   \   000118   12....       LCALL   ?L_MOV_X
   \   00011B   7401         MOV     A,#0x1
   \   00011D   78..         MOV     R0,#?V0 + 0
   \   00011F   12....       LCALL   ?L_SHL
   \   000122   EC           MOV     A,R4
   \   000123   2440         ADD     A,#0x40
   \   000125   F5..         MOV     ?V0 + 4,A
   \   000127   E4           CLR     A
   \   000128   F5..         MOV     ?V0 + 5,A
   \   00012A   F5..         MOV     ?V0 + 6,A
   \   00012C   F5..         MOV     ?V0 + 7,A
   \   00012E   78..         MOV     R0,#?V0 + 0
   \   000130   79..         MOV     R1,#?V0 + 4
   \   000132   12....       LCALL   ?L_DIV_MOD
   \   000135   7408         MOV     A,#0x8
   \   000137   12....       LCALL   ?XSTACK_DISP0_8
   \   00013A   E5..         MOV     A,?V0 + 0
   \   00013C   F0           MOVX    @DPTR,A
   \   00013D   A3           INC     DPTR
   \   00013E   E5..         MOV     A,?V0 + 1
   \   000140   F0           MOVX    @DPTR,A
   1066              accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
   \   000141   8E82         MOV     DPL,R6
   \   000143   8F83         MOV     DPH,R7
   \   000145   A3           INC     DPTR
   \   000146   A3           INC     DPTR
   \   000147   A3           INC     DPTR
   \   000148   A3           INC     DPTR
   \   000149   A3           INC     DPTR
   \   00014A   A3           INC     DPTR
   \   00014B   A3           INC     DPTR
   \   00014C   A3           INC     DPTR
   \   00014D   78..         MOV     R0,#?V0 + 0
   \   00014F   12....       LCALL   ?L_MOV_X
   \   000152   7401         MOV     A,#0x1
   \   000154   78..         MOV     R0,#?V0 + 0
   \   000156   12....       LCALL   ?L_SHL
   \   000159   EA           MOV     A,R2
   \   00015A   2440         ADD     A,#0x40
   \   00015C   F5..         MOV     ?V0 + 4,A
   \   00015E   E4           CLR     A
   \   00015F   F5..         MOV     ?V0 + 5,A
   \   000161   F5..         MOV     ?V0 + 6,A
   \   000163   F5..         MOV     ?V0 + 7,A
   \   000165   78..         MOV     R0,#?V0 + 0
   \   000167   79..         MOV     R1,#?V0 + 4
   \   000169   12....       LCALL   ?L_DIV_MOD
   \   00016C   740A         MOV     A,#0xa
   \   00016E   12....       LCALL   ?XSTACK_DISP0_8
   \   000171   E5..         MOV     A,?V0 + 0
   \   000173   F0           MOVX    @DPTR,A
   \   000174   A3           INC     DPTR
   \   000175   E5..         MOV     A,?V0 + 1
   \   000177   F0           MOVX    @DPTR,A
   1067          
   1068              if (i2c_read(st.hw->addr, 0x06, 6, data))
   \   000178                ; Setup parameters for call to function MPU_Read_Len
   \   000178   85..82       MOV     DPL,?XSP + 0
   \   00017B   85..83       MOV     DPH,?XSP + 1
   \   00017E   AC82         MOV     R4,DPL
   \   000180   AD83         MOV     R5,DPH
   \   000182   7B06         MOV     R3,#0x6
   \   000184   7A06         MOV     R2,#0x6
   \   000186   90....       MOV     DPTR,#st + 2
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   F8           MOV     R0,A
   \   00018B   A3           INC     DPTR
   \   00018C   E0           MOVX    A,@DPTR
   \   00018D   F583         MOV     DPH,A
   \   00018F   8882         MOV     DPL,R0
   \   000191   E0           MOVX    A,@DPTR
   \   000192   F9           MOV     R1,A
   \   000193   12....       LCALL   ??MPU_Read_Len?relay
   \   000196   E9           MOV     A,R1
   \   000197   6003         JZ      $+5
   \   000199   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   1069                  return -1;
   1070          
   1071              got_accel[0] = ((short)data[0] << 8) | data[1];
   \   00019C   85..82       MOV     DPL,?XSP + 0
   \   00019F   85..83       MOV     DPH,?XSP + 1
   \   0001A2   E0           MOVX    A,@DPTR
   \   0001A3   F9           MOV     R1,A
   \   0001A4   7401         MOV     A,#0x1
   \   0001A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A9   E0           MOVX    A,@DPTR
   \   0001AA   F8           MOV     R0,A
   \   0001AB   7412         MOV     A,#0x12
   \   0001AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B0   E8           MOV     A,R0
   \   0001B1   F0           MOVX    @DPTR,A
   \   0001B2   A3           INC     DPTR
   \   0001B3   E9           MOV     A,R1
   \   0001B4   F0           MOVX    @DPTR,A
   1072              got_accel[1] = ((short)data[2] << 8) | data[3];
   \   0001B5   7402         MOV     A,#0x2
   \   0001B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BA   E0           MOVX    A,@DPTR
   \   0001BB   F9           MOV     R1,A
   \   0001BC   7403         MOV     A,#0x3
   \   0001BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C1   E0           MOVX    A,@DPTR
   \   0001C2   FA           MOV     R2,A
   \   0001C3   E9           MOV     A,R1
   \   0001C4   FB           MOV     R3,A
   \   0001C5   7414         MOV     A,#0x14
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   EA           MOV     A,R2
   \   0001CB   F0           MOVX    @DPTR,A
   \   0001CC   A3           INC     DPTR
   \   0001CD   EB           MOV     A,R3
   \   0001CE   F0           MOVX    @DPTR,A
   1073              got_accel[2] = ((short)data[4] << 8) | data[5];
   \   0001CF   7404         MOV     A,#0x4
   \   0001D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D4   E0           MOVX    A,@DPTR
   \   0001D5   F9           MOV     R1,A
   \   0001D6   7405         MOV     A,#0x5
   \   0001D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DB   E0           MOVX    A,@DPTR
   \   0001DC   F8           MOV     R0,A
   \   0001DD   7416         MOV     A,#0x16
   \   0001DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E2   E8           MOV     A,R0
   \   0001E3   F0           MOVX    @DPTR,A
   \   0001E4   A3           INC     DPTR
   \   0001E5   E9           MOV     A,R1
   \   0001E6   F0           MOVX    @DPTR,A
   1074          
   1075              accel_hw[0] += got_accel[0];
   \   0001E7   7412         MOV     A,#0x12
   \   0001E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EC   E0           MOVX    A,@DPTR
   \   0001ED   FC           MOV     R4,A
   \   0001EE   A3           INC     DPTR
   \   0001EF   E0           MOVX    A,@DPTR
   \   0001F0   FD           MOV     R5,A
   \   0001F1   7406         MOV     A,#0x6
   \   0001F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F6   E0           MOVX    A,@DPTR
   \   0001F7   2C           ADD     A,R4
   \   0001F8   F0           MOVX    @DPTR,A
   \   0001F9   A3           INC     DPTR
   \   0001FA   E0           MOVX    A,@DPTR
   \   0001FB   3D           ADDC    A,R5
   \   0001FC   F0           MOVX    @DPTR,A
   1076              accel_hw[1] += got_accel[1];
   \   0001FD   7408         MOV     A,#0x8
   \   0001FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000202   E0           MOVX    A,@DPTR
   \   000203   2A           ADD     A,R2
   \   000204   F0           MOVX    @DPTR,A
   \   000205   A3           INC     DPTR
   \   000206   E0           MOVX    A,@DPTR
   \   000207   3B           ADDC    A,R3
   \   000208   F0           MOVX    @DPTR,A
   1077              accel_hw[2] += got_accel[2];
   \   000209   740A         MOV     A,#0xa
   \   00020B   12....       LCALL   ?XSTACK_DISP0_8
   \   00020E   E0           MOVX    A,@DPTR
   \   00020F   28           ADD     A,R0
   \   000210   F0           MOVX    @DPTR,A
   \   000211   A3           INC     DPTR
   \   000212   E0           MOVX    A,@DPTR
   \   000213   39           ADDC    A,R1
   \   000214   F0           MOVX    @DPTR,A
   1078          
   1079              data[0] = (accel_hw[0] >> 8) & 0xff;
   \   000215   7406         MOV     A,#0x6
   \   000217   12....       LCALL   ?XSTACK_DISP0_8
   \   00021A   E0           MOVX    A,@DPTR
   \   00021B   F5..         MOV     ?V0 + 0,A
   \   00021D   A3           INC     DPTR
   \   00021E   E0           MOVX    A,@DPTR
   \   00021F   F5..         MOV     ?V0 + 1,A
   \   000221   7408         MOV     A,#0x8
   \   000223   78..         MOV     R0,#?V0 + 0
   \   000225   12....       LCALL   ?SS_SHR
   \   000228   85..82       MOV     DPL,?XSP + 0
   \   00022B   85..83       MOV     DPH,?XSP + 1
   \   00022E   E5..         MOV     A,?V0 + 0
   \   000230   F0           MOVX    @DPTR,A
   1080              data[1] = (accel_hw[0]) & 0xff;
   \   000231   7406         MOV     A,#0x6
   \   000233   12....       LCALL   ?XSTACK_DISP0_8
   \   000236   E0           MOVX    A,@DPTR
   \   000237   C0E0         PUSH    A
   \   000239   7401         MOV     A,#0x1
   \   00023B   12....       LCALL   ?XSTACK_DISP0_8
   \   00023E   D0E0         POP     A
   \   000240   F0           MOVX    @DPTR,A
   1081              data[2] = (accel_hw[1] >> 8) & 0xff;
   \   000241   7408         MOV     A,#0x8
   \   000243   12....       LCALL   ?XSTACK_DISP0_8
   \   000246   E0           MOVX    A,@DPTR
   \   000247   FA           MOV     R2,A
   \   000248   A3           INC     DPTR
   \   000249   E0           MOVX    A,@DPTR
   \   00024A   FB           MOV     R3,A
   \   00024B   8A..         MOV     ?V0 + 0,R2
   \   00024D   8B..         MOV     ?V0 + 1,R3
   \   00024F   7408         MOV     A,#0x8
   \   000251   78..         MOV     R0,#?V0 + 0
   \   000253   12....       LCALL   ?SS_SHR
   \   000256   7402         MOV     A,#0x2
   \   000258   12....       LCALL   ?XSTACK_DISP0_8
   \   00025B   E5..         MOV     A,?V0 + 0
   \   00025D   F0           MOVX    @DPTR,A
   1082              data[3] = (accel_hw[1]) & 0xff;
   \   00025E   EA           MOV     A,R2
   \   00025F   C0E0         PUSH    A
   \   000261   7403         MOV     A,#0x3
   \   000263   12....       LCALL   ?XSTACK_DISP0_8
   \   000266   D0E0         POP     A
   \   000268   F0           MOVX    @DPTR,A
   1083              data[4] = (accel_hw[2] >> 8) & 0xff;
   \   000269   740A         MOV     A,#0xa
   \   00026B   12....       LCALL   ?XSTACK_DISP0_8
   \   00026E   E0           MOVX    A,@DPTR
   \   00026F   FA           MOV     R2,A
   \   000270   A3           INC     DPTR
   \   000271   E0           MOVX    A,@DPTR
   \   000272   FB           MOV     R3,A
   \   000273   8A..         MOV     ?V0 + 0,R2
   \   000275   8B..         MOV     ?V0 + 1,R3
   \   000277   7408         MOV     A,#0x8
   \   000279   78..         MOV     R0,#?V0 + 0
   \   00027B   12....       LCALL   ?SS_SHR
   \   00027E   7404         MOV     A,#0x4
   \   000280   12....       LCALL   ?XSTACK_DISP0_8
   \   000283   E5..         MOV     A,?V0 + 0
   \   000285   F0           MOVX    @DPTR,A
   1084              data[5] = (accel_hw[2]) & 0xff;
   \   000286   EA           MOV     A,R2
   \   000287   C0E0         PUSH    A
   \   000289   7405         MOV     A,#0x5
   \   00028B   12....       LCALL   ?XSTACK_DISP0_8
   \   00028E   D0E0         POP     A
   \   000290   F0           MOVX    @DPTR,A
   1085          
   1086              if (i2c_write(st.hw->addr, 0x06, 6, data))
   \   000291                ; Setup parameters for call to function MPU_Write_Len
   \   000291   85..82       MOV     DPL,?XSP + 0
   \   000294   85..83       MOV     DPH,?XSP + 1
   \   000297   AC82         MOV     R4,DPL
   \   000299   AD83         MOV     R5,DPH
   \   00029B   7B06         MOV     R3,#0x6
   \   00029D   7A06         MOV     R2,#0x6
   \   00029F   90....       MOV     DPTR,#st + 2
   \   0002A2   E0           MOVX    A,@DPTR
   \   0002A3   F8           MOV     R0,A
   \   0002A4   A3           INC     DPTR
   \   0002A5   E0           MOVX    A,@DPTR
   \   0002A6   F583         MOV     DPH,A
   \   0002A8   8882         MOV     DPL,R0
   \   0002AA   E0           MOVX    A,@DPTR
   \   0002AB   F9           MOV     R1,A
   \   0002AC   12....       LCALL   ??MPU_Write_Len?relay
   \   0002AF   E9           MOV     A,R1
   \   0002B0   6003         JZ      $+5
   \   0002B2   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   \   0002B5   02....       LJMP    ??mpu_set_accel_bias_4 & 0xFFFF
   1087                  return -1;
   1088              return 0;
   1089          }
   1090          
   1091          /**
   1092           *  @brief  Reset FIFO read/write pointers.
   1093           *  @return 0 if successful.
   1094           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1095          int mpu_reset_fifo(void)
   \                     mpu_reset_fifo:
   1096          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1097              unsigned char data;
   1098          
   1099              if (!(st.chip_cfg.sensors))
   \   000009   90....       MOV     DPTR,#st + 6
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   7007         JNZ     ??mpu_reset_fifo_0
   1100                  return -1;
   \                     ??mpu_reset_fifo_1:
   \   00000F   7AFF         MOV     R2,#-0x1
   \   000011   7BFF         MOV     R3,#-0x1
   \   000013   02....       LJMP    ??mpu_reset_fifo_2 & 0xFFFF
   1101          
   1102              data = 0;
   \                     ??mpu_reset_fifo_0:
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   E4           CLR     A
   \   00001D   F0           MOVX    @DPTR,A
   1103              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \   00001E                ; Setup parameters for call to function MPU_Write_Len
   \   00001E   AC82         MOV     R4,DPL
   \   000020   AD83         MOV     R5,DPH
   \   000022   7B01         MOV     R3,#0x1
   \   000024   90....       MOV     DPTR,#st
   \   000027   E0           MOVX    A,@DPTR
   \   000028   240F         ADD     A,#0xf
   \   00002A   F8           MOV     R0,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   F9           MOV     R1,A
   \   000030   8882         MOV     DPL,R0
   \   000032   8983         MOV     DPH,R1
   \   000034   E0           MOVX    A,@DPTR
   \   000035   FA           MOV     R2,A
   \   000036   90....       MOV     DPTR,#st + 2
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F583         MOV     DPH,A
   \   00003F   8882         MOV     DPL,R0
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F9           MOV     R1,A
   \   000043   12....       LCALL   ??MPU_Write_Len?relay
   \   000046   E9           MOV     A,R1
   \   000047   70C6         JNZ     ??mpu_reset_fifo_1
   1104                  return -1;
   1105              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   \   000049                ; Setup parameters for call to function MPU_Write_Len
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   AC82         MOV     R4,DPL
   \   000051   AD83         MOV     R5,DPH
   \   000053   7B01         MOV     R3,#0x1
   \   000055   90....       MOV     DPTR,#st
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F8           MOV     R0,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F583         MOV     DPH,A
   \   00005E   8882         MOV     DPL,R0
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FA           MOV     R2,A
   \   000067   90....       MOV     DPTR,#st + 2
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F8           MOV     R0,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F583         MOV     DPH,A
   \   000070   8882         MOV     DPL,R0
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F9           MOV     R1,A
   \   000074   12....       LCALL   ??MPU_Write_Len?relay
   \   000077   E9           MOV     A,R1
   \   000078   7095         JNZ     ??mpu_reset_fifo_1
   1106                  return -1;
   1107              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   00007A                ; Setup parameters for call to function MPU_Write_Len
   \   00007A   85..82       MOV     DPL,?XSP + 0
   \   00007D   85..83       MOV     DPH,?XSP + 1
   \   000080   AC82         MOV     R4,DPL
   \   000082   AD83         MOV     R5,DPH
   \   000084   7B01         MOV     R3,#0x1
   \   000086   90....       MOV     DPTR,#st
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F8           MOV     R0,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F583         MOV     DPH,A
   \   00008F   8882         MOV     DPL,R0
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   FA           MOV     R2,A
   \   000097   90....       MOV     DPTR,#st + 2
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   F8           MOV     R0,A
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   F583         MOV     DPH,A
   \   0000A0   8882         MOV     DPL,R0
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F9           MOV     R1,A
   \   0000A4   12....       LCALL   ??MPU_Write_Len?relay
   \   0000A7   E9           MOV     A,R1
   \   0000A8   6003         JZ      $+5
   \   0000AA   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1108                  return -1;
   1109          
   1110              if (st.chip_cfg.dmp_on) {
   \   0000AD   90....       MOV     DPTR,#st + 29
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   85..82       MOV     DPL,?XSP + 0
   \   0000B4   85..83       MOV     DPH,?XSP + 1
   \   0000B7   7003         JNZ     $+5
   \   0000B9   02....       LJMP    ??mpu_reset_fifo_3 & 0xFFFF
   1111                  data = BIT_FIFO_RST | BIT_DMP_RST;
   \   0000BC   740C         MOV     A,#0xc
   \   0000BE   F0           MOVX    @DPTR,A
   1112                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   0000BF                ; Setup parameters for call to function MPU_Write_Len
   \   0000BF   AC82         MOV     R4,DPL
   \   0000C1   AD83         MOV     R5,DPH
   \   0000C3   7B01         MOV     R3,#0x1
   \   0000C5   90....       MOV     DPTR,#st
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F8           MOV     R0,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   F583         MOV     DPH,A
   \   0000CE   8882         MOV     DPL,R0
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   FA           MOV     R2,A
   \   0000D6   90....       MOV     DPTR,#st + 2
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   F8           MOV     R0,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   F583         MOV     DPH,A
   \   0000DF   8882         MOV     DPL,R0
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   F9           MOV     R1,A
   \   0000E3   12....       LCALL   ??MPU_Write_Len?relay
   \   0000E6   E9           MOV     A,R1
   \   0000E7   6003         JZ      $+5
   \   0000E9   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1113                      return -1;
   1114                  delay_ms(50);
   \   0000EC                ; Setup parameters for call to function delay_ms
   \   0000EC   90....       MOV     DPTR,#__Constant_32
   \   0000EF   12....       LCALL   ?XLOAD_R2345
   \   0000F2   12....       LCALL   ??delay_ms?relay
   1115                  data = BIT_DMP_EN | BIT_FIFO_EN;
   \   0000F5   85..82       MOV     DPL,?XSP + 0
   \   0000F8   85..83       MOV     DPH,?XSP + 1
   \   0000FB   74C0         MOV     A,#-0x40
   \   0000FD   F0           MOVX    @DPTR,A
   1116                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   0000FE   90....       MOV     DPTR,#st + 6
   \   000101   E0           MOVX    A,@DPTR
   \   000102   A2E0         MOV     C,0xE0 /* A   */.0
   \   000104   5009         JNC     ??mpu_reset_fifo_4
   1117                      data |= BIT_AUX_IF_EN;
   \   000106   85..82       MOV     DPL,?XSP + 0
   \   000109   85..83       MOV     DPH,?XSP + 1
   \   00010C   74E0         MOV     A,#-0x20
   \   00010E   F0           MOVX    @DPTR,A
   1118                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??mpu_reset_fifo_4:
   \   00010F                ; Setup parameters for call to function MPU_Write_Len
   \   00010F   85..82       MOV     DPL,?XSP + 0
   \   000112   85..83       MOV     DPH,?XSP + 1
   \   000115   AC82         MOV     R4,DPL
   \   000117   AD83         MOV     R5,DPH
   \   000119   7B01         MOV     R3,#0x1
   \   00011B   90....       MOV     DPTR,#st
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   F8           MOV     R0,A
   \   000120   A3           INC     DPTR
   \   000121   E0           MOVX    A,@DPTR
   \   000122   F583         MOV     DPH,A
   \   000124   8882         MOV     DPL,R0
   \   000126   A3           INC     DPTR
   \   000127   A3           INC     DPTR
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   FA           MOV     R2,A
   \   00012C   90....       MOV     DPTR,#st + 2
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   F8           MOV     R0,A
   \   000131   A3           INC     DPTR
   \   000132   E0           MOVX    A,@DPTR
   \   000133   F583         MOV     DPH,A
   \   000135   8882         MOV     DPL,R0
   \   000137   E0           MOVX    A,@DPTR
   \   000138   F9           MOV     R1,A
   \   000139   12....       LCALL   ??MPU_Write_Len?relay
   \   00013C   E9           MOV     A,R1
   \   00013D   6003         JZ      $+5
   \   00013F   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1119                      return -1;
   1120                  if (st.chip_cfg.int_enable)
   \   000142   90....       MOV     DPTR,#st + 12
   \   000145   E0           MOVX    A,@DPTR
   \   000146   85..82       MOV     DPL,?XSP + 0
   \   000149   85..83       MOV     DPH,?XSP + 1
   \   00014C   6004         JZ      ??mpu_reset_fifo_5
   1121                      data = BIT_DMP_INT_EN;
   \   00014E   7402         MOV     A,#0x2
   \   000150   8001         SJMP    ??mpu_reset_fifo_6
   1122                  else
   1123                      data = 0;
   \                     ??mpu_reset_fifo_5:
   \   000152   E4           CLR     A
   \                     ??mpu_reset_fifo_6:
   \   000153   F0           MOVX    @DPTR,A
   1124                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \   000154                ; Setup parameters for call to function MPU_Write_Len
   \   000154   AC82         MOV     R4,DPL
   \   000156   AD83         MOV     R5,DPH
   \   000158   7B01         MOV     R3,#0x1
   \   00015A   90....       MOV     DPTR,#st
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   240F         ADD     A,#0xf
   \   000160   F8           MOV     R0,A
   \   000161   A3           INC     DPTR
   \   000162   E0           MOVX    A,@DPTR
   \   000163   3400         ADDC    A,#0x0
   \   000165   F9           MOV     R1,A
   \   000166   8882         MOV     DPL,R0
   \   000168   8983         MOV     DPH,R1
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   FA           MOV     R2,A
   \   00016C   90....       MOV     DPTR,#st + 2
   \   00016F   E0           MOVX    A,@DPTR
   \   000170   F8           MOV     R0,A
   \   000171   A3           INC     DPTR
   \   000172   E0           MOVX    A,@DPTR
   \   000173   F583         MOV     DPH,A
   \   000175   8882         MOV     DPL,R0
   \   000177   E0           MOVX    A,@DPTR
   \   000178   F9           MOV     R1,A
   \   000179   12....       LCALL   ??MPU_Write_Len?relay
   \   00017C   E9           MOV     A,R1
   \   00017D   6003         JZ      $+5
   \   00017F   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1125                      return -1;
   1126                  data = 0;
   \   000182   85..82       MOV     DPL,?XSP + 0
   \   000185   85..83       MOV     DPH,?XSP + 1
   \   000188   E4           CLR     A
   \   000189   F0           MOVX    @DPTR,A
   1127                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   \   00018A                ; Setup parameters for call to function MPU_Write_Len
   \   00018A   AC82         MOV     R4,DPL
   \   00018C   AD83         MOV     R5,DPH
   \   00018E   7B01         MOV     R3,#0x1
   \   000190   90....       MOV     DPTR,#st
   \   000193   E0           MOVX    A,@DPTR
   \   000194   F8           MOV     R0,A
   \   000195   A3           INC     DPTR
   \   000196   E0           MOVX    A,@DPTR
   \   000197   F583         MOV     DPH,A
   \   000199   8882         MOV     DPL,R0
   \   00019B   A3           INC     DPTR
   \   00019C   A3           INC     DPTR
   \   00019D   A3           INC     DPTR
   \   00019E   A3           INC     DPTR
   \   00019F   A3           INC     DPTR
   \   0001A0   E0           MOVX    A,@DPTR
   \   0001A1   FA           MOV     R2,A
   \   0001A2   90....       MOV     DPTR,#st + 2
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   F8           MOV     R0,A
   \   0001A7   A3           INC     DPTR
   \   0001A8   E0           MOVX    A,@DPTR
   \   0001A9   F583         MOV     DPH,A
   \   0001AB   8882         MOV     DPL,R0
   \   0001AD   E0           MOVX    A,@DPTR
   \   0001AE   F9           MOV     R1,A
   \   0001AF   12....       LCALL   ??MPU_Write_Len?relay
   \   0001B2   E9           MOV     A,R1
   \   0001B3   6003         JZ      $+5
   \   0001B5   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   \   0001B8   02....       LJMP    ??mpu_reset_fifo_7 & 0xFFFF
   1128                      return -1;
   1129              } else {
   1130                  data = BIT_FIFO_RST;
   \                     ??mpu_reset_fifo_3:
   \   0001BB   7404         MOV     A,#0x4
   \   0001BD   F0           MOVX    @DPTR,A
   1131                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   0001BE                ; Setup parameters for call to function MPU_Write_Len
   \   0001BE   AC82         MOV     R4,DPL
   \   0001C0   AD83         MOV     R5,DPH
   \   0001C2   7B01         MOV     R3,#0x1
   \   0001C4   90....       MOV     DPTR,#st
   \   0001C7   E0           MOVX    A,@DPTR
   \   0001C8   F8           MOV     R0,A
   \   0001C9   A3           INC     DPTR
   \   0001CA   E0           MOVX    A,@DPTR
   \   0001CB   F583         MOV     DPH,A
   \   0001CD   8882         MOV     DPL,R0
   \   0001CF   A3           INC     DPTR
   \   0001D0   A3           INC     DPTR
   \   0001D1   A3           INC     DPTR
   \   0001D2   A3           INC     DPTR
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   FA           MOV     R2,A
   \   0001D5   90....       MOV     DPTR,#st + 2
   \   0001D8   E0           MOVX    A,@DPTR
   \   0001D9   F8           MOV     R0,A
   \   0001DA   A3           INC     DPTR
   \   0001DB   E0           MOVX    A,@DPTR
   \   0001DC   F583         MOV     DPH,A
   \   0001DE   8882         MOV     DPL,R0
   \   0001E0   E0           MOVX    A,@DPTR
   \   0001E1   F9           MOV     R1,A
   \   0001E2   12....       LCALL   ??MPU_Write_Len?relay
   \   0001E5   E9           MOV     A,R1
   \   0001E6   6003         JZ      $+5
   \   0001E8   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1132                      return -1;
   1133                  if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   \   0001EB   90....       MOV     DPTR,#st + 13
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   7008         JNZ     ??mpu_reset_fifo_8
   \   0001F1   90....       MOV     DPTR,#st + 6
   \   0001F4   E0           MOVX    A,@DPTR
   \   0001F5   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001F7   400A         JC      ??mpu_reset_fifo_9
   1134                      data = BIT_FIFO_EN;
   \                     ??mpu_reset_fifo_8:
   \   0001F9   85..82       MOV     DPL,?XSP + 0
   \   0001FC   85..83       MOV     DPH,?XSP + 1
   \   0001FF   7440         MOV     A,#0x40
   \   000201   8008         SJMP    ??mpu_reset_fifo_10
   1135                  else
   1136                      data = BIT_FIFO_EN | BIT_AUX_IF_EN;
   \                     ??mpu_reset_fifo_9:
   \   000203   85..82       MOV     DPL,?XSP + 0
   \   000206   85..83       MOV     DPH,?XSP + 1
   \   000209   7460         MOV     A,#0x60
   \                     ??mpu_reset_fifo_10:
   \   00020B   F0           MOVX    @DPTR,A
   1137                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   00020C                ; Setup parameters for call to function MPU_Write_Len
   \   00020C   AC82         MOV     R4,DPL
   \   00020E   AD83         MOV     R5,DPH
   \   000210   7B01         MOV     R3,#0x1
   \   000212   90....       MOV     DPTR,#st
   \   000215   E0           MOVX    A,@DPTR
   \   000216   F8           MOV     R0,A
   \   000217   A3           INC     DPTR
   \   000218   E0           MOVX    A,@DPTR
   \   000219   F583         MOV     DPH,A
   \   00021B   8882         MOV     DPL,R0
   \   00021D   A3           INC     DPTR
   \   00021E   A3           INC     DPTR
   \   00021F   A3           INC     DPTR
   \   000220   A3           INC     DPTR
   \   000221   E0           MOVX    A,@DPTR
   \   000222   FA           MOV     R2,A
   \   000223   90....       MOV     DPTR,#st + 2
   \   000226   E0           MOVX    A,@DPTR
   \   000227   F8           MOV     R0,A
   \   000228   A3           INC     DPTR
   \   000229   E0           MOVX    A,@DPTR
   \   00022A   F583         MOV     DPH,A
   \   00022C   8882         MOV     DPL,R0
   \   00022E   E0           MOVX    A,@DPTR
   \   00022F   F9           MOV     R1,A
   \   000230   12....       LCALL   ??MPU_Write_Len?relay
   \   000233   E9           MOV     A,R1
   \   000234   6003         JZ      $+5
   \   000236   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1138                      return -1;
   1139                  delay_ms(50);
   \   000239                ; Setup parameters for call to function delay_ms
   \   000239   90....       MOV     DPTR,#__Constant_32
   \   00023C   12....       LCALL   ?XLOAD_R2345
   \   00023F   12....       LCALL   ??delay_ms?relay
   1140                  if (st.chip_cfg.int_enable)
   \   000242   90....       MOV     DPTR,#st + 12
   \   000245   E0           MOVX    A,@DPTR
   \   000246   85..82       MOV     DPL,?XSP + 0
   \   000249   85..83       MOV     DPH,?XSP + 1
   \   00024C   6004         JZ      ??mpu_reset_fifo_11
   1141                      data = BIT_DATA_RDY_EN;
   \   00024E   7401         MOV     A,#0x1
   \   000250   8001         SJMP    ??mpu_reset_fifo_12
   1142                  else
   1143                      data = 0;
   \                     ??mpu_reset_fifo_11:
   \   000252   E4           CLR     A
   \                     ??mpu_reset_fifo_12:
   \   000253   F0           MOVX    @DPTR,A
   1144                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \   000254                ; Setup parameters for call to function MPU_Write_Len
   \   000254   AC82         MOV     R4,DPL
   \   000256   AD83         MOV     R5,DPH
   \   000258   7B01         MOV     R3,#0x1
   \   00025A   90....       MOV     DPTR,#st
   \   00025D   E0           MOVX    A,@DPTR
   \   00025E   240F         ADD     A,#0xf
   \   000260   F8           MOV     R0,A
   \   000261   A3           INC     DPTR
   \   000262   E0           MOVX    A,@DPTR
   \   000263   3400         ADDC    A,#0x0
   \   000265   F9           MOV     R1,A
   \   000266   8882         MOV     DPL,R0
   \   000268   8983         MOV     DPH,R1
   \   00026A   E0           MOVX    A,@DPTR
   \   00026B   FA           MOV     R2,A
   \   00026C   90....       MOV     DPTR,#st + 2
   \   00026F   E0           MOVX    A,@DPTR
   \   000270   F8           MOV     R0,A
   \   000271   A3           INC     DPTR
   \   000272   E0           MOVX    A,@DPTR
   \   000273   F583         MOV     DPH,A
   \   000275   8882         MOV     DPL,R0
   \   000277   E0           MOVX    A,@DPTR
   \   000278   F9           MOV     R1,A
   \   000279   12....       LCALL   ??MPU_Write_Len?relay
   \   00027C   E9           MOV     A,R1
   \   00027D   6003         JZ      $+5
   \   00027F   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1145                      return -1;
   1146                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
   \   000282                ; Setup parameters for call to function MPU_Write_Len
   \   000282   7C..         MOV     R4,#(st + 11) & 0xff
   \   000284   7D..         MOV     R5,#((st + 11) >> 8) & 0xff
   \   000286   7B01         MOV     R3,#0x1
   \   000288   90....       MOV     DPTR,#st
   \   00028B   E0           MOVX    A,@DPTR
   \   00028C   F8           MOV     R0,A
   \   00028D   A3           INC     DPTR
   \   00028E   E0           MOVX    A,@DPTR
   \   00028F   F583         MOV     DPH,A
   \   000291   8882         MOV     DPL,R0
   \   000293   A3           INC     DPTR
   \   000294   A3           INC     DPTR
   \   000295   A3           INC     DPTR
   \   000296   A3           INC     DPTR
   \   000297   A3           INC     DPTR
   \   000298   E0           MOVX    A,@DPTR
   \   000299   FA           MOV     R2,A
   \   00029A   90....       MOV     DPTR,#st + 2
   \   00029D   E0           MOVX    A,@DPTR
   \   00029E   F8           MOV     R0,A
   \   00029F   A3           INC     DPTR
   \   0002A0   E0           MOVX    A,@DPTR
   \   0002A1   F583         MOV     DPH,A
   \   0002A3   8882         MOV     DPL,R0
   \   0002A5   E0           MOVX    A,@DPTR
   \   0002A6   F9           MOV     R1,A
   \   0002A7   12....       LCALL   ??MPU_Write_Len?relay
   \   0002AA   E9           MOV     A,R1
   \   0002AB   6003         JZ      $+5
   \   0002AD   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1147                      return -1;
   1148              }
   1149              return 0;
   \                     ??mpu_reset_fifo_7:
   \   0002B0   7A00         MOV     R2,#0x0
   \   0002B2   7B00         MOV     R3,#0x0
   \                     ??mpu_reset_fifo_2:
   \   0002B4   7401         MOV     A,#0x1
   \   0002B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002B9   D083         POP     DPH
   \   0002BB   D082         POP     DPL
   \   0002BD   02....       LJMP    ?BRET
   1150          }
   1151          
   1152          /**
   1153           *  @brief      Get the gyro full-scale range.
   1154           *  @param[out] fsr Current full-scale range.
   1155           *  @return     0 if successful.
   1156           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1157          int mpu_get_gyro_fsr(unsigned short *fsr)
   \                     mpu_get_gyro_fsr:
   1158          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1159              switch (st.chip_cfg.gyro_fsr) {
   \   000004   90....       MOV     DPTR,#st + 4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_gyro_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6013         JZ      ??mpu_get_gyro_fsr_1
   \   00000D   14           DEC     A
   \   00000E   601C         JZ      ??mpu_get_gyro_fsr_2
   \   000010   14           DEC     A
   \   000011   6025         JZ      ??mpu_get_gyro_fsr_3
   \   000013   802F         SJMP    ??mpu_get_gyro_fsr_4
   1160              case INV_FSR_250DPS:
   1161                  fsr[0] = 250;
   \                     ??mpu_get_gyro_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   74FA         MOV     A,#-0x6
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   E4           CLR     A
   \   00001E   802B         SJMP    ??mpu_get_gyro_fsr_5
   1162                  break;
   1163              case INV_FSR_500DPS:
   1164                  fsr[0] = 500;
   \                     ??mpu_get_gyro_fsr_1:
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   74F4         MOV     A,#-0xc
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   7401         MOV     A,#0x1
   \   00002A   801F         SJMP    ??mpu_get_gyro_fsr_5
   1165                  break;
   1166              case INV_FSR_1000DPS:
   1167                  fsr[0] = 1000;
   \                     ??mpu_get_gyro_fsr_2:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   74E8         MOV     A,#-0x18
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7403         MOV     A,#0x3
   \   000036   8013         SJMP    ??mpu_get_gyro_fsr_5
   1168                  break;
   1169              case INV_FSR_2000DPS:
   1170                  fsr[0] = 2000;
   \                     ??mpu_get_gyro_fsr_3:
   \   000038   8A82         MOV     DPL,R2
   \   00003A   8B83         MOV     DPH,R3
   \   00003C   74D0         MOV     A,#-0x30
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   7407         MOV     A,#0x7
   \   000042   8007         SJMP    ??mpu_get_gyro_fsr_5
   1171                  break;
   1172              default:
   1173                  fsr[0] = 0;
   \                     ??mpu_get_gyro_fsr_4:
   \   000044   8A82         MOV     DPL,R2
   \   000046   8B83         MOV     DPH,R3
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \                     ??mpu_get_gyro_fsr_5:
   \   00004B   F0           MOVX    @DPTR,A
   1174                  break;
   1175              }
   1176              return 0;
   \   00004C   7A00         MOV     R2,#0x0
   \   00004E   7B00         MOV     R3,#0x0
   \   000050   D083         POP     DPH
   \   000052   D082         POP     DPL
   \   000054   02....       LJMP    ?BRET
   1177          }
   1178          
   1179          /**
   1180           *  @brief      Set the gyro full-scale range.
   1181           *  @param[in]  fsr Desired full-scale range.
   1182           *  @return     0 if successful.
   1183           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1184          int mpu_set_gyro_fsr(unsigned short fsr)
   \                     mpu_set_gyro_fsr:
   1185          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1186              unsigned char data;
   1187          
   1188              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7007         JNZ     ??mpu_set_gyro_fsr_0
   1189                  return -1;
   \                     ??mpu_set_gyro_fsr_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   02....       LJMP    ??mpu_set_gyro_fsr_2 & 0xFFFF
   1190          
   1191              switch (fsr) {
   \                     ??mpu_set_gyro_fsr_0:
   \   000017   8A..         MOV     ?V0 + 0,R2
   \   000019   8B..         MOV     ?V0 + 1,R3
   \   00001B   78..         MOV     R0,#?V0 + 0
   \   00001D   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for mpu_set_gyro_fsr>_0`:
   \   000020   0000         DW        0
   \   000022   0400         DW        4
   \   000024   FA00         DW        250
   \   000026   ....         DW        ??mpu_set_gyro_fsr_3
   \   000028   F401         DW        500
   \   00002A   ....         DW        ??mpu_set_gyro_fsr_4
   \   00002C   E803         DW        1000
   \   00002E   ....         DW        ??mpu_set_gyro_fsr_5
   \   000030   D007         DW        2000
   \   000032   ....         DW        ??mpu_set_gyro_fsr_6
   \   000034   ....         DW        ??mpu_set_gyro_fsr_1
   1192              case 250:
   1193                  data = INV_FSR_250DPS << 3;
   \                     ??mpu_set_gyro_fsr_3:
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   E4           CLR     A
   \   00003D   801C         SJMP    ??mpu_set_gyro_fsr_7
   1194                  break;
   1195              case 500:
   1196                  data = INV_FSR_500DPS << 3;
   \                     ??mpu_set_gyro_fsr_4:
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   7408         MOV     A,#0x8
   \   000047   8012         SJMP    ??mpu_set_gyro_fsr_7
   1197                  break;
   1198              case 1000:
   1199                  data = INV_FSR_1000DPS << 3;
   \                     ??mpu_set_gyro_fsr_5:
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   7410         MOV     A,#0x10
   \   000051   8008         SJMP    ??mpu_set_gyro_fsr_7
   1200                  break;
   1201              case 2000:
   1202                  data = INV_FSR_2000DPS << 3;
   \                     ??mpu_set_gyro_fsr_6:
   \   000053   85..82       MOV     DPL,?XSP + 0
   \   000056   85..83       MOV     DPH,?XSP + 1
   \   000059   7418         MOV     A,#0x18
   \                     ??mpu_set_gyro_fsr_7:
   \   00005B   F0           MOVX    @DPTR,A
   1203                  break;
   1204              default:
   1205                  return -1;
   1206              }
   1207          
   1208              if (st.chip_cfg.gyro_fsr == (data >> 3))
   \   00005C   90....       MOV     DPTR,#st + 4
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   F8           MOV     R0,A
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   13           RRC     A
   \   000069   13           RRC     A
   \   00006A   13           RRC     A
   \   00006B   541F         ANL     A,#0x1f
   \   00006D   68           XRL     A,R0
   \   00006E   603F         JZ      ??mpu_set_gyro_fsr_8
   1209                  return 0;
   1210              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
   \   000070                ; Setup parameters for call to function MPU_Write_Len
   \   000070   AC82         MOV     R4,DPL
   \   000072   AD83         MOV     R5,DPH
   \   000074   7B01         MOV     R3,#0x1
   \   000076   90....       MOV     DPTR,#st
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   F8           MOV     R0,A
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   F583         MOV     DPH,A
   \   00007F   8882         MOV     DPL,R0
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   FA           MOV     R2,A
   \   000089   90....       MOV     DPTR,#st + 2
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F8           MOV     R0,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F583         MOV     DPH,A
   \   000092   8882         MOV     DPL,R0
   \   000094   E0           MOVX    A,@DPTR
   \   000095   F9           MOV     R1,A
   \   000096   12....       LCALL   ??MPU_Write_Len?relay
   \   000099   E9           MOV     A,R1
   \   00009A   6003         JZ      $+5
   \   00009C   02....       LJMP    ??mpu_set_gyro_fsr_1 & 0xFFFF
   1211                  return -1;
   1212              st.chip_cfg.gyro_fsr = data >> 3;
   \   00009F   85..82       MOV     DPL,?XSP + 0
   \   0000A2   85..83       MOV     DPH,?XSP + 1
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   13           RRC     A
   \   0000A7   13           RRC     A
   \   0000A8   13           RRC     A
   \   0000A9   541F         ANL     A,#0x1f
   \   0000AB   90....       MOV     DPTR,#st + 4
   \   0000AE   F0           MOVX    @DPTR,A
   1213              return 0;
   \                     ??mpu_set_gyro_fsr_8:
   \   0000AF   7A00         MOV     R2,#0x0
   \   0000B1   7B00         MOV     R3,#0x0
   \                     ??mpu_set_gyro_fsr_2:
   \   0000B3   7401         MOV     A,#0x1
   \   0000B5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B8   7F02         MOV     R7,#0x2
   \   0000BA   02....       LJMP    ?BANKED_LEAVE_XDATA
   1214          }
   1215          
   1216          /**
   1217           *  @brief      Get the accel full-scale range.
   1218           *  @param[out] fsr Current full-scale range.
   1219           *  @return     0 if successful.
   1220           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1221          int mpu_get_accel_fsr(unsigned char *fsr)
   \                     mpu_get_accel_fsr:
   1222          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1223              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6028         JZ      ??mpu_get_accel_fsr_1
   \   00000D   14           DEC     A
   \   00000E   602D         JZ      ??mpu_get_accel_fsr_2
   \   000010   14           DEC     A
   \   000011   6032         JZ      ??mpu_get_accel_fsr_3
   \   000013   8038         SJMP    ??mpu_get_accel_fsr_4
   1224              case INV_FSR_2G:
   1225                  fsr[0] = 2;
   \                     ??mpu_get_accel_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   7402         MOV     A,#0x2
   \                     ??mpu_get_accel_fsr_5:
   \   00001B   F0           MOVX    @DPTR,A
   1226                  break;
   1227              case INV_FSR_4G:
   1228                  fsr[0] = 4;
   1229                  break;
   1230              case INV_FSR_8G:
   1231                  fsr[0] = 8;
   1232                  break;
   1233              case INV_FSR_16G:
   1234                  fsr[0] = 16;
   1235                  break;
   1236              default:
   1237                  return -1;
   1238              }
   1239              if (st.chip_cfg.accel_half)
   \   00001C   90....       MOV     DPTR,#st + 14
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6008         JZ      ??mpu_get_accel_fsr_6
   1240                  fsr[0] <<= 1;
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   E0           MOVX    A,@DPTR
   \   000027   C3           CLR     C
   \   000028   33           RLC     A
   \   000029   F0           MOVX    @DPTR,A
   1241              return 0;
   \                     ??mpu_get_accel_fsr_6:
   \   00002A   7A00         MOV     R2,#0x0
   \   00002C   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_fsr_7:
   \   00002E   D083         POP     DPH
   \   000030   D082         POP     DPL
   \   000032   02....       LJMP    ?BRET
   \                     ??mpu_get_accel_fsr_1:
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   7404         MOV     A,#0x4
   \   00003B   80DE         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_2:
   \   00003D   8A82         MOV     DPL,R2
   \   00003F   8B83         MOV     DPH,R3
   \   000041   7408         MOV     A,#0x8
   \   000043   80D6         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_3:
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   7410         MOV     A,#0x10
   \   00004B   80CE         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_4:
   \   00004D   7AFF         MOV     R2,#-0x1
   \   00004F   7BFF         MOV     R3,#-0x1
   \   000051   80DB         SJMP    ??mpu_get_accel_fsr_7
   1242          }
   1243          
   1244          /**
   1245           *  @brief      Set the accel full-scale range.
   1246           *  @param[in]  fsr Desired full-scale range.
   1247           *  @return     0 if successful.
   1248           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1249          int mpu_set_accel_fsr(unsigned char fsr)
   \                     mpu_set_accel_fsr:
   1250          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1251              unsigned char data;
   1252          
   1253              if (!(st.chip_cfg.sensors))
   \   00000C   90....       MOV     DPTR,#st + 6
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   7007         JNZ     ??mpu_set_accel_fsr_0
   1254                  return -1;
   \                     ??mpu_set_accel_fsr_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \   000016   02....       LJMP    ??mpu_set_accel_fsr_2 & 0xFFFF
   1255          
   1256              switch (fsr) {
   \                     ??mpu_set_accel_fsr_0:
   \   000019   EE           MOV     A,R6
   \   00001A   24FE         ADD     A,#-0x2
   \   00001C   600E         JZ      ??mpu_set_accel_fsr_3
   \   00001E   24FE         ADD     A,#-0x2
   \   000020   6013         JZ      ??mpu_set_accel_fsr_4
   \   000022   24FC         ADD     A,#-0x4
   \   000024   6019         JZ      ??mpu_set_accel_fsr_5
   \   000026   24F8         ADD     A,#-0x8
   \   000028   601F         JZ      ??mpu_set_accel_fsr_6
   \   00002A   80E6         SJMP    ??mpu_set_accel_fsr_1
   1257              case 2:
   1258                  data = INV_FSR_2G << 3;
   \                     ??mpu_set_accel_fsr_3:
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   E4           CLR     A
   \   000033   801C         SJMP    ??mpu_set_accel_fsr_7
   1259                  break;
   1260              case 4:
   1261                  data = INV_FSR_4G << 3;
   \                     ??mpu_set_accel_fsr_4:
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   7408         MOV     A,#0x8
   \   00003D   8012         SJMP    ??mpu_set_accel_fsr_7
   1262                  break;
   1263              case 8:
   1264                  data = INV_FSR_8G << 3;
   \                     ??mpu_set_accel_fsr_5:
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   7410         MOV     A,#0x10
   \   000047   8008         SJMP    ??mpu_set_accel_fsr_7
   1265                  break;
   1266              case 16:
   1267                  data = INV_FSR_16G << 3;
   \                     ??mpu_set_accel_fsr_6:
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   7418         MOV     A,#0x18
   \                     ??mpu_set_accel_fsr_7:
   \   000051   F0           MOVX    @DPTR,A
   1268                  break;
   1269              default:
   1270                  return -1;
   1271              }
   1272          
   1273              if (st.chip_cfg.accel_fsr == (data >> 3))
   \   000052   90....       MOV     DPTR,#st + 5
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   13           RRC     A
   \   00005F   13           RRC     A
   \   000060   13           RRC     A
   \   000061   541F         ANL     A,#0x1f
   \   000063   68           XRL     A,R0
   \   000064   6040         JZ      ??mpu_set_accel_fsr_8
   1274                  return 0;
   1275              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
   \   000066                ; Setup parameters for call to function MPU_Write_Len
   \   000066   AC82         MOV     R4,DPL
   \   000068   AD83         MOV     R5,DPH
   \   00006A   7B01         MOV     R3,#0x1
   \   00006C   90....       MOV     DPTR,#st
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F8           MOV     R0,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F583         MOV     DPH,A
   \   000075   8882         MOV     DPL,R0
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   FA           MOV     R2,A
   \   000080   90....       MOV     DPTR,#st + 2
   \   000083   E0           MOVX    A,@DPTR
   \   000084   F8           MOV     R0,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   F583         MOV     DPH,A
   \   000089   8882         MOV     DPL,R0
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   F9           MOV     R1,A
   \   00008D   12....       LCALL   ??MPU_Write_Len?relay
   \   000090   E9           MOV     A,R1
   \   000091   6003         JZ      $+5
   \   000093   02....       LJMP    ??mpu_set_accel_fsr_1 & 0xFFFF
   1276                  return -1;
   1277              st.chip_cfg.accel_fsr = data >> 3;
   \   000096   85..82       MOV     DPL,?XSP + 0
   \   000099   85..83       MOV     DPH,?XSP + 1
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   13           RRC     A
   \   00009E   13           RRC     A
   \   00009F   13           RRC     A
   \   0000A0   541F         ANL     A,#0x1f
   \   0000A2   90....       MOV     DPTR,#st + 5
   \   0000A5   F0           MOVX    @DPTR,A
   1278              return 0;
   \                     ??mpu_set_accel_fsr_8:
   \   0000A6   7A00         MOV     R2,#0x0
   \   0000A8   7B00         MOV     R3,#0x0
   \                     ??mpu_set_accel_fsr_2:
   \   0000AA   7401         MOV     A,#0x1
   \   0000AC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AF   7F01         MOV     R7,#0x1
   \   0000B1   02....       LJMP    ?BANKED_LEAVE_XDATA
   1279          }
   1280          
   1281          /**
   1282           *  @brief      Get the current DLPF setting.
   1283           *  @param[out] lpf Current LPF setting.
   1284           *  0 if successful.
   1285           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1286          int mpu_get_lpf(unsigned short *lpf)
   \                     mpu_get_lpf:
   1287          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1288              switch (st.chip_cfg.lpf) {
   \   000004   90....       MOV     DPTR,#st + 7
   \   000007   E0           MOVX    A,@DPTR
   \   000008   14           DEC     A
   \   000009   6011         JZ      ??mpu_get_lpf_0
   \   00000B   14           DEC     A
   \   00000C   6019         JZ      ??mpu_get_lpf_1
   \   00000E   14           DEC     A
   \   00000F   601E         JZ      ??mpu_get_lpf_2
   \   000011   14           DEC     A
   \   000012   6023         JZ      ??mpu_get_lpf_3
   \   000014   14           DEC     A
   \   000015   6028         JZ      ??mpu_get_lpf_4
   \   000017   14           DEC     A
   \   000018   602D         JZ      ??mpu_get_lpf_5
   \   00001A   8033         SJMP    ??mpu_get_lpf_6
   1289              case INV_FILTER_188HZ:
   1290                  lpf[0] = 188;
   \                     ??mpu_get_lpf_0:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   74BC         MOV     A,#-0x44
   \                     ??mpu_get_lpf_7:
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E4           CLR     A
   \   000025   802F         SJMP    ??mpu_get_lpf_8
   1291                  break;
   1292              case INV_FILTER_98HZ:
   1293                  lpf[0] = 98;
   \                     ??mpu_get_lpf_1:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   7462         MOV     A,#0x62
   \   00002D   80F3         SJMP    ??mpu_get_lpf_7
   1294                  break;
   1295              case INV_FILTER_42HZ:
   1296                  lpf[0] = 42;
   \                     ??mpu_get_lpf_2:
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   742A         MOV     A,#0x2a
   \   000035   80EB         SJMP    ??mpu_get_lpf_7
   1297                  break;
   1298              case INV_FILTER_20HZ:
   1299                  lpf[0] = 20;
   \                     ??mpu_get_lpf_3:
   \   000037   8A82         MOV     DPL,R2
   \   000039   8B83         MOV     DPH,R3
   \   00003B   7414         MOV     A,#0x14
   \   00003D   80E3         SJMP    ??mpu_get_lpf_7
   1300                  break;
   1301              case INV_FILTER_10HZ:
   1302                  lpf[0] = 10;
   \                     ??mpu_get_lpf_4:
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   740A         MOV     A,#0xa
   \   000045   80DB         SJMP    ??mpu_get_lpf_7
   1303                  break;
   1304              case INV_FILTER_5HZ:
   1305                  lpf[0] = 5;
   \                     ??mpu_get_lpf_5:
   \   000047   8A82         MOV     DPL,R2
   \   000049   8B83         MOV     DPH,R3
   \   00004B   7405         MOV     A,#0x5
   \   00004D   80D3         SJMP    ??mpu_get_lpf_7
   1306                  break;
   1307              case INV_FILTER_256HZ_NOLPF2:
   1308              case INV_FILTER_2100HZ_NOLPF:
   1309              default:
   1310                  lpf[0] = 0;
   \                     ??mpu_get_lpf_6:
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \                     ??mpu_get_lpf_8:
   \   000056   F0           MOVX    @DPTR,A
   1311                  break;
   1312              }
   1313              return 0;
   \   000057   7A00         MOV     R2,#0x0
   \   000059   7B00         MOV     R3,#0x0
   \   00005B   D083         POP     DPH
   \   00005D   D082         POP     DPL
   \   00005F   02....       LJMP    ?BRET
   1314          }
   1315          
   1316          /**
   1317           *  @brief      Set digital low pass filter.
   1318           *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
   1319           *  @param[in]  lpf Desired LPF setting.
   1320           *  @return     0 if successful.
   1321           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1322          int mpu_set_lpf(unsigned short lpf)
   \                     mpu_set_lpf:
   1323          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1324              unsigned char data;
   1325          
   1326              if (!(st.chip_cfg.sensors))
   \   000009   90....       MOV     DPTR,#st + 6
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   7007         JNZ     ??mpu_set_lpf_0
   1327                  return -1;
   \                     ??mpu_set_lpf_1:
   \   00000F   7AFF         MOV     R2,#-0x1
   \   000011   7BFF         MOV     R3,#-0x1
   \   000013   02....       LJMP    ??mpu_set_lpf_2 & 0xFFFF
   1328          
   1329              if (lpf >= 188)
   \                     ??mpu_set_lpf_0:
   \   000016   C3           CLR     C
   \   000017   EA           MOV     A,R2
   \   000018   94BC         SUBB    A,#-0x44
   \   00001A   EB           MOV     A,R3
   \   00001B   9400         SUBB    A,#0x0
   \   00001D   400A         JC      ??mpu_set_lpf_3
   1330                  data = INV_FILTER_188HZ;
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   7401         MOV     A,#0x1
   \   000027   804E         SJMP    ??mpu_set_lpf_4
   1331              else if (lpf >= 98)
   \                     ??mpu_set_lpf_3:
   \   000029   C3           CLR     C
   \   00002A   EA           MOV     A,R2
   \   00002B   9462         SUBB    A,#0x62
   \   00002D   EB           MOV     A,R3
   \   00002E   9400         SUBB    A,#0x0
   \   000030   400A         JC      ??mpu_set_lpf_5
   1332                  data = INV_FILTER_98HZ;
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   7402         MOV     A,#0x2
   \   00003A   803B         SJMP    ??mpu_set_lpf_4
   1333              else if (lpf >= 42)
   \                     ??mpu_set_lpf_5:
   \   00003C   C3           CLR     C
   \   00003D   EA           MOV     A,R2
   \   00003E   942A         SUBB    A,#0x2a
   \   000040   EB           MOV     A,R3
   \   000041   9400         SUBB    A,#0x0
   \   000043   400A         JC      ??mpu_set_lpf_6
   1334                  data = INV_FILTER_42HZ;
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   7403         MOV     A,#0x3
   \   00004D   8028         SJMP    ??mpu_set_lpf_4
   1335              else if (lpf >= 20)
   \                     ??mpu_set_lpf_6:
   \   00004F   C3           CLR     C
   \   000050   EA           MOV     A,R2
   \   000051   9414         SUBB    A,#0x14
   \   000053   EB           MOV     A,R3
   \   000054   9400         SUBB    A,#0x0
   \   000056   400A         JC      ??mpu_set_lpf_7
   1336                  data = INV_FILTER_20HZ;
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   7404         MOV     A,#0x4
   \   000060   8015         SJMP    ??mpu_set_lpf_4
   1337              else if (lpf >= 10)
   \                     ??mpu_set_lpf_7:
   \   000062   C3           CLR     C
   \   000063   EA           MOV     A,R2
   \   000064   940A         SUBB    A,#0xa
   \   000066   EB           MOV     A,R3
   \   000067   9400         SUBB    A,#0x0
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   4004         JC      ??mpu_set_lpf_8
   1338                  data = INV_FILTER_10HZ;
   \   000071   7405         MOV     A,#0x5
   \   000073   8002         SJMP    ??mpu_set_lpf_4
   1339              else
   1340                  data = INV_FILTER_5HZ;
   \                     ??mpu_set_lpf_8:
   \   000075   7406         MOV     A,#0x6
   \                     ??mpu_set_lpf_4:
   \   000077   F0           MOVX    @DPTR,A
   1341          
   1342              if (st.chip_cfg.lpf == data)
   \   000078   90....       MOV     DPTR,#st + 7
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F8           MOV     R0,A
   \   00007D   85..82       MOV     DPL,?XSP + 0
   \   000080   85..83       MOV     DPH,?XSP + 1
   \   000083   E0           MOVX    A,@DPTR
   \   000084   68           XRL     A,R0
   \   000085   6036         JZ      ??mpu_set_lpf_9
   1343                  return 0;
   1344              if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
   \   000087                ; Setup parameters for call to function MPU_Write_Len
   \   000087   AC82         MOV     R4,DPL
   \   000089   AD83         MOV     R5,DPH
   \   00008B   7B01         MOV     R3,#0x1
   \   00008D   90....       MOV     DPTR,#st
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F8           MOV     R0,A
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   F583         MOV     DPH,A
   \   000096   8882         MOV     DPL,R0
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   FA           MOV     R2,A
   \   00009C   90....       MOV     DPTR,#st + 2
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   F8           MOV     R0,A
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   F583         MOV     DPH,A
   \   0000A5   8882         MOV     DPL,R0
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   F9           MOV     R1,A
   \   0000A9   12....       LCALL   ??MPU_Write_Len?relay
   \   0000AC   E9           MOV     A,R1
   \   0000AD   6003         JZ      $+5
   \   0000AF   02....       LJMP    ??mpu_set_lpf_1 & 0xFFFF
   1345                  return -1;
   1346              st.chip_cfg.lpf = data;
   \   0000B2   85..82       MOV     DPL,?XSP + 0
   \   0000B5   85..83       MOV     DPH,?XSP + 1
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   90....       MOV     DPTR,#st + 7
   \   0000BC   F0           MOVX    @DPTR,A
   1347              return 0;
   \                     ??mpu_set_lpf_9:
   \   0000BD   7A00         MOV     R2,#0x0
   \   0000BF   7B00         MOV     R3,#0x0
   \                     ??mpu_set_lpf_2:
   \   0000C1   7401         MOV     A,#0x1
   \   0000C3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C6   D083         POP     DPH
   \   0000C8   D082         POP     DPL
   \   0000CA   02....       LJMP    ?BRET
   1348          }
   1349          
   1350          /**
   1351           *  @brief      Get sampling rate.
   1352           *  @param[out] rate    Current sampling rate (Hz).
   1353           *  @return     0 if successful.
   1354           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1355          int mpu_get_sample_rate(unsigned short *rate)
   \                     mpu_get_sample_rate:
   1356          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1357              if (st.chip_cfg.dmp_on)
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6006         JZ      ??mpu_get_sample_rate_0
   1358                  return -1;
   \   00000A   7AFF         MOV     R2,#-0x1
   \   00000C   7BFF         MOV     R3,#-0x1
   \   00000E   8015         SJMP    ??mpu_get_sample_rate_1
   1359              else
   1360                  rate[0] = st.chip_cfg.sample_rate;
   \                     ??mpu_get_sample_rate_0:
   \   000010   90....       MOV     DPTR,#st + 9
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   E8           MOV     A,R0
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   E9           MOV     A,R1
   \   000020   F0           MOVX    @DPTR,A
   1361              return 0;
   \   000021   7A00         MOV     R2,#0x0
   \   000023   7B00         MOV     R3,#0x0
   \                     ??mpu_get_sample_rate_1:
   \   000025   D083         POP     DPH
   \   000027   D082         POP     DPL
   \   000029   02....       LJMP    ?BRET
   1362          }
   1363          
   1364          /**
   1365           *  @brief      Set sampling rate.
   1366           *  Sampling rate must be between 4Hz and 1kHz.
   1367           *  @param[in]  rate    Desired sampling rate (Hz).
   1368           *  @return     0 if successful.
   1369           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1370          int mpu_set_sample_rate(unsigned short rate)
   \                     mpu_set_sample_rate:
   1371          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1372              unsigned char data;
   1373          
   1374              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_set_sample_rate_0
   1375                  return -1;
   \                     ??mpu_set_sample_rate_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_set_sample_rate_2 & 0xFFFF
   1376          
   1377              if (st.chip_cfg.dmp_on)
   \                     ??mpu_set_sample_rate_0:
   \   00001B   90....       MOV     DPTR,#st + 29
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   70F3         JNZ     ??mpu_set_sample_rate_1
   1378                  return -1;
   1379              else {
   1380                  if (st.chip_cfg.lp_accel_mode) {
   \   000021   90....       MOV     DPTR,#st + 15
   \   000024   E0           MOVX    A,@DPTR
   \   000025   601A         JZ      ??mpu_set_sample_rate_3
   1381                      if (rate && (rate <= 40)) {
   \   000027   EE           MOV     A,R6
   \   000028   4F           ORL     A,R7
   \   000029   6011         JZ      ??mpu_set_sample_rate_4
   \   00002B   C3           CLR     C
   \   00002C   EE           MOV     A,R6
   \   00002D   9429         SUBB    A,#0x29
   \   00002F   EF           MOV     A,R7
   \   000030   9400         SUBB    A,#0x0
   \   000032   5008         JNC     ??mpu_set_sample_rate_4
   1382                          /* Just stay in low-power accel mode. */
   1383                          mpu_lp_accel_mode(rate);
   \   000034                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000034   EE           MOV     A,R6
   \   000035   F9           MOV     R1,A
   \   000036   12....       LCALL   ??mpu_lp_accel_mode?relay
   1384                          return 0;
   \   000039   02....       LJMP    ??mpu_set_sample_rate_5 & 0xFFFF
   1385                      }
   1386                      /* Requested rate exceeds the allowed frequencies in LP accel mode,
   1387                       * switch back to full-power mode.
   1388                       */
   1389                      mpu_lp_accel_mode(0);
   \                     ??mpu_set_sample_rate_4:
   \   00003C                ; Setup parameters for call to function mpu_lp_accel_mode
   \   00003C   7900         MOV     R1,#0x0
   \   00003E   12....       LCALL   ??mpu_lp_accel_mode?relay
   1390                  }
   1391                  if (rate < 4)
   \                     ??mpu_set_sample_rate_3:
   \   000041   C3           CLR     C
   \   000042   EE           MOV     A,R6
   \   000043   9404         SUBB    A,#0x4
   \   000045   EF           MOV     A,R7
   \   000046   9400         SUBB    A,#0x0
   \   000048   5006         JNC     ??mpu_set_sample_rate_6
   1392                      rate = 4;
   \   00004A   7E04         MOV     R6,#0x4
   \   00004C   7F00         MOV     R7,#0x0
   \   00004E   800D         SJMP    ??mpu_set_sample_rate_7
   1393                  else if (rate > 1000)
   \                     ??mpu_set_sample_rate_6:
   \   000050   C3           CLR     C
   \   000051   EE           MOV     A,R6
   \   000052   94E9         SUBB    A,#-0x17
   \   000054   EF           MOV     A,R7
   \   000055   9403         SUBB    A,#0x3
   \   000057   4004         JC      ??mpu_set_sample_rate_7
   1394                      rate = 1000;
   \   000059   7EE8         MOV     R6,#-0x18
   \   00005B   7F03         MOV     R7,#0x3
   1395          
   1396                  data = 1000 / rate - 1;
   \                     ??mpu_set_sample_rate_7:
   \   00005D   78E8         MOV     R0,#-0x18
   \   00005F   7903         MOV     R1,#0x3
   \   000061   EE           MOV     A,R6
   \   000062   FA           MOV     R2,A
   \   000063   EF           MOV     A,R7
   \   000064   FB           MOV     R3,A
   \   000065   12....       LCALL   ?US_DIV_MOD
   \   000068   E8           MOV     A,R0
   \   000069   14           DEC     A
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   F0           MOVX    @DPTR,A
   1397                  if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
   \   000071                ; Setup parameters for call to function MPU_Write_Len
   \   000071   AC82         MOV     R4,DPL
   \   000073   AD83         MOV     R5,DPH
   \   000075   7B01         MOV     R3,#0x1
   \   000077   90....       MOV     DPTR,#st
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   F8           MOV     R0,A
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   F583         MOV     DPH,A
   \   000080   8882         MOV     DPL,R0
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   90....       MOV     DPTR,#st + 2
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F8           MOV     R0,A
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   F583         MOV     DPH,A
   \   00008E   8882         MOV     DPL,R0
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F9           MOV     R1,A
   \   000092   12....       LCALL   ??MPU_Write_Len?relay
   \   000095   E9           MOV     A,R1
   \   000096   6003         JZ      $+5
   \   000098   02....       LJMP    ??mpu_set_sample_rate_1 & 0xFFFF
   1398                      return -1;
   1399          
   1400                  st.chip_cfg.sample_rate = 1000 / (1 + data);
   \   00009B   78E8         MOV     R0,#-0x18
   \   00009D   7903         MOV     R1,#0x3
   \   00009F   85..82       MOV     DPL,?XSP + 0
   \   0000A2   85..83       MOV     DPH,?XSP + 1
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   2401         ADD     A,#0x1
   \   0000A8   FA           MOV     R2,A
   \   0000A9   E4           CLR     A
   \   0000AA   3400         ADDC    A,#0x0
   \   0000AC   FB           MOV     R3,A
   \   0000AD   12....       LCALL   ?S_DIV_MOD
   \   0000B0   90....       MOV     DPTR,#st + 9
   \   0000B3   E8           MOV     A,R0
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E9           MOV     A,R1
   \   0000B7   F0           MOVX    @DPTR,A
   1401          
   1402          #ifdef AK89xx_SECONDARY
   1403                  mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
   1404          #endif
   1405          
   1406                  /* Automatically set LPF to 1/2 sampling rate. */
   1407                  mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
   \   0000B8                ; Setup parameters for call to function mpu_set_lpf
   \   0000B8   90....       MOV     DPTR,#st + 9
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   FA           MOV     R2,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   C3           CLR     C
   \   0000C0   13           RRC     A
   \   0000C1   FB           MOV     R3,A
   \   0000C2   EA           MOV     A,R2
   \   0000C3   13           RRC     A
   \   0000C4   FA           MOV     R2,A
   \   0000C5   12....       LCALL   ??mpu_set_lpf?relay
   1408                  return 0;
   \                     ??mpu_set_sample_rate_5:
   \   0000C8   7A00         MOV     R2,#0x0
   \   0000CA   7B00         MOV     R3,#0x0
   \                     ??mpu_set_sample_rate_2:
   \   0000CC   7401         MOV     A,#0x1
   \   0000CE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D1   7F01         MOV     R7,#0x1
   \   0000D3   02....       LJMP    ?BANKED_LEAVE_XDATA
   1409              }
   1410          }
   1411          
   1412          /**
   1413           *  @brief      Get compass sampling rate.
   1414           *  @param[out] rate    Current compass sampling rate (Hz).
   1415           *  @return     0 if successful.
   1416           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1417          int mpu_get_compass_sample_rate(unsigned short *rate)
   \                     mpu_get_compass_sample_rate:
   1418          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1419          #ifdef AK89xx_SECONDARY
   1420              rate[0] = st.chip_cfg.compass_sample_rate;
   1421              return 0;
   1422          #else
   1423              rate[0] = 0;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   F0           MOVX    @DPTR,A
   1424              return -1;
   \   00000C   7AFF         MOV     R2,#-0x1
   \   00000E   7BFF         MOV     R3,#-0x1
   \   000010   D083         POP     DPH
   \   000012   D082         POP     DPL
   \   000014   02....       LJMP    ?BRET
   1425          #endif
   1426          }
   1427          
   1428          /**
   1429           *  @brief      Set compass sampling rate.
   1430           *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
   1431           *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
   1432           *  sampling rate.
   1433           *
   1434           *  \n WARNING: The new rate may be different than what was requested. Call
   1435           *  mpu_get_compass_sample_rate to check the actual setting.
   1436           *  @param[in]  rate    Desired compass sampling rate (Hz).
   1437           *  @return     0 if successful.
   1438           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1439          int mpu_set_compass_sample_rate(unsigned short rate)
   \                     mpu_set_compass_sample_rate:
   1440          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1441          #ifdef AK89xx_SECONDARY
   1442              unsigned char div;
   1443              if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
   1444                  return -1;
   1445          
   1446              div = st.chip_cfg.sample_rate / rate - 1;
   1447              if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
   1448                  return -1;
   1449              st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
   1450              return 0;
   1451          #else
   1452              return -1;
   \   000000   7AFF         MOV     R2,#-0x1
   \   000002   7BFF         MOV     R3,#-0x1
   \   000004   02....       LJMP    ?BRET
   1453          #endif
   1454          }
   1455          
   1456          /**
   1457           *  @brief      Get gyro sensitivity scale factor.
   1458           *  @param[out] sens    Conversion from hardware units to dps.
   1459           *  @return     0 if successful.
   1460           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1461          int mpu_get_gyro_sens(float *sens)
   \                     mpu_get_gyro_sens:
   1462          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   1463              switch (st.chip_cfg.gyro_fsr) {
   \   000009   90....       MOV     DPTR,#st + 4
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   600B         JZ      ??mpu_get_gyro_sens_0
   \   00000F   14           DEC     A
   \   000010   601E         JZ      ??mpu_get_gyro_sens_1
   \   000012   14           DEC     A
   \   000013   6020         JZ      ??mpu_get_gyro_sens_2
   \   000015   14           DEC     A
   \   000016   6022         JZ      ??mpu_get_gyro_sens_3
   \   000018   8025         SJMP    ??mpu_get_gyro_sens_4
   1464              case INV_FSR_250DPS:
   1465                  sens[0] = 131.f;
   \                     ??mpu_get_gyro_sens_0:
   \   00001A   90....       MOV     DPTR,#__Constant_43030000
   \                     ??mpu_get_gyro_sens_5:
   \   00001D   12....       LCALL   ?XLOAD_R2345
   \   000020   8882         MOV     DPL,R0
   \   000022   8983         MOV     DPH,R1
   \   000024   12....       LCALL   ?XSTORE_R2345
   1466                  break;
   1467              case INV_FSR_500DPS:
   1468                  sens[0] = 65.5f;
   1469                  break;
   1470              case INV_FSR_1000DPS:
   1471                  sens[0] = 32.8f;
   1472                  break;
   1473              case INV_FSR_2000DPS:
   1474                  sens[0] = 16.4f;
   1475                  break;
   1476              default:
   1477                  return -1;
   1478              }
   1479              return 0;
   \   000027   7A00         MOV     R2,#0x0
   \   000029   7B00         MOV     R3,#0x0
   \                     ??mpu_get_gyro_sens_6:
   \   00002B   7F01         MOV     R7,#0x1
   \   00002D   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??mpu_get_gyro_sens_1:
   \   000030   90....       MOV     DPTR,#__Constant_42830000
   \   000033   80E8         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_2:
   \   000035   90....       MOV     DPTR,#__Constant_42033333
   \   000038   80E3         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_3:
   \   00003A   90....       MOV     DPTR,#__Constant_41833333
   \   00003D   80DE         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_4:
   \   00003F   7AFF         MOV     R2,#-0x1
   \   000041   7BFF         MOV     R3,#-0x1
   \   000043   80E6         SJMP    ??mpu_get_gyro_sens_6
   1480          }
   1481          
   1482          /**
   1483           *  @brief      Get accel sensitivity scale factor.
   1484           *  @param[out] sens    Conversion from hardware units to g's.
   1485           *  @return     0 if successful.
   1486           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1487          int mpu_get_accel_sens(unsigned short *sens)
   \                     mpu_get_accel_sens:
   1488          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1489              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_sens_0
   \   00000A   14           DEC     A
   \   00000B   6038         JZ      ??mpu_get_accel_sens_1
   \   00000D   14           DEC     A
   \   00000E   6041         JZ      ??mpu_get_accel_sens_2
   \   000010   14           DEC     A
   \   000011   6049         JZ      ??mpu_get_accel_sens_3
   \   000013   8052         SJMP    ??mpu_get_accel_sens_4
   1490              case INV_FSR_2G:
   1491                  sens[0] = 16384;
   \                     ??mpu_get_accel_sens_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7440         MOV     A,#0x40
   \                     ??mpu_get_accel_sens_5:
   \   00001E   F0           MOVX    @DPTR,A
   1492                  break;
   1493              case INV_FSR_4G:
   1494                  sens[0] = 8092;
   1495                  break;
   1496              case INV_FSR_8G:
   1497                  sens[0] = 4096;
   1498                  break;
   1499              case INV_FSR_16G:
   1500                  sens[0] = 2048;
   1501                  break;
   1502              default:
   1503                  return -1;
   1504              }
   1505              if (st.chip_cfg.accel_half)
   \   00001F   90....       MOV     DPTR,#st + 14
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6015         JZ      ??mpu_get_accel_sens_6
   1506                  sens[0] >>= 1;
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   C3           CLR     C
   \   00002E   13           RRC     A
   \   00002F   F9           MOV     R1,A
   \   000030   E8           MOV     A,R0
   \   000031   13           RRC     A
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E9           MOV     A,R1
   \   000039   F0           MOVX    @DPTR,A
   1507              return 0;
   \                     ??mpu_get_accel_sens_6:
   \   00003A   7A00         MOV     R2,#0x0
   \   00003C   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_sens_7:
   \   00003E   D083         POP     DPH
   \   000040   D082         POP     DPL
   \   000042   02....       LJMP    ?BRET
   \                     ??mpu_get_accel_sens_1:
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   749C         MOV     A,#-0x64
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   741F         MOV     A,#0x1f
   \   00004F   80CD         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_2:
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   E4           CLR     A
   \   000056   F0           MOVX    @DPTR,A
   \   000057   A3           INC     DPTR
   \   000058   7410         MOV     A,#0x10
   \   00005A   80C2         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_3:
   \   00005C   8A82         MOV     DPL,R2
   \   00005E   8B83         MOV     DPH,R3
   \   000060   E4           CLR     A
   \   000061   F0           MOVX    @DPTR,A
   \   000062   A3           INC     DPTR
   \   000063   7408         MOV     A,#0x8
   \   000065   80B7         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_4:
   \   000067   7AFF         MOV     R2,#-0x1
   \   000069   7BFF         MOV     R3,#-0x1
   \   00006B   80D1         SJMP    ??mpu_get_accel_sens_7
   1508          }
   1509          
   1510          /**
   1511           *  @brief      Get current FIFO configuration.
   1512           *  @e sensors can contain a combination of the following flags:
   1513           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1514           *  \n INV_XYZ_GYRO
   1515           *  \n INV_XYZ_ACCEL
   1516           *  @param[out] sensors Mask of sensors in FIFO.
   1517           *  @return     0 if successful.
   1518           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1519          int mpu_get_fifo_config(unsigned char *sensors)
   \                     mpu_get_fifo_config:
   1520          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1521              sensors[0] = st.chip_cfg.fifo_enable;
   \   000004   90....       MOV     DPTR,#st + 11
   \   000007   E0           MOVX    A,@DPTR
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   F0           MOVX    @DPTR,A
   1522              return 0;
   \   00000D   7A00         MOV     R2,#0x0
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   D083         POP     DPH
   \   000013   D082         POP     DPL
   \   000015   02....       LJMP    ?BRET
   1523          }
   1524          
   1525          /**
   1526           *  @brief      Select which sensors are pushed to FIFO.
   1527           *  @e sensors can contain a combination of the following flags:
   1528           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1529           *  \n INV_XYZ_GYRO
   1530           *  \n INV_XYZ_ACCEL
   1531           *  @param[in]  sensors Mask of sensors to push to FIFO.
   1532           *  @return     0 if successful.
   1533           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1534          int mpu_configure_fifo(unsigned char sensors)
   \                     mpu_configure_fifo:
   1535          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1536              unsigned char prev;
   1537              int result = 0;
   1538          
   1539              /* Compass data isn't going into the FIFO. Stop trying. */
   1540              sensors &= ~INV_XYZ_COMPASS;
   \   000005   E9           MOV     A,R1
   \   000006   C2E0         CLR     0xE0 /* A   */.0
   \   000008   F5..         MOV     ?V0 + 0,A
   1541          
   1542              if (st.chip_cfg.dmp_on)
   \   00000A   90....       MOV     DPTR,#st + 29
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6006         JZ      ??mpu_configure_fifo_0
   1543                  return 0;
   \   000010   7A00         MOV     R2,#0x0
   \   000012   7B00         MOV     R3,#0x0
   \   000014   8054         SJMP    ??mpu_configure_fifo_1
   1544              else {
   1545                  if (!(st.chip_cfg.sensors))
   \                     ??mpu_configure_fifo_0:
   \   000016   90....       MOV     DPTR,#st + 6
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F8           MOV     R0,A
   \   00001B   7006         JNZ     ??mpu_configure_fifo_2
   1546                      return -1;
   \                     ??mpu_configure_fifo_3:
   \   00001D   7AFF         MOV     R2,#-0x1
   \   00001F   7BFF         MOV     R3,#-0x1
   \   000021   8047         SJMP    ??mpu_configure_fifo_1
   1547                  prev = st.chip_cfg.fifo_enable;
   \                     ??mpu_configure_fifo_2:
   \   000023   90....       MOV     DPTR,#st + 11
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F5..         MOV     ?V0 + 1,A
   1548                  st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
   \   000029   E5..         MOV     A,?V0 + 0
   \   00002B   58           ANL     A,R0
   \   00002C   F8           MOV     R0,A
   \   00002D   F0           MOVX    @DPTR,A
   1549                  if (st.chip_cfg.fifo_enable != sensors)
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   68           XRL     A,R0
   \   000031   6006         JZ      ??mpu_configure_fifo_4
   1550                      /* You're not getting what you asked for. Some sensors are
   1551                       * asleep.
   1552                       */
   1553                      result = -1;
   \   000033   7EFF         MOV     R6,#-0x1
   \   000035   7FFF         MOV     R7,#-0x1
   \   000037   8004         SJMP    ??mpu_configure_fifo_5
   1554                  else
   1555                      result = 0;
   \                     ??mpu_configure_fifo_4:
   \   000039   7E00         MOV     R6,#0x0
   \   00003B   7F00         MOV     R7,#0x0
   1556                  if (sensors || st.chip_cfg.lp_accel_mode)
   \                     ??mpu_configure_fifo_5:
   \   00003D   E5..         MOV     A,?V0 + 0
   \   00003F   7006         JNZ     ??mpu_configure_fifo_6
   \   000041   90....       MOV     DPTR,#st + 15
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6004         JZ      ??mpu_configure_fifo_7
   1557                      set_int_enable(1);
   \                     ??mpu_configure_fifo_6:
   \   000047                ; Setup parameters for call to function set_int_enable
   \   000047   7901         MOV     R1,#0x1
   \   000049   8002         SJMP    ??mpu_configure_fifo_8
   1558                  else
   1559                      set_int_enable(0);
   \                     ??mpu_configure_fifo_7:
   \   00004B                ; Setup parameters for call to function set_int_enable
   \   00004B   7900         MOV     R1,#0x0
   \                     ??mpu_configure_fifo_8:
   \   00004D   12....       LCALL   ??set_int_enable?relay
   1560                  if (sensors) {
   \   000050   E5..         MOV     A,?V0 + 0
   \   000052   6012         JZ      ??mpu_configure_fifo_9
   1561                      if (mpu_reset_fifo()) {
   \   000054                ; Setup parameters for call to function mpu_reset_fifo
   \   000054   12....       LCALL   ??mpu_reset_fifo?relay
   \   000057   8B..         MOV     ?V0 + 3,R3
   \   000059   EA           MOV     A,R2
   \   00005A   45..         ORL     A,?V0 + 3
   \   00005C   6008         JZ      ??mpu_configure_fifo_9
   1562                          st.chip_cfg.fifo_enable = prev;
   \   00005E   E5..         MOV     A,?V0 + 1
   \   000060   90....       MOV     DPTR,#st + 11
   \   000063   F0           MOVX    @DPTR,A
   1563                          return -1;
   \   000064   80B7         SJMP    ??mpu_configure_fifo_3
   1564                      }
   1565                  }
   1566              }
   1567          
   1568              return result;
   \                     ??mpu_configure_fifo_9:
   \   000066   EE           MOV     A,R6
   \   000067   FA           MOV     R2,A
   \   000068   EF           MOV     A,R7
   \   000069   FB           MOV     R3,A
   \                     ??mpu_configure_fifo_1:
   \   00006A   7F04         MOV     R7,#0x4
   \   00006C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1569          }
   1570          
   1571          /**
   1572           *  @brief      Get current power state.
   1573           *  @param[in]  power_on    1 if turned on, 0 if suspended.
   1574           *  @return     0 if successful.
   1575           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1576          int mpu_get_power_state(unsigned char *power_on)
   \                     mpu_get_power_state:
   1577          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1578              if (st.chip_cfg.sensors)
   \   000004   90....       MOV     DPTR,#st + 6
   \   000007   E0           MOVX    A,@DPTR
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   6004         JZ      ??mpu_get_power_state_0
   1579                  power_on[0] = 1;
   \   00000E   7401         MOV     A,#0x1
   \   000010   8001         SJMP    ??mpu_get_power_state_1
   1580              else
   1581                  power_on[0] = 0;
   \                     ??mpu_get_power_state_0:
   \   000012   E4           CLR     A
   \                     ??mpu_get_power_state_1:
   \   000013   F0           MOVX    @DPTR,A
   1582              return 0;
   \   000014   7A00         MOV     R2,#0x0
   \   000016   7B00         MOV     R3,#0x0
   \   000018   D083         POP     DPH
   \   00001A   D082         POP     DPL
   \   00001C   02....       LJMP    ?BRET
   1583          }
   1584          
   1585          /**
   1586           *  @brief      Turn specific sensors on/off.
   1587           *  @e sensors can contain a combination of the following flags:
   1588           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1589           *  \n INV_XYZ_GYRO
   1590           *  \n INV_XYZ_ACCEL
   1591           *  \n INV_XYZ_COMPASS
   1592           *  @param[in]  sensors    Mask of sensors to wake.
   1593           *  @return     0 if successful.
   1594           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1595          int mpu_set_sensors(unsigned char sensors)
   \                     mpu_set_sensors:
   1596          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1597              unsigned char data;
   1598          #ifdef AK89xx_SECONDARY
   1599              unsigned char user_ctrl;
   1600          #endif
   1601          
   1602              if (sensors & INV_XYZ_GYRO)
   \   00000C   7470         MOV     A,#0x70
   \   00000E   5E           ANL     A,R6
   \   00000F   600A         JZ      ??mpu_set_sensors_0
   1603                  data = INV_CLK_PLL;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7401         MOV     A,#0x1
   \   000019   800E         SJMP    ??mpu_set_sensors_1
   1604              else if (sensors)
   \                     ??mpu_set_sensors_0:
   \   00001B   EE           MOV     A,R6
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   6003         JZ      ??mpu_set_sensors_2
   1605                  data = 0;
   \   000024   E4           CLR     A
   \   000025   8002         SJMP    ??mpu_set_sensors_1
   1606              else
   1607                  data = BIT_SLEEP;
   \                     ??mpu_set_sensors_2:
   \   000027   7440         MOV     A,#0x40
   \                     ??mpu_set_sensors_1:
   \   000029   F0           MOVX    @DPTR,A
   1608              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
   \   00002A                ; Setup parameters for call to function MPU_Write_Len
   \   00002A   AC82         MOV     R4,DPL
   \   00002C   AD83         MOV     R5,DPH
   \   00002E   7B01         MOV     R3,#0x1
   \   000030   90....       MOV     DPTR,#st
   \   000033   E0           MOVX    A,@DPTR
   \   000034   2412         ADD     A,#0x12
   \   000036   F8           MOV     R0,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   3400         ADDC    A,#0x0
   \   00003B   F9           MOV     R1,A
   \   00003C   8882         MOV     DPL,R0
   \   00003E   8983         MOV     DPH,R1
   \   000040   E0           MOVX    A,@DPTR
   \   000041   FA           MOV     R2,A
   \   000042   90....       MOV     DPTR,#st + 2
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F583         MOV     DPH,A
   \   00004B   8882         MOV     DPL,R0
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F9           MOV     R1,A
   \   00004F   12....       LCALL   ??MPU_Write_Len?relay
   \   000052   E9           MOV     A,R1
   \   000053   600C         JZ      ??mpu_set_sensors_3
   1609                  st.chip_cfg.sensors = 0;
   \                     ??mpu_set_sensors_4:
   \   000055   90....       MOV     DPTR,#st + 6
   \   000058   E4           CLR     A
   \   000059   F0           MOVX    @DPTR,A
   1610                  return -1;
   \   00005A   7AFF         MOV     R2,#-0x1
   \   00005C   7BFF         MOV     R3,#-0x1
   \   00005E   02....       LJMP    ??mpu_set_sensors_5 & 0xFFFF
   1611              }
   1612              st.chip_cfg.clk_src = data & ~BIT_SLEEP;
   \                     ??mpu_set_sensors_3:
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   54BF         ANL     A,#0xbf
   \   00006A   90....       MOV     DPTR,#st + 8
   \   00006D   F0           MOVX    @DPTR,A
   1613          
   1614              data = 0;
   \   00006E   85..82       MOV     DPL,?XSP + 0
   \   000071   85..83       MOV     DPH,?XSP + 1
   \   000074   E4           CLR     A
   \   000075   F0           MOVX    @DPTR,A
   1615              if (!(sensors & INV_X_GYRO))
   \   000076   EE           MOV     A,R6
   \   000077   A2E6         MOV     C,0xE0 /* A   */.6
   \   000079   4003         JC      ??mpu_set_sensors_6
   1616                  data |= BIT_STBY_XG;
   \   00007B   7404         MOV     A,#0x4
   \   00007D   F0           MOVX    @DPTR,A
   1617              if (!(sensors & INV_Y_GYRO))
   \                     ??mpu_set_sensors_6:
   \   00007E   EE           MOV     A,R6
   \   00007F   A2E5         MOV     C,0xE0 /* A   */.5
   \   000081   4004         JC      ??mpu_set_sensors_7
   1618                  data |= BIT_STBY_YG;
   \   000083   E0           MOVX    A,@DPTR
   \   000084   D2E1         SETB    0xE0 /* A   */.1
   \   000086   F0           MOVX    @DPTR,A
   1619              if (!(sensors & INV_Z_GYRO))
   \                     ??mpu_set_sensors_7:
   \   000087   EE           MOV     A,R6
   \   000088   A2E4         MOV     C,0xE0 /* A   */.4
   \   00008A   4004         JC      ??mpu_set_sensors_8
   1620                  data |= BIT_STBY_ZG;
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   D2E0         SETB    0xE0 /* A   */.0
   \   00008F   F0           MOVX    @DPTR,A
   1621              if (!(sensors & INV_XYZ_ACCEL))
   \                     ??mpu_set_sensors_8:
   \   000090   EE           MOV     A,R6
   \   000091   A2E3         MOV     C,0xE0 /* A   */.3
   \   000093   4004         JC      ??mpu_set_sensors_9
   1622                  data |= BIT_STBY_XYZA;
   \   000095   E0           MOVX    A,@DPTR
   \   000096   4438         ORL     A,#0x38
   \   000098   F0           MOVX    @DPTR,A
   1623              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
   \                     ??mpu_set_sensors_9:
   \   000099                ; Setup parameters for call to function MPU_Write_Len
   \   000099   AC82         MOV     R4,DPL
   \   00009B   AD83         MOV     R5,DPH
   \   00009D   7B01         MOV     R3,#0x1
   \   00009F   90....       MOV     DPTR,#st
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   2413         ADD     A,#0x13
   \   0000A5   F8           MOV     R0,A
   \   0000A6   A3           INC     DPTR
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   3400         ADDC    A,#0x0
   \   0000AA   F9           MOV     R1,A
   \   0000AB   8882         MOV     DPL,R0
   \   0000AD   8983         MOV     DPH,R1
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   FA           MOV     R2,A
   \   0000B1   90....       MOV     DPTR,#st + 2
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   F8           MOV     R0,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   F583         MOV     DPH,A
   \   0000BA   8882         MOV     DPL,R0
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   12....       LCALL   ??MPU_Write_Len?relay
   \   0000C1   E9           MOV     A,R1
   \   0000C2   7091         JNZ     ??mpu_set_sensors_4
   1624                  st.chip_cfg.sensors = 0;
   1625                  return -1;
   1626              }
   1627          
   1628              if (sensors && (sensors != INV_XYZ_ACCEL))
   \   0000C4   EE           MOV     A,R6
   \   0000C5   600A         JZ      ??mpu_set_sensors_10
   \   0000C7   7408         MOV     A,#0x8
   \   0000C9   6E           XRL     A,R6
   \   0000CA   6005         JZ      ??mpu_set_sensors_10
   1629                  /* Latched interrupts only used in LP accel mode. */
   1630                  mpu_set_int_latched(0);
   \   0000CC                ; Setup parameters for call to function mpu_set_int_latched
   \   0000CC   7900         MOV     R1,#0x0
   \   0000CE   12....       LCALL   ??mpu_set_int_latched?relay
   1631          
   1632          #ifdef AK89xx_SECONDARY
   1633          #ifdef AK89xx_BYPASS
   1634              if (sensors & INV_XYZ_COMPASS)
   1635                  mpu_set_bypass(1);
   1636              else
   1637                  mpu_set_bypass(0);
   1638          #else
   1639              if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1640                  return -1;
   1641              /* Handle AKM power management. */
   1642              if (sensors & INV_XYZ_COMPASS) {
   1643                  data = AKM_SINGLE_MEASUREMENT;
   1644                  user_ctrl |= BIT_AUX_IF_EN;
   1645              } else {
   1646                  data = AKM_POWER_DOWN;
   1647                  user_ctrl &= ~BIT_AUX_IF_EN;
   1648              }
   1649              if (st.chip_cfg.dmp_on)
   1650                  user_ctrl |= BIT_DMP_EN;
   1651              else
   1652                  user_ctrl &= ~BIT_DMP_EN;
   1653              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
   1654                  return -1;
   1655              /* Enable/disable I2C master mode. */
   1656              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1657                  return -1;
   1658          #endif
   1659          #endif
   1660          
   1661              st.chip_cfg.sensors = sensors;
   \                     ??mpu_set_sensors_10:
   \   0000D1   EE           MOV     A,R6
   \   0000D2   90....       MOV     DPTR,#st + 6
   \   0000D5   F0           MOVX    @DPTR,A
   1662              st.chip_cfg.lp_accel_mode = 0;
   \   0000D6   90....       MOV     DPTR,#st + 15
   \   0000D9   E4           CLR     A
   \   0000DA   F0           MOVX    @DPTR,A
   1663              delay_ms(50);
   \   0000DB                ; Setup parameters for call to function delay_ms
   \   0000DB   90....       MOV     DPTR,#__Constant_32
   \   0000DE   12....       LCALL   ?XLOAD_R2345
   \   0000E1   12....       LCALL   ??delay_ms?relay
   1664              return 0;
   \   0000E4   7A00         MOV     R2,#0x0
   \   0000E6   7B00         MOV     R3,#0x0
   \                     ??mpu_set_sensors_5:
   \   0000E8   7401         MOV     A,#0x1
   \   0000EA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000ED   7F01         MOV     R7,#0x1
   \   0000EF   02....       LJMP    ?BANKED_LEAVE_XDATA
   1665          }
   1666          
   1667          /**
   1668           *  @brief      Read the MPU interrupt status registers.
   1669           *  @param[out] status  Mask of interrupt bits.
   1670           *  @return     0 if successful.
   1671           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1672          int mpu_get_int_status(short *status)
   \                     mpu_get_int_status:
   1673          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1674              unsigned char tmp[2];
   1675              if (!st.chip_cfg.sensors)
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7006         JNZ     ??mpu_get_int_status_0
   1676                  return -1;
   \                     ??mpu_get_int_status_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   804B         SJMP    ??mpu_get_int_status_2
   1677              if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
   \                     ??mpu_get_int_status_0:
   \   00001A                ; Setup parameters for call to function MPU_Read_Len
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   AC82         MOV     R4,DPL
   \   000022   AD83         MOV     R5,DPH
   \   000024   7B02         MOV     R3,#0x2
   \   000026   90....       MOV     DPTR,#st
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   2410         ADD     A,#0x10
   \   00002C   F8           MOV     R0,A
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   3400         ADDC    A,#0x0
   \   000031   F9           MOV     R1,A
   \   000032   8882         MOV     DPL,R0
   \   000034   8983         MOV     DPH,R1
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FA           MOV     R2,A
   \   000038   90....       MOV     DPTR,#st + 2
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F583         MOV     DPH,A
   \   000041   8882         MOV     DPL,R0
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   ??MPU_Read_Len?relay
   \   000048   E9           MOV     A,R1
   \   000049   70C9         JNZ     ??mpu_get_int_status_1
   1678                  return -1;
   1679              status[0] = (tmp[0] << 8) | tmp[1];
   \   00004B   85..82       MOV     DPL,?XSP + 0
   \   00004E   85..83       MOV     DPH,?XSP + 1
   \   000051   E0           MOVX    A,@DPTR
   \   000052   F9           MOV     R1,A
   \   000053   7401         MOV     A,#0x1
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   E0           MOVX    A,@DPTR
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E9           MOV     A,R1
   \   000060   F0           MOVX    @DPTR,A
   1680              return 0;
   \   000061   7A00         MOV     R2,#0x0
   \   000063   7B00         MOV     R3,#0x0
   \                     ??mpu_get_int_status_2:
   \   000065   7402         MOV     A,#0x2
   \   000067   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006A   7F01         MOV     R7,#0x1
   \   00006C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1681          }
   1682          
   1683          /**
   1684           *  @brief      Get one packet from the FIFO.
   1685           *  If @e sensors does not contain a particular sensor, disregard the data
   1686           *  returned to that pointer.
   1687           *  \n @e sensors can contain a combination of the following flags:
   1688           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1689           *  \n INV_XYZ_GYRO
   1690           *  \n INV_XYZ_ACCEL
   1691           *  \n If the FIFO has no new data, @e sensors will be zero.
   1692           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
   1693           *  return a non-zero error code.
   1694           *  @param[out] gyro        Gyro data in hardware units.
   1695           *  @param[out] accel       Accel data in hardware units.
   1696           *  @param[out] timestamp   Timestamp in milliseconds.
   1697           *  @param[out] sensors     Mask of sensors read from FIFO.
   1698           *  @param[out] more        Number of remaining packets.
   1699           *  @return     0 if successful.
   1700           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1701          int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
   \                     mpu_read_fifo:
   1702                  unsigned char *sensors, unsigned char *more)
   1703          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 10,R2
   \   00000C   8B..         MOV     ?V0 + 11,R3
   \   00000E   8C..         MOV     ?V0 + 8,R4
   \   000010   8D..         MOV     ?V0 + 9,R5
   \   000012   7424         MOV     A,#0x24
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 12,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 13,A
   \   00001E   7426         MOV     A,#0x26
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 6,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F5..         MOV     ?V0 + 7,A
   1704              /* Assumes maximum packet size is gyro (6) + accel (6). */
   1705              unsigned char data[MAX_PACKET_LENGTH];
   1706              unsigned char packet_size = 0;
   \   00002A   75..00       MOV     ?V0 + 0,#0x0
   1707              unsigned short fifo_count, index = 0;
   \   00002D   75..00       MOV     ?V0 + 2,#0x0
   \   000030   75..00       MOV     ?V0 + 3,#0x0
   1708          
   1709              if (st.chip_cfg.dmp_on)
   \   000033   90....       MOV     DPTR,#st + 29
   \   000036   E0           MOVX    A,@DPTR
   \   000037   600E         JZ      ??mpu_read_fifo_0
   1710                  return -1;
   \                     ??mpu_read_fifo_1:
   \   000039   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_2:
   \   00003B   7BFF         MOV     R3,#-0x1
   \                     ??mpu_read_fifo_3:
   \   00003D   740C         MOV     A,#0xc
   \   00003F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000042   7F10         MOV     R7,#0x10
   \   000044   02....       LJMP    ?BANKED_LEAVE_XDATA
   1711          
   1712              sensors[0] = 0;
   \                     ??mpu_read_fifo_0:
   \   000047   85..82       MOV     DPL,?V0 + 6
   \   00004A   85..83       MOV     DPH,?V0 + 7
   \   00004D   E4           CLR     A
   \   00004E   F0           MOVX    @DPTR,A
   1713              if (!st.chip_cfg.sensors)
   \   00004F   90....       MOV     DPTR,#st + 6
   \   000052   E0           MOVX    A,@DPTR
   \   000053   60E4         JZ      ??mpu_read_fifo_1
   1714                  return -1;
   1715              if (!st.chip_cfg.fifo_enable)
   \   000055   90....       MOV     DPTR,#st + 11
   \   000058   E0           MOVX    A,@DPTR
   \   000059   60DE         JZ      ??mpu_read_fifo_1
   1716                  return -1;
   1717          
   1718              if (st.chip_cfg.fifo_enable & INV_X_GYRO)
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   A2E6         MOV     C,0xE0 /* A   */.6
   \   00005E   5003         JNC     ??mpu_read_fifo_4
   1719                  packet_size += 2;
   \   000060   75..02       MOV     ?V0 + 0,#0x2
   1720              if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
   \                     ??mpu_read_fifo_4:
   \   000063   E0           MOVX    A,@DPTR
   \   000064   A2E5         MOV     C,0xE0 /* A   */.5
   \   000066   5004         JNC     ??mpu_read_fifo_5
   1721                  packet_size += 2;
   \   000068   05..         INC     ?V0 + 0
   \   00006A   05..         INC     ?V0 + 0
   1722              if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
   \                     ??mpu_read_fifo_5:
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   A2E4         MOV     C,0xE0 /* A   */.4
   \   00006F   5004         JNC     ??mpu_read_fifo_6
   1723                  packet_size += 2;
   \   000071   05..         INC     ?V0 + 0
   \   000073   05..         INC     ?V0 + 0
   1724              if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
   \                     ??mpu_read_fifo_6:
   \   000075   E0           MOVX    A,@DPTR
   \   000076   A2E3         MOV     C,0xE0 /* A   */.3
   \   000078   5006         JNC     ??mpu_read_fifo_7
   1725                  packet_size += 6;
   \   00007A   7406         MOV     A,#0x6
   \   00007C   25..         ADD     A,?V0 + 0
   \   00007E   F5..         MOV     ?V0 + 0,A
   1726          
   1727              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \                     ??mpu_read_fifo_7:
   \   000080                ; Setup parameters for call to function MPU_Read_Len
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   AC82         MOV     R4,DPL
   \   000088   AD83         MOV     R5,DPH
   \   00008A   7B02         MOV     R3,#0x2
   \   00008C   90....       MOV     DPTR,#st
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F8           MOV     R0,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   F583         MOV     DPH,A
   \   000095   8882         MOV     DPL,R0
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   FA           MOV     R2,A
   \   0000A3   90....       MOV     DPTR,#st + 2
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F8           MOV     R0,A
   \   0000A8   A3           INC     DPTR
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   F583         MOV     DPH,A
   \   0000AC   8882         MOV     DPL,R0
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   F9           MOV     R1,A
   \   0000B0   12....       LCALL   ??MPU_Read_Len?relay
   \   0000B3   E9           MOV     A,R1
   \   0000B4   7083         JNZ     ??mpu_read_fifo_1
   1728                  return -1;
   1729              fifo_count = (data[0] << 8) | data[1];
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   7401         MOV     A,#0x1
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   FE           MOV     R6,A
   \   0000C5   E9           MOV     A,R1
   \   0000C6   FF           MOV     R7,A
   1730              if (fifo_count < packet_size)
   \   0000C7   85..82       MOV     DPL,?V0 + 0
   \   0000CA   8582..       MOV     ?V0 + 4,DPL
   \   0000CD   C3           CLR     C
   \   0000CE   EE           MOV     A,R6
   \   0000CF   95..         SUBB    A,?V0 + 4
   \   0000D1   EF           MOV     A,R7
   \   0000D2   9400         SUBB    A,#0x0
   \   0000D4   5007         JNC     ??mpu_read_fifo_8
   1731                  return 0;
   \                     ??mpu_read_fifo_9:
   \   0000D6   7A00         MOV     R2,#0x0
   \   0000D8   7B00         MOV     R3,#0x0
   \   0000DA   02....       LJMP    ??mpu_read_fifo_3 & 0xFFFF
   1732          //    log_i("FIFO count: %hd\n", fifo_count);
   1733              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_8:
   \   0000DD   90....       MOV     DPTR,#st + 2
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   F8           MOV     R0,A
   \   0000E2   A3           INC     DPTR
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   F9           MOV     R1,A
   \   0000E5   8882         MOV     DPL,R0
   \   0000E7   8983         MOV     DPH,R1
   \   0000E9   A3           INC     DPTR
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   FA           MOV     R2,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   E0           MOVX    A,@DPTR
   \   0000EE   C3           CLR     C
   \   0000EF   13           RRC     A
   \   0000F0   FB           MOV     R3,A
   \   0000F1   EA           MOV     A,R2
   \   0000F2   13           RRC     A
   \   0000F3   C3           CLR     C
   \   0000F4   9E           SUBB    A,R6
   \   0000F5   EB           MOV     A,R3
   \   0000F6   9F           SUBB    A,R7
   \   0000F7   5041         JNC     ??mpu_read_fifo_10
   1734                  /* FIFO is 50% full, better check overflow bit. */
   1735                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
   \   0000F9                ; Setup parameters for call to function MPU_Read_Len
   \   0000F9   85..82       MOV     DPL,?XSP + 0
   \   0000FC   85..83       MOV     DPH,?XSP + 1
   \   0000FF   AC82         MOV     R4,DPL
   \   000101   AD83         MOV     R5,DPH
   \   000103   7B01         MOV     R3,#0x1
   \   000105   90....       MOV     DPTR,#st
   \   000108   E0           MOVX    A,@DPTR
   \   000109   2411         ADD     A,#0x11
   \   00010B   F5..         MOV     ?V0 + 14,A
   \   00010D   A3           INC     DPTR
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   3400         ADDC    A,#0x0
   \   000111   85..82       MOV     DPL,?V0 + 14
   \   000114   F583         MOV     DPH,A
   \   000116   E0           MOVX    A,@DPTR
   \   000117   FA           MOV     R2,A
   \   000118   8882         MOV     DPL,R0
   \   00011A   8983         MOV     DPH,R1
   \   00011C   E0           MOVX    A,@DPTR
   \   00011D   F9           MOV     R1,A
   \   00011E   12....       LCALL   ??MPU_Read_Len?relay
   \   000121   E9           MOV     A,R1
   \   000122   6003         JZ      $+5
   \   000124   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1736                      return -1;
   1737                  if (data[0] & BIT_FIFO_OVERFLOW) {
   \   000127   85..82       MOV     DPL,?XSP + 0
   \   00012A   85..83       MOV     DPH,?XSP + 1
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   A2E4         MOV     C,0xE0 /* A   */.4
   \   000130   5008         JNC     ??mpu_read_fifo_10
   1738                      mpu_reset_fifo();
   \   000132                ; Setup parameters for call to function mpu_reset_fifo
   \   000132   12....       LCALL   ??mpu_reset_fifo?relay
   1739                      return -2;
   \   000135   7AFE         MOV     R2,#-0x2
   \   000137   02....       LJMP    ??mpu_read_fifo_2 & 0xFFFF
   1740                  }
   1741              }
   1742              get_ms((unsigned long*)timestamp);
   \                     ??mpu_read_fifo_10:
   \   00013A                ; Setup parameters for call to function mget_ms
   \   00013A   AA..         MOV     R2,?V0 + 12
   \   00013C   AB..         MOV     R3,?V0 + 13
   \   00013E   12....       LCALL   ??mget_ms?relay
   1743          
   1744              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
   \   000141                ; Setup parameters for call to function MPU_Read_Len
   \   000141   85..82       MOV     DPL,?XSP + 0
   \   000144   85..83       MOV     DPH,?XSP + 1
   \   000147   AC82         MOV     R4,DPL
   \   000149   AD83         MOV     R5,DPH
   \   00014B   AB..         MOV     R3,?V0 + 0
   \   00014D   90....       MOV     DPTR,#st
   \   000150   E0           MOVX    A,@DPTR
   \   000151   240B         ADD     A,#0xb
   \   000153   F8           MOV     R0,A
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   3400         ADDC    A,#0x0
   \   000158   F9           MOV     R1,A
   \   000159   8882         MOV     DPL,R0
   \   00015B   8983         MOV     DPH,R1
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   FA           MOV     R2,A
   \   00015F   90....       MOV     DPTR,#st + 2
   \   000162   E0           MOVX    A,@DPTR
   \   000163   F8           MOV     R0,A
   \   000164   A3           INC     DPTR
   \   000165   E0           MOVX    A,@DPTR
   \   000166   F583         MOV     DPH,A
   \   000168   8882         MOV     DPL,R0
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   F9           MOV     R1,A
   \   00016C   12....       LCALL   ??MPU_Read_Len?relay
   \   00016F   E9           MOV     A,R1
   \   000170   6003         JZ      $+5
   \   000172   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1745                  return -1;
   1746              more[0] = fifo_count / packet_size - 1;
   \   000175   EE           MOV     A,R6
   \   000176   F8           MOV     R0,A
   \   000177   EF           MOV     A,R7
   \   000178   F9           MOV     R1,A
   \   000179   AA..         MOV     R2,?V0 + 4
   \   00017B   7B00         MOV     R3,#0x0
   \   00017D   12....       LCALL   ?US_DIV_MOD
   \   000180   E8           MOV     A,R0
   \   000181   14           DEC     A
   \   000182   C0E0         PUSH    A
   \   000184   7428         MOV     A,#0x28
   \   000186   12....       LCALL   ?XSTACK_DISP0_8
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   F8           MOV     R0,A
   \   00018B   A3           INC     DPTR
   \   00018C   E0           MOVX    A,@DPTR
   \   00018D   F583         MOV     DPH,A
   \   00018F   8882         MOV     DPL,R0
   \   000191   D0E0         POP     A
   \   000193   F0           MOVX    @DPTR,A
   1747              sensors[0] = 0;
   \   000194   85..82       MOV     DPL,?V0 + 6
   \   000197   85..83       MOV     DPH,?V0 + 7
   \   00019A   E4           CLR     A
   \   00019B   F0           MOVX    @DPTR,A
   1748          
   1749              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
   \   00019C   E5..         MOV     A,?V0 + 0
   \   00019E   6061         JZ      ??mpu_read_fifo_11
   \   0001A0   90....       MOV     DPTR,#st + 11
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   A2E3         MOV     C,0xE0 /* A   */.3
   \   0001A6   5059         JNC     ??mpu_read_fifo_11
   1750                  accel[0] = (data[index+0] << 8) | data[index+1];
   \   0001A8   85..82       MOV     DPL,?XSP + 0
   \   0001AB   85..83       MOV     DPH,?XSP + 1
   \   0001AE   E0           MOVX    A,@DPTR
   \   0001AF   F9           MOV     R1,A
   \   0001B0   7401         MOV     A,#0x1
   \   0001B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B5   E0           MOVX    A,@DPTR
   \   0001B6   85..82       MOV     DPL,?V0 + 8
   \   0001B9   85..83       MOV     DPH,?V0 + 9
   \   0001BC   F0           MOVX    @DPTR,A
   \   0001BD   A3           INC     DPTR
   \   0001BE   E9           MOV     A,R1
   \   0001BF   F0           MOVX    @DPTR,A
   1751                  accel[1] = (data[index+2] << 8) | data[index+3];
   \   0001C0   7402         MOV     A,#0x2
   \   0001C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C5   E0           MOVX    A,@DPTR
   \   0001C6   F9           MOV     R1,A
   \   0001C7   7403         MOV     A,#0x3
   \   0001C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CC   E0           MOVX    A,@DPTR
   \   0001CD   85..82       MOV     DPL,?V0 + 8
   \   0001D0   85..83       MOV     DPH,?V0 + 9
   \   0001D3   A3           INC     DPTR
   \   0001D4   A3           INC     DPTR
   \   0001D5   F0           MOVX    @DPTR,A
   \   0001D6   A3           INC     DPTR
   \   0001D7   E9           MOV     A,R1
   \   0001D8   F0           MOVX    @DPTR,A
   1752                  accel[2] = (data[index+4] << 8) | data[index+5];
   \   0001D9   7404         MOV     A,#0x4
   \   0001DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DE   E0           MOVX    A,@DPTR
   \   0001DF   F9           MOV     R1,A
   \   0001E0   7405         MOV     A,#0x5
   \   0001E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E5   E0           MOVX    A,@DPTR
   \   0001E6   85..82       MOV     DPL,?V0 + 8
   \   0001E9   85..83       MOV     DPH,?V0 + 9
   \   0001EC   A3           INC     DPTR
   \   0001ED   A3           INC     DPTR
   \   0001EE   A3           INC     DPTR
   \   0001EF   A3           INC     DPTR
   \   0001F0   F0           MOVX    @DPTR,A
   \   0001F1   A3           INC     DPTR
   \   0001F2   E9           MOV     A,R1
   \   0001F3   F0           MOVX    @DPTR,A
   1753                  sensors[0] |= INV_XYZ_ACCEL;
   \   0001F4   85..82       MOV     DPL,?V0 + 6
   \   0001F7   85..83       MOV     DPH,?V0 + 7
   \   0001FA   E0           MOVX    A,@DPTR
   \   0001FB   D2E3         SETB    0xE0 /* A   */.3
   \   0001FD   F0           MOVX    @DPTR,A
   1754                  index += 6;
   \   0001FE   75..06       MOV     ?V0 + 2,#0x6
   1755              }
   1756              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
   \                     ??mpu_read_fifo_11:
   \   000201   E5..         MOV     A,?V0 + 4
   \   000203   65..         XRL     A,?V0 + 2
   \   000205   7001         JNZ     ??mpu_read_fifo_12
   \   000207   E4           CLR     A
   \                     ??mpu_read_fifo_12:
   \   000208   603D         JZ      ??mpu_read_fifo_13
   \   00020A   90....       MOV     DPTR,#st + 11
   \   00020D   E0           MOVX    A,@DPTR
   \   00020E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000210   5035         JNC     ??mpu_read_fifo_13
   1757                  gyro[0] = (data[index+0] << 8) | data[index+1];
   \   000212   85..82       MOV     DPL,?XSP + 0
   \   000215   85..83       MOV     DPH,?XSP + 1
   \   000218   E582         MOV     A,DPL
   \   00021A   25..         ADD     A,?V0 + 2
   \   00021C   F582         MOV     DPL,A
   \   00021E   E583         MOV     A,DPH
   \   000220   3400         ADDC    A,#0x0
   \   000222   F583         MOV     DPH,A
   \   000224   E0           MOVX    A,@DPTR
   \   000225   F9           MOV     R1,A
   \   000226   A3           INC     DPTR
   \   000227   E0           MOVX    A,@DPTR
   \   000228   85..82       MOV     DPL,?V0 + 10
   \   00022B   85..83       MOV     DPH,?V0 + 11
   \   00022E   F0           MOVX    @DPTR,A
   \   00022F   A3           INC     DPTR
   \   000230   E9           MOV     A,R1
   \   000231   F0           MOVX    @DPTR,A
   1758                  sensors[0] |= INV_X_GYRO;
   \   000232   85..82       MOV     DPL,?V0 + 6
   \   000235   85..83       MOV     DPH,?V0 + 7
   \   000238   E0           MOVX    A,@DPTR
   \   000239   D2E6         SETB    0xE0 /* A   */.6
   \   00023B   F0           MOVX    @DPTR,A
   1759                  index += 2;
   \   00023C   E5..         MOV     A,?V0 + 2
   \   00023E   2402         ADD     A,#0x2
   \   000240   F5..         MOV     ?V0 + 2,A
   \   000242   E4           CLR     A
   \   000243   3400         ADDC    A,#0x0
   \   000245   F5..         MOV     ?V0 + 3,A
   1760              }
   1761              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
   \                     ??mpu_read_fifo_13:
   \   000247   E5..         MOV     A,?V0 + 4
   \   000249   65..         XRL     A,?V0 + 2
   \   00024B   7002         JNZ     ??mpu_read_fifo_14
   \   00024D   E5..         MOV     A,?V0 + 3
   \                     ??mpu_read_fifo_14:
   \   00024F   6040         JZ      ??mpu_read_fifo_15
   \   000251   90....       MOV     DPTR,#st + 11
   \   000254   E0           MOVX    A,@DPTR
   \   000255   A2E5         MOV     C,0xE0 /* A   */.5
   \   000257   5038         JNC     ??mpu_read_fifo_15
   1762                  gyro[1] = (data[index+0] << 8) | data[index+1];
   \   000259   85..82       MOV     DPL,?XSP + 0
   \   00025C   85..83       MOV     DPH,?XSP + 1
   \   00025F   E582         MOV     A,DPL
   \   000261   25..         ADD     A,?V0 + 2
   \   000263   F582         MOV     DPL,A
   \   000265   E583         MOV     A,DPH
   \   000267   35..         ADDC    A,?V0 + 3
   \   000269   F583         MOV     DPH,A
   \   00026B   E0           MOVX    A,@DPTR
   \   00026C   F9           MOV     R1,A
   \   00026D   A3           INC     DPTR
   \   00026E   E0           MOVX    A,@DPTR
   \   00026F   85..82       MOV     DPL,?V0 + 10
   \   000272   85..83       MOV     DPH,?V0 + 11
   \   000275   A3           INC     DPTR
   \   000276   A3           INC     DPTR
   \   000277   F0           MOVX    @DPTR,A
   \   000278   A3           INC     DPTR
   \   000279   E9           MOV     A,R1
   \   00027A   F0           MOVX    @DPTR,A
   1763                  sensors[0] |= INV_Y_GYRO;
   \   00027B   85..82       MOV     DPL,?V0 + 6
   \   00027E   85..83       MOV     DPH,?V0 + 7
   \   000281   E0           MOVX    A,@DPTR
   \   000282   D2E5         SETB    0xE0 /* A   */.5
   \   000284   F0           MOVX    @DPTR,A
   1764                  index += 2;
   \   000285   E5..         MOV     A,?V0 + 2
   \   000287   2402         ADD     A,#0x2
   \   000289   F5..         MOV     ?V0 + 2,A
   \   00028B   E5..         MOV     A,?V0 + 3
   \   00028D   3400         ADDC    A,#0x0
   \   00028F   F5..         MOV     ?V0 + 3,A
   1765              }
   1766              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
   \                     ??mpu_read_fifo_15:
   \   000291   E5..         MOV     A,?V0 + 4
   \   000293   65..         XRL     A,?V0 + 2
   \   000295   7002         JNZ     ??mpu_read_fifo_16
   \   000297   E5..         MOV     A,?V0 + 3
   \                     ??mpu_read_fifo_16:
   \   000299   7003         JNZ     $+5
   \   00029B   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \   00029E   90....       MOV     DPTR,#st + 11
   \   0002A1   E0           MOVX    A,@DPTR
   \   0002A2   A2E4         MOV     C,0xE0 /* A   */.4
   \   0002A4   4003         JC      $+5
   \   0002A6   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1767                  gyro[2] = (data[index+0] << 8) | data[index+1];
   \   0002A9   85..82       MOV     DPL,?XSP + 0
   \   0002AC   85..83       MOV     DPH,?XSP + 1
   \   0002AF   E582         MOV     A,DPL
   \   0002B1   25..         ADD     A,?V0 + 2
   \   0002B3   F582         MOV     DPL,A
   \   0002B5   E583         MOV     A,DPH
   \   0002B7   35..         ADDC    A,?V0 + 3
   \   0002B9   F583         MOV     DPH,A
   \   0002BB   E0           MOVX    A,@DPTR
   \   0002BC   F9           MOV     R1,A
   \   0002BD   A3           INC     DPTR
   \   0002BE   E0           MOVX    A,@DPTR
   \   0002BF   85..82       MOV     DPL,?V0 + 10
   \   0002C2   85..83       MOV     DPH,?V0 + 11
   \   0002C5   A3           INC     DPTR
   \   0002C6   A3           INC     DPTR
   \   0002C7   A3           INC     DPTR
   \   0002C8   A3           INC     DPTR
   \   0002C9   F0           MOVX    @DPTR,A
   \   0002CA   A3           INC     DPTR
   \   0002CB   E9           MOV     A,R1
   \   0002CC   F0           MOVX    @DPTR,A
   1768                  sensors[0] |= INV_Z_GYRO;
   \   0002CD   85..82       MOV     DPL,?V0 + 6
   \   0002D0   85..83       MOV     DPH,?V0 + 7
   \   0002D3   E0           MOVX    A,@DPTR
   \   0002D4   D2E4         SETB    0xE0 /* A   */.4
   \   0002D6   F0           MOVX    @DPTR,A
   1769                  index += 2;
   \   0002D7   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1770              }
   1771          
   1772              return 0;
   1773          }
   1774          
   1775          /**
   1776           *  @brief      Get one unparsed packet from the FIFO.
   1777           *  This function should be used if the packet is to be parsed elsewhere.
   1778           *  @param[in]  length  Length of one FIFO packet.
   1779           *  @param[in]  data    FIFO packet.
   1780           *  @param[in]  more    Number of remaining packets.
   1781           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1782          int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
   \                     mpu_read_fifo_stream:
   1783              unsigned char *more)
   1784          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 4,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 5,A
   1785              unsigned char tmp[2];
   1786              unsigned short fifo_count;
   1787              if (!st.chip_cfg.dmp_on)
   \   00001E   90....       MOV     DPTR,#st + 29
   \   000021   E0           MOVX    A,@DPTR
   \   000022   7007         JNZ     ??mpu_read_fifo_stream_0
   1788                  return -1;
   \                     ??mpu_read_fifo_stream_1:
   \   000024   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_stream_2:
   \   000026   7BFF         MOV     R3,#-0x1
   \   000028   02....       LJMP    ??mpu_read_fifo_stream_3 & 0xFFFF
   1789              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_fifo_stream_0:
   \   00002B   90....       MOV     DPTR,#st + 6
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   60F3         JZ      ??mpu_read_fifo_stream_1
   1790                  return -1;
   1791          
   1792              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
   \   000031                ; Setup parameters for call to function MPU_Read_Len
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   AC82         MOV     R4,DPL
   \   000039   AD83         MOV     R5,DPH
   \   00003B   7B02         MOV     R3,#0x2
   \   00003D   90....       MOV     DPTR,#st
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F8           MOV     R0,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F583         MOV     DPH,A
   \   000046   8882         MOV     DPL,R0
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   FA           MOV     R2,A
   \   000054   90....       MOV     DPTR,#st + 2
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F8           MOV     R0,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F583         MOV     DPH,A
   \   00005D   8882         MOV     DPL,R0
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   F9           MOV     R1,A
   \   000061   12....       LCALL   ??MPU_Read_Len?relay
   \   000064   E9           MOV     A,R1
   \   000065   70BD         JNZ     ??mpu_read_fifo_stream_1
   1793                  return -1;
   1794              fifo_count = (tmp[0] << 8) | tmp[1];
   \   000067   85..82       MOV     DPL,?XSP + 0
   \   00006A   85..83       MOV     DPH,?XSP + 1
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F9           MOV     R1,A
   \   00006F   7401         MOV     A,#0x1
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   FA           MOV     R2,A
   \   000076   F5..         MOV     ?V0 + 0,A
   \   000078   E9           MOV     A,R1
   \   000079   F5..         MOV     ?V0 + 1,A
   1795              if (fifo_count < length) {
   \   00007B   C3           CLR     C
   \   00007C   EA           MOV     A,R2
   \   00007D   9E           SUBB    A,R6
   \   00007E   E9           MOV     A,R1
   \   00007F   9F           SUBB    A,R7
   \   000080   500A         JNC     ??mpu_read_fifo_stream_4
   1796                  more[0] = 0;
   \   000082   85..82       MOV     DPL,?V0 + 4
   \   000085   85..83       MOV     DPH,?V0 + 5
   \   000088   E4           CLR     A
   \   000089   F0           MOVX    @DPTR,A
   1797                  return -1;
   \   00008A   8098         SJMP    ??mpu_read_fifo_stream_1
   1798              }
   1799              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_stream_4:
   \   00008C   90....       MOV     DPTR,#st + 2
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F8           MOV     R0,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   F9           MOV     R1,A
   \   000094   8882         MOV     DPL,R0
   \   000096   8983         MOV     DPH,R1
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   FA           MOV     R2,A
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   C3           CLR     C
   \   00009E   13           RRC     A
   \   00009F   FB           MOV     R3,A
   \   0000A0   EA           MOV     A,R2
   \   0000A1   13           RRC     A
   \   0000A2   C3           CLR     C
   \   0000A3   95..         SUBB    A,?V0 + 0
   \   0000A5   EB           MOV     A,R3
   \   0000A6   95..         SUBB    A,?V0 + 1
   \   0000A8   5041         JNC     ??mpu_read_fifo_stream_5
   1800                  /* FIFO is 50% full, better check overflow bit. */
   1801                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
   \   0000AA                ; Setup parameters for call to function MPU_Read_Len
   \   0000AA   85..82       MOV     DPL,?XSP + 0
   \   0000AD   85..83       MOV     DPH,?XSP + 1
   \   0000B0   AC82         MOV     R4,DPL
   \   0000B2   AD83         MOV     R5,DPH
   \   0000B4   7B01         MOV     R3,#0x1
   \   0000B6   90....       MOV     DPTR,#st
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   2411         ADD     A,#0x11
   \   0000BC   F5..         MOV     ?V0 + 6,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   3400         ADDC    A,#0x0
   \   0000C2   85..82       MOV     DPL,?V0 + 6
   \   0000C5   F583         MOV     DPH,A
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   FA           MOV     R2,A
   \   0000C9   8882         MOV     DPL,R0
   \   0000CB   8983         MOV     DPH,R1
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   F9           MOV     R1,A
   \   0000CF   12....       LCALL   ??MPU_Read_Len?relay
   \   0000D2   E9           MOV     A,R1
   \   0000D3   6003         JZ      $+5
   \   0000D5   02....       LJMP    ??mpu_read_fifo_stream_1 & 0xFFFF
   1802                      return -1;
   1803                  if (tmp[0] & BIT_FIFO_OVERFLOW) {
   \   0000D8   85..82       MOV     DPL,?XSP + 0
   \   0000DB   85..83       MOV     DPH,?XSP + 1
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000E1   5008         JNC     ??mpu_read_fifo_stream_5
   1804                      mpu_reset_fifo();
   \   0000E3                ; Setup parameters for call to function mpu_reset_fifo
   \   0000E3   12....       LCALL   ??mpu_reset_fifo?relay
   1805                      return -2;
   \   0000E6   7AFE         MOV     R2,#-0x2
   \   0000E8   02....       LJMP    ??mpu_read_fifo_stream_2 & 0xFFFF
   1806                  }
   1807              }
   1808          
   1809              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
   \                     ??mpu_read_fifo_stream_5:
   \   0000EB                ; Setup parameters for call to function MPU_Read_Len
   \   0000EB   AC..         MOV     R4,?V0 + 2
   \   0000ED   AD..         MOV     R5,?V0 + 3
   \   0000EF   EE           MOV     A,R6
   \   0000F0   FB           MOV     R3,A
   \   0000F1   90....       MOV     DPTR,#st
   \   0000F4   E0           MOVX    A,@DPTR
   \   0000F5   240B         ADD     A,#0xb
   \   0000F7   F8           MOV     R0,A
   \   0000F8   A3           INC     DPTR
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   3400         ADDC    A,#0x0
   \   0000FC   F9           MOV     R1,A
   \   0000FD   8882         MOV     DPL,R0
   \   0000FF   8983         MOV     DPH,R1
   \   000101   E0           MOVX    A,@DPTR
   \   000102   FA           MOV     R2,A
   \   000103   90....       MOV     DPTR,#st + 2
   \   000106   E0           MOVX    A,@DPTR
   \   000107   F8           MOV     R0,A
   \   000108   A3           INC     DPTR
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   F583         MOV     DPH,A
   \   00010C   8882         MOV     DPL,R0
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   F9           MOV     R1,A
   \   000110   12....       LCALL   ??MPU_Read_Len?relay
   \   000113   E9           MOV     A,R1
   \   000114   6003         JZ      $+5
   \   000116   02....       LJMP    ??mpu_read_fifo_stream_1 & 0xFFFF
   1810                  return -1;
   1811              more[0] = fifo_count / length - 1;
   \   000119   A8..         MOV     R0,?V0 + 0
   \   00011B   A9..         MOV     R1,?V0 + 1
   \   00011D   EE           MOV     A,R6
   \   00011E   FA           MOV     R2,A
   \   00011F   EF           MOV     A,R7
   \   000120   FB           MOV     R3,A
   \   000121   12....       LCALL   ?US_DIV_MOD
   \   000124   E8           MOV     A,R0
   \   000125   14           DEC     A
   \   000126   85..82       MOV     DPL,?V0 + 4
   \   000129   85..83       MOV     DPH,?V0 + 5
   \   00012C   F0           MOVX    @DPTR,A
   1812              return 0;
   \   00012D   7A00         MOV     R2,#0x0
   \   00012F   7B00         MOV     R3,#0x0
   \                     ??mpu_read_fifo_stream_3:
   \   000131   7402         MOV     A,#0x2
   \   000133   12....       LCALL   ?DEALLOC_XSTACK8
   \   000136   7F08         MOV     R7,#0x8
   \   000138   02....       LJMP    ?BANKED_LEAVE_XDATA
   1813          }
   1814          
   1815          /**
   1816           *  @brief      Set device to bypass mode.
   1817           *  @param[in]  bypass_on   1 to enable bypass mode.
   1818           *  @return     0 if successful.
   1819           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1820          int mpu_set_bypass(unsigned char bypass_on)
   \                     mpu_set_bypass:
   1821          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 0,R1
   1822              unsigned char tmp;
   1823          
   1824              if (st.chip_cfg.bypass_mode == bypass_on)
   \   00000C   90....       MOV     DPTR,#st + 13
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   65..         XRL     A,?V0 + 0
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??mpu_set_bypass_0 & 0xFFFF
   1825                  return 0;
   1826          
   1827              if (bypass_on) {
   \   000017   90....       MOV     DPTR,#st + 2
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   90....       MOV     DPTR,#st
   \   000022   E0           MOVX    A,@DPTR
   \   000023   2404         ADD     A,#0x4
   \   000025   FA           MOV     R2,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   3400         ADDC    A,#0x0
   \   00002A   FB           MOV     R3,A
   \   00002B   EA           MOV     A,R2
   \   00002C   FE           MOV     R6,A
   \   00002D   EB           MOV     A,R3
   \   00002E   FF           MOV     R7,A
   \   00002F   E5..         MOV     A,?V0 + 0
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   AC82         MOV     R4,DPL
   \   000039   AD83         MOV     R5,DPH
   \   00003B   7B01         MOV     R3,#0x1
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   7003         JNZ     $+5
   \   000043   02....       LJMP    ??mpu_set_bypass_1 & 0xFFFF
   1828                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   000046                ; Setup parameters for call to function MPU_Read_Len
   \   000046   E0           MOVX    A,@DPTR
   \   000047   FA           MOV     R2,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   8983         MOV     DPH,R1
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   12....       LCALL   ??MPU_Read_Len?relay
   \   000051   E9           MOV     A,R1
   \   000052   6007         JZ      ??mpu_set_bypass_2
   1829                      return -1;
   \                     ??mpu_set_bypass_3:
   \   000054   7AFF         MOV     R2,#-0x1
   \   000056   7BFF         MOV     R3,#-0x1
   \   000058   02....       LJMP    ??mpu_set_bypass_4 & 0xFFFF
   1830                  tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_2:
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   E0           MOVX    A,@DPTR
   \   000062   C2E5         CLR     0xE0 /* A   */.5
   \   000064   F0           MOVX    @DPTR,A
   1831                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   000065                ; Setup parameters for call to function MPU_Write_Len
   \   000065   AC82         MOV     R4,DPL
   \   000067   AD83         MOV     R5,DPH
   \   000069   7B01         MOV     R3,#0x1
   \   00006B   90....       MOV     DPTR,#st
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F8           MOV     R0,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F583         MOV     DPH,A
   \   000074   8882         MOV     DPL,R0
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FA           MOV     R2,A
   \   00007C   90....       MOV     DPTR,#st + 2
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F8           MOV     R0,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F583         MOV     DPH,A
   \   000085   8882         MOV     DPL,R0
   \   000087   E0           MOVX    A,@DPTR
   \   000088   F9           MOV     R1,A
   \   000089   12....       LCALL   ??MPU_Write_Len?relay
   \   00008C   E9           MOV     A,R1
   \   00008D   70C5         JNZ     ??mpu_set_bypass_3
   1832                      return -1;
   1833                  delay_ms(3);
   \   00008F                ; Setup parameters for call to function delay_ms
   \   00008F   90....       MOV     DPTR,#__Constant_3
   \   000092   12....       LCALL   ?XLOAD_R2345
   \   000095   12....       LCALL   ??delay_ms?relay
   1834                  tmp = BIT_BYPASS_EN;
   \   000098   85..82       MOV     DPL,?XSP + 0
   \   00009B   85..83       MOV     DPH,?XSP + 1
   \   00009E   7402         MOV     A,#0x2
   \   0000A0   F0           MOVX    @DPTR,A
   1835                  if (st.chip_cfg.active_low_int)
   \   0000A1   90....       MOV     DPTR,#st + 27
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   6009         JZ      ??mpu_set_bypass_5
   1836                      tmp |= BIT_ACTL;
   \   0000A7   85..82       MOV     DPL,?XSP + 0
   \   0000AA   85..83       MOV     DPH,?XSP + 1
   \   0000AD   7482         MOV     A,#-0x7e
   \   0000AF   F0           MOVX    @DPTR,A
   1837                  if (st.chip_cfg.latched_int)
   \                     ??mpu_set_bypass_5:
   \   0000B0   90....       MOV     DPTR,#st + 28
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   600A         JZ      ??mpu_set_bypass_6
   1838                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   4430         ORL     A,#0x30
   \   0000BF   F0           MOVX    @DPTR,A
   1839                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_6:
   \   0000C0                ; Setup parameters for call to function MPU_Write_Len
   \   0000C0   85..82       MOV     DPL,?XSP + 0
   \   0000C3   85..83       MOV     DPH,?XSP + 1
   \   0000C6   AC82         MOV     R4,DPL
   \   0000C8   AD83         MOV     R5,DPH
   \   0000CA   7B01         MOV     R3,#0x1
   \   0000CC   90....       MOV     DPTR,#st
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   2414         ADD     A,#0x14
   \   0000D2   F8           MOV     R0,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   3400         ADDC    A,#0x0
   \   0000D7   F9           MOV     R1,A
   \   0000D8   8882         MOV     DPL,R0
   \   0000DA   8983         MOV     DPH,R1
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   FA           MOV     R2,A
   \   0000DE   90....       MOV     DPTR,#st + 2
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   F8           MOV     R0,A
   \   0000E3   A3           INC     DPTR
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   F583         MOV     DPH,A
   \   0000E7   8882         MOV     DPL,R0
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   F9           MOV     R1,A
   \   0000EB   12....       LCALL   ??MPU_Write_Len?relay
   \   0000EE   E9           MOV     A,R1
   \   0000EF   6003         JZ      $+5
   \   0000F1   02....       LJMP    ??mpu_set_bypass_3 & 0xFFFF
   \   0000F4   02....       LJMP    ??mpu_set_bypass_7 & 0xFFFF
   1840                      return -1;
   1841              } else {
   1842                  /* Enable I2C master mode if compass is being used. */
   1843                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??mpu_set_bypass_1:
   \   0000F7                ; Setup parameters for call to function MPU_Read_Len
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   FA           MOV     R2,A
   \   0000F9   8882         MOV     DPL,R0
   \   0000FB   8983         MOV     DPH,R1
   \   0000FD   E0           MOVX    A,@DPTR
   \   0000FE   F9           MOV     R1,A
   \   0000FF   12....       LCALL   ??MPU_Read_Len?relay
   \   000102   E9           MOV     A,R1
   \   000103   6003         JZ      $+5
   \   000105   02....       LJMP    ??mpu_set_bypass_3 & 0xFFFF
   1844                      return -1;
   1845                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   000108   90....       MOV     DPTR,#st + 6
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00010E   85..82       MOV     DPL,?XSP + 0
   \   000111   85..83       MOV     DPH,?XSP + 1
   \   000114   E0           MOVX    A,@DPTR
   \   000115   5004         JNC     ??mpu_set_bypass_8
   1846                      tmp |= BIT_AUX_IF_EN;
   \   000117   D2E5         SETB    0xE0 /* A   */.5
   \   000119   8002         SJMP    ??mpu_set_bypass_9
   1847                  else
   1848                      tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_8:
   \   00011B   C2E5         CLR     0xE0 /* A   */.5
   \                     ??mpu_set_bypass_9:
   \   00011D   F0           MOVX    @DPTR,A
   1849                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   00011E                ; Setup parameters for call to function MPU_Write_Len
   \   00011E   AC82         MOV     R4,DPL
   \   000120   AD83         MOV     R5,DPH
   \   000122   7B01         MOV     R3,#0x1
   \   000124   90....       MOV     DPTR,#st
   \   000127   E0           MOVX    A,@DPTR
   \   000128   F8           MOV     R0,A
   \   000129   A3           INC     DPTR
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   F583         MOV     DPH,A
   \   00012D   8882         MOV     DPL,R0
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   A3           INC     DPTR
   \   000133   E0           MOVX    A,@DPTR
   \   000134   FA           MOV     R2,A
   \   000135   90....       MOV     DPTR,#st + 2
   \   000138   E0           MOVX    A,@DPTR
   \   000139   F8           MOV     R0,A
   \   00013A   A3           INC     DPTR
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   F583         MOV     DPH,A
   \   00013E   8882         MOV     DPL,R0
   \   000140   E0           MOVX    A,@DPTR
   \   000141   F9           MOV     R1,A
   \   000142   12....       LCALL   ??MPU_Write_Len?relay
   \   000145   E9           MOV     A,R1
   \   000146   6003         JZ      $+5
   \   000148   02....       LJMP    ??mpu_set_bypass_3 & 0xFFFF
   1850                      return -1;
   1851                  delay_ms(3);
   \   00014B                ; Setup parameters for call to function delay_ms
   \   00014B   90....       MOV     DPTR,#__Constant_3
   \   00014E   12....       LCALL   ?XLOAD_R2345
   \   000151   12....       LCALL   ??delay_ms?relay
   1852                  if (st.chip_cfg.active_low_int)
   \   000154   90....       MOV     DPTR,#st + 27
   \   000157   E0           MOVX    A,@DPTR
   \   000158   85..82       MOV     DPL,?XSP + 0
   \   00015B   85..83       MOV     DPH,?XSP + 1
   \   00015E   6004         JZ      ??mpu_set_bypass_10
   1853                      tmp = BIT_ACTL;
   \   000160   7480         MOV     A,#-0x80
   \   000162   8001         SJMP    ??mpu_set_bypass_11
   1854                  else
   1855                      tmp = 0;
   \                     ??mpu_set_bypass_10:
   \   000164   E4           CLR     A
   \                     ??mpu_set_bypass_11:
   \   000165   F0           MOVX    @DPTR,A
   1856                  if (st.chip_cfg.latched_int)
   \   000166   90....       MOV     DPTR,#st + 28
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   600A         JZ      ??mpu_set_bypass_12
   1857                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00016C   85..82       MOV     DPL,?XSP + 0
   \   00016F   85..83       MOV     DPH,?XSP + 1
   \   000172   E0           MOVX    A,@DPTR
   \   000173   4430         ORL     A,#0x30
   \   000175   F0           MOVX    @DPTR,A
   1858                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_12:
   \   000176                ; Setup parameters for call to function MPU_Write_Len
   \   000176   85..82       MOV     DPL,?XSP + 0
   \   000179   85..83       MOV     DPH,?XSP + 1
   \   00017C   AC82         MOV     R4,DPL
   \   00017E   AD83         MOV     R5,DPH
   \   000180   7B01         MOV     R3,#0x1
   \   000182   90....       MOV     DPTR,#st
   \   000185   E0           MOVX    A,@DPTR
   \   000186   2414         ADD     A,#0x14
   \   000188   F8           MOV     R0,A
   \   000189   A3           INC     DPTR
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   3400         ADDC    A,#0x0
   \   00018D   F9           MOV     R1,A
   \   00018E   8882         MOV     DPL,R0
   \   000190   8983         MOV     DPH,R1
   \   000192   E0           MOVX    A,@DPTR
   \   000193   FA           MOV     R2,A
   \   000194   90....       MOV     DPTR,#st + 2
   \   000197   E0           MOVX    A,@DPTR
   \   000198   F8           MOV     R0,A
   \   000199   A3           INC     DPTR
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   F583         MOV     DPH,A
   \   00019D   8882         MOV     DPL,R0
   \   00019F   E0           MOVX    A,@DPTR
   \   0001A0   F9           MOV     R1,A
   \   0001A1   12....       LCALL   ??MPU_Write_Len?relay
   \   0001A4   E9           MOV     A,R1
   \   0001A5   6003         JZ      $+5
   \   0001A7   02....       LJMP    ??mpu_set_bypass_3 & 0xFFFF
   1859                      return -1;
   1860              }
   1861              st.chip_cfg.bypass_mode = bypass_on;
   \                     ??mpu_set_bypass_7:
   \   0001AA   E5..         MOV     A,?V0 + 0
   \   0001AC   90....       MOV     DPTR,#st + 13
   \   0001AF   F0           MOVX    @DPTR,A
   1862              return 0;
   \                     ??mpu_set_bypass_0:
   \   0001B0   7A00         MOV     R2,#0x0
   \   0001B2   7B00         MOV     R3,#0x0
   \                     ??mpu_set_bypass_4:
   \   0001B4   7401         MOV     A,#0x1
   \   0001B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B9   7F01         MOV     R7,#0x1
   \   0001BB   02....       LJMP    ?BANKED_LEAVE_XDATA
   1863          }
   1864          
   1865          /**
   1866           *  @brief      Set interrupt level.
   1867           *  @param[in]  active_low  1 for active low, 0 for active high.
   1868           *  @return     0 if successful.
   1869           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1870          int mpu_set_int_level(unsigned char active_low)
   \                     mpu_set_int_level:
   1871          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1872              st.chip_cfg.active_low_int = active_low;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#st + 27
   \   000008   F0           MOVX    @DPTR,A
   1873              return 0;
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   D083         POP     DPH
   \   00000F   D082         POP     DPL
   \   000011   02....       LJMP    ?BRET
   1874          }
   1875          
   1876          /**
   1877           *  @brief      Enable latched interrupts.
   1878           *  Any MPU register will clear the interrupt.
   1879           *  @param[in]  enable  1 to enable, 0 to disable.
   1880           *  @return     0 if successful.
   1881           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1882          int mpu_set_int_latched(unsigned char enable)
   \                     mpu_set_int_latched:
   1883          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1884              unsigned char tmp;
   1885              if (st.chip_cfg.latched_int == enable)
   \   00000C   90....       MOV     DPTR,#st + 28
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   606B         JZ      ??mpu_set_int_latched_0
   1886                  return 0;
   1887          
   1888              if (enable)
   \   000013   EE           MOV     A,R6
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   6004         JZ      ??mpu_set_int_latched_1
   1889                  tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00001C   7430         MOV     A,#0x30
   \   00001E   8001         SJMP    ??mpu_set_int_latched_2
   1890              else
   1891                  tmp = 0;
   \                     ??mpu_set_int_latched_1:
   \   000020   E4           CLR     A
   \                     ??mpu_set_int_latched_2:
   \   000021   F0           MOVX    @DPTR,A
   1892              if (st.chip_cfg.bypass_mode)
   \   000022   90....       MOV     DPTR,#st + 13
   \   000025   E0           MOVX    A,@DPTR
   \   000026   600A         JZ      ??mpu_set_int_latched_3
   1893                  tmp |= BIT_BYPASS_EN;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   D2E1         SETB    0xE0 /* A   */.1
   \   000031   F0           MOVX    @DPTR,A
   1894              if (st.chip_cfg.active_low_int)
   \                     ??mpu_set_int_latched_3:
   \   000032   90....       MOV     DPTR,#st + 27
   \   000035   E0           MOVX    A,@DPTR
   \   000036   600A         JZ      ??mpu_set_int_latched_4
   1895                  tmp |= BIT_ACTL;
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   D2E7         SETB    0xE0 /* A   */.7
   \   000041   F0           MOVX    @DPTR,A
   1896              if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_int_latched_4:
   \   000042                ; Setup parameters for call to function MPU_Write_Len
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   AC82         MOV     R4,DPL
   \   00004A   AD83         MOV     R5,DPH
   \   00004C   7B01         MOV     R3,#0x1
   \   00004E   90....       MOV     DPTR,#st
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2414         ADD     A,#0x14
   \   000054   F8           MOV     R0,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   3400         ADDC    A,#0x0
   \   000059   F9           MOV     R1,A
   \   00005A   8882         MOV     DPL,R0
   \   00005C   8983         MOV     DPH,R1
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   FA           MOV     R2,A
   \   000060   90....       MOV     DPTR,#st + 2
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F8           MOV     R0,A
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F583         MOV     DPH,A
   \   000069   8882         MOV     DPL,R0
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   F9           MOV     R1,A
   \   00006D   12....       LCALL   ??MPU_Write_Len?relay
   \   000070   E9           MOV     A,R1
   \   000071   6006         JZ      ??mpu_set_int_latched_5
   1897                  return -1;
   \   000073   7AFF         MOV     R2,#-0x1
   \   000075   7BFF         MOV     R3,#-0x1
   \   000077   8009         SJMP    ??mpu_set_int_latched_6
   1898              st.chip_cfg.latched_int = enable;
   \                     ??mpu_set_int_latched_5:
   \   000079   EE           MOV     A,R6
   \   00007A   90....       MOV     DPTR,#st + 28
   \   00007D   F0           MOVX    @DPTR,A
   1899              return 0;
   \                     ??mpu_set_int_latched_0:
   \   00007E   7A00         MOV     R2,#0x0
   \   000080   7B00         MOV     R3,#0x0
   \                     ??mpu_set_int_latched_6:
   \   000082   7401         MOV     A,#0x1
   \   000084   12....       LCALL   ?DEALLOC_XSTACK8
   \   000087   7F01         MOV     R7,#0x1
   \   000089   02....       LJMP    ?BANKED_LEAVE_XDATA
   1900          }
   1901          
   1902          #ifdef MPU6050

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1903          static int get_accel_prod_shift(float *st_shift)
   \                     get_accel_prod_shift:
   1904          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 12,R2
   \   00000C   8B..         MOV     ?V0 + 13,R3
   1905              unsigned char tmp[4], shift_code[3], ii;
   1906          
   1907              if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
   \   00000E                ; Setup parameters for call to function MPU_Read_Len
   \   00000E   7403         MOV     A,#0x3
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   7B04         MOV     R3,#0x4
   \   000019   7A0D         MOV     R2,#0xd
   \   00001B   90....       MOV     DPTR,#st + 2
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F583         MOV     DPH,A
   \   000024   8882         MOV     DPL,R0
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F9           MOV     R1,A
   \   000028   12....       LCALL   ??MPU_Read_Len?relay
   \   00002B   E9           MOV     A,R1
   \   00002C   6005         JZ      ??get_accel_prod_shift_0
   1908                  return 0x07;
   \   00002E   7A07         MOV     R2,#0x7
   \   000030   02....       LJMP    ??get_accel_prod_shift_1 & 0xFFFF
   1909          
   1910              shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
   \                     ??get_accel_prod_shift_0:
   \   000033   7406         MOV     A,#0x6
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   C4           SWAP    A
   \   00003B   540F         ANL     A,#0xf
   \   00003D   5403         ANL     A,#0x3
   \   00003F   F8           MOV     R0,A
   \   000040   7403         MOV     A,#0x3
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E0           MOVX    A,@DPTR
   \   000046   13           RRC     A
   \   000047   13           RRC     A
   \   000048   13           RRC     A
   \   000049   541F         ANL     A,#0x1f
   \   00004B   541C         ANL     A,#0x1c
   \   00004D   48           ORL     A,R0
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   F0           MOVX    @DPTR,A
   1911              shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
   \   000055   E9           MOV     A,R1
   \   000056   13           RRC     A
   \   000057   13           RRC     A
   \   000058   543F         ANL     A,#0x3f
   \   00005A   5403         ANL     A,#0x3
   \   00005C   F8           MOV     R0,A
   \   00005D   7404         MOV     A,#0x4
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   E0           MOVX    A,@DPTR
   \   000063   13           RRC     A
   \   000064   13           RRC     A
   \   000065   13           RRC     A
   \   000066   541F         ANL     A,#0x1f
   \   000068   541C         ANL     A,#0x1c
   \   00006A   48           ORL     A,R0
   \   00006B   C0E0         PUSH    A
   \   00006D   7401         MOV     A,#0x1
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   D0E0         POP     A
   \   000074   F0           MOVX    @DPTR,A
   1912              shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
   \   000075   7403         MOV     A,#0x3
   \   000077   59           ANL     A,R1
   \   000078   F8           MOV     R0,A
   \   000079   7405         MOV     A,#0x5
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   13           RRC     A
   \   000080   13           RRC     A
   \   000081   13           RRC     A
   \   000082   541F         ANL     A,#0x1f
   \   000084   541C         ANL     A,#0x1c
   \   000086   48           ORL     A,R0
   \   000087   C0E0         PUSH    A
   \   000089   7402         MOV     A,#0x2
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   D0E0         POP     A
   \   000090   F0           MOVX    @DPTR,A
   1913              for (ii = 0; ii < 3; ii++) {
   \   000091   7E00         MOV     R6,#0x0
   \   000093   8032         SJMP    ??get_accel_prod_shift_2
   1914                  if (!shift_code[ii]) {
   1915                      st_shift[ii] = 0.f;
   1916                      continue;
   1917                  }
   1918                  /* Equivalent to..
   1919                   * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
   1920                   */
   1921                  st_shift[ii] = 0.34f;
   1922                  while (--shift_code[ii])
   1923                      st_shift[ii] *= 1.034f;
   \                     ??get_accel_prod_shift_3:
   \   000095   85..82       MOV     DPL,?V0 + 4
   \   000098   85..83       MOV     DPH,?V0 + 5
   \   00009B   78..         MOV     R0,#?V0 + 0
   \   00009D   12....       LCALL   ?L_MOV_X
   \   0000A0   90....       MOV     DPTR,#__Constant_3f845a1d
   \   0000A3   78..         MOV     R0,#?V0 + 8
   \   0000A5   12....       LCALL   ?L_MOV_X
   \   0000A8   78..         MOV     R0,#?V0 + 0
   \   0000AA   79..         MOV     R1,#?V0 + 8
   \   0000AC   12....       LCALL   ?FLT_MUL
   \   0000AF   85..82       MOV     DPL,?V0 + 4
   \   0000B2   85..83       MOV     DPH,?V0 + 5
   \   0000B5   78..         MOV     R0,#?V0 + 0
   \   0000B7   12....       LCALL   ?L_MOV_TO_X
   \                     ??get_accel_prod_shift_4:
   \   0000BA   85..82       MOV     DPL,?V0 + 6
   \   0000BD   85..83       MOV     DPH,?V0 + 7
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   14           DEC     A
   \   0000C2   F0           MOVX    @DPTR,A
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   70CF         JNZ     ??get_accel_prod_shift_3
   \                     ??get_accel_prod_shift_5:
   \   0000C6   0E           INC     R6
   \                     ??get_accel_prod_shift_2:
   \   0000C7   EE           MOV     A,R6
   \   0000C8   C3           CLR     C
   \   0000C9   9403         SUBB    A,#0x3
   \   0000CB   5057         JNC     ??get_accel_prod_shift_6
   \   0000CD   8E82         MOV     DPL,R6
   \   0000CF   AA82         MOV     R2,DPL
   \   0000D1   8A..         MOV     ?V0 + 0,R2
   \   0000D3   75..00       MOV     ?V0 + 1,#0x0
   \   0000D6   7402         MOV     A,#0x2
   \   0000D8   78..         MOV     R0,#?V0 + 0
   \   0000DA   12....       LCALL   ?S_SHL
   \   0000DD   E5..         MOV     A,?V0 + 12
   \   0000DF   25..         ADD     A,?V0 + 0
   \   0000E1   F5..         MOV     ?V0 + 4,A
   \   0000E3   E5..         MOV     A,?V0 + 13
   \   0000E5   35..         ADDC    A,?V0 + 1
   \   0000E7   F5..         MOV     ?V0 + 5,A
   \   0000E9   85..82       MOV     DPL,?XSP + 0
   \   0000EC   85..83       MOV     DPH,?XSP + 1
   \   0000EF   E582         MOV     A,DPL
   \   0000F1   2A           ADD     A,R2
   \   0000F2   F5..         MOV     ?V0 + 6,A
   \   0000F4   E583         MOV     A,DPH
   \   0000F6   3400         ADDC    A,#0x0
   \   0000F8   F5..         MOV     ?V0 + 7,A
   \   0000FA   85..82       MOV     DPL,?V0 + 6
   \   0000FD   F583         MOV     DPH,A
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   7011         JNZ     ??get_accel_prod_shift_7
   \   000102   90....       MOV     DPTR,#__Constant_0
   \   000105   12....       LCALL   ?XLOAD_R2345
   \   000108   85..82       MOV     DPL,?V0 + 4
   \   00010B   85..83       MOV     DPH,?V0 + 5
   \   00010E   12....       LCALL   ?XSTORE_R2345
   \   000111   80B3         SJMP    ??get_accel_prod_shift_5
   \                     ??get_accel_prod_shift_7:
   \   000113   90....       MOV     DPTR,#__Constant_3eae147b
   \   000116   12....       LCALL   ?XLOAD_R2345
   \   000119   85..82       MOV     DPL,?V0 + 4
   \   00011C   85..83       MOV     DPH,?V0 + 5
   \   00011F   12....       LCALL   ?XSTORE_R2345
   \   000122   8096         SJMP    ??get_accel_prod_shift_4
   1924              }
   1925              return 0;
   \                     ??get_accel_prod_shift_6:
   \   000124   7A00         MOV     R2,#0x0
   \                     ??get_accel_prod_shift_1:
   \   000126   7B00         MOV     R3,#0x0
   \   000128   7407         MOV     A,#0x7
   \   00012A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012D   7F0E         MOV     R7,#0xe
   \   00012F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1926          }
   1927          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1928          static int accel_self_test(long *bias_regular, long *bias_st)
   \                     accel_self_test:
   1929          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   8C..         MOV     ?V0 + 14,R4
   \   000017   8D..         MOV     ?V0 + 15,R5
   1930              int jj, result = 0;
   \   000019   75..00       MOV     ?V0 + 12,#0x0
   \   00001C   75..00       MOV     ?V0 + 13,#0x0
   1931              float st_shift[3], st_shift_cust, st_shift_var;
   1932          
   1933              get_accel_prod_shift(st_shift);
   \   00001F                ; Setup parameters for call to function get_accel_prod_shift
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   AA82         MOV     R2,DPL
   \   000026   AB83         MOV     R3,DPH
   \   000028   12....       LCALL   ??get_accel_prod_shift?relay
   1934              for(jj = 0; jj < 3; jj++) {
   \   00002B   7E00         MOV     R6,#0x0
   \   00002D   7F00         MOV     R7,#0x0
   \   00002F   8030         SJMP    ??accel_self_test_0
   1935                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   1936                  if (st_shift[jj]) {
   1937                      st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
   1938                      if (fabs(st_shift_var) > test.max_accel_var)
   1939                          result |= 1 << jj;
   1940                  } else if ((st_shift_cust < test.min_g) ||
   1941                      (st_shift_cust > test.max_g))
   \                     ??accel_self_test_1:
   \   000031   90....       MOV     DPTR,#__Constant_3e99999a
   \   000034   78..         MOV     R0,#?V0 + 0
   \   000036   12....       LCALL   ?L_MOV_X
   \   000039   78..         MOV     R0,#?V0 + 4
   \   00003B   79..         MOV     R1,#?V0 + 0
   \   00003D   12....       LCALL   ?FLT_LT
   \   000040   5003         JNC     $+5
   \   000042   02....       LJMP    ??accel_self_test_2 & 0xFFFF
   \   000045   90....       MOV     DPTR,#__Constant_3f733334
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?L_MOV_X
   \   00004D   78..         MOV     R0,#?V0 + 4
   \   00004F   79..         MOV     R1,#?V0 + 0
   \   000051   12....       LCALL   ?FLT_GE
   \   000054   5003         JNC     $+5
   \   000056   02....       LJMP    ??accel_self_test_2 & 0xFFFF
   \                     ??accel_self_test_3:
   \   000059   EE           MOV     A,R6
   \   00005A   2401         ADD     A,#0x1
   \   00005C   0E           INC     R6
   \   00005D   EF           MOV     A,R7
   \   00005E   3400         ADDC    A,#0x0
   \   000060   FF           MOV     R7,A
   \                     ??accel_self_test_0:
   \   000061   C3           CLR     C
   \   000062   EE           MOV     A,R6
   \   000063   9403         SUBB    A,#0x3
   \   000065   EF           MOV     A,R7
   \   000066   9400         SUBB    A,#0x0
   \   000068   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00006A   65D0         XRL     A,PSW
   \   00006C   33           RLC     A
   \   00006D   4003         JC      $+5
   \   00006F   02....       LJMP    ??accel_self_test_4 & 0xFFFF
   \   000072   8E..         MOV     ?V0 + 2,R6
   \   000074   8F..         MOV     ?V0 + 3,R7
   \   000076   7402         MOV     A,#0x2
   \   000078   78..         MOV     R0,#?V0 + 2
   \   00007A   12....       LCALL   ?S_SHL
   \   00007D   85....       MOV     ?V0 + 0,?V0 + 2
   \   000080   85....       MOV     ?V0 + 1,?V0 + 3
   \   000083                ; Setup parameters for call to function labs
   \   000083   85..82       MOV     DPL,?XSP + 0
   \   000086   85..83       MOV     DPH,?XSP + 1
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   25..         ADD     A,?V0 + 0
   \   00008C   F8           MOV     R0,A
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   35..         ADDC    A,?V0 + 1
   \   000091   8882         MOV     DPL,R0
   \   000093   F583         MOV     DPH,A
   \   000095   78..         MOV     R0,#?V0 + 4
   \   000097   12....       LCALL   ?L_MOV_X
   \   00009A   E5..         MOV     A,?V0 + 14
   \   00009C   25..         ADD     A,?V0 + 0
   \   00009E   F582         MOV     DPL,A
   \   0000A0   E5..         MOV     A,?V0 + 15
   \   0000A2   35..         ADDC    A,?V0 + 1
   \   0000A4   F583         MOV     DPH,A
   \   0000A6   78..         MOV     R0,#?V0 + 4
   \   0000A8   12....       LCALL   ?L_SUB_X
   \   0000AB   AA..         MOV     R2,?V0 + 4
   \   0000AD   AB..         MOV     R3,?V0 + 5
   \   0000AF   AC..         MOV     R4,?V0 + 6
   \   0000B1   AD..         MOV     R5,?V0 + 7
   \   0000B3   12....       LCALL   ??labs?relay
   \   0000B6   8A..         MOV     ?V0 + 4,R2
   \   0000B8   8B..         MOV     ?V0 + 5,R3
   \   0000BA   8C..         MOV     ?V0 + 6,R4
   \   0000BC   8D..         MOV     ?V0 + 7,R5
   \   0000BE   78..         MOV     R0,#?V0 + 4
   \   0000C0   12....       LCALL   ?L_TO_FLT
   \   0000C3   90....       MOV     DPTR,#__Constant_37800000
   \   0000C6   78..         MOV     R0,#?V0 + 8
   \   0000C8   12....       LCALL   ?L_MOV_X
   \   0000CB   78..         MOV     R0,#?V0 + 4
   \   0000CD   79..         MOV     R1,#?V0 + 8
   \   0000CF   12....       LCALL   ?FLT_MUL
   \   0000D2   7402         MOV     A,#0x2
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   E582         MOV     A,DPL
   \   0000D9   25..         ADD     A,?V0 + 0
   \   0000DB   F582         MOV     DPL,A
   \   0000DD   E583         MOV     A,DPH
   \   0000DF   35..         ADDC    A,?V0 + 1
   \   0000E1   F583         MOV     DPH,A
   \   0000E3   78..         MOV     R0,#?V0 + 8
   \   0000E5   12....       LCALL   ?L_MOV_X
   \   0000E8   90....       MOV     DPTR,#__Constant_0
   \   0000EB   78..         MOV     R0,#?V0 + 0
   \   0000ED   12....       LCALL   ?L_MOV_X
   \   0000F0   78..         MOV     R0,#?V0 + 8
   \   0000F2   79..         MOV     R1,#?V0 + 0
   \   0000F4   12....       LCALL   ?FLT_EQ
   \   0000F7   7003         JNZ     $+5
   \   0000F9   02....       LJMP    ??accel_self_test_1 & 0xFFFF
   \   0000FC   8E..         MOV     ?V0 + 0,R6
   \   0000FE   8F..         MOV     ?V0 + 1,R7
   \   000100   7402         MOV     A,#0x2
   \   000102   78..         MOV     R0,#?V0 + 0
   \   000104   12....       LCALL   ?S_SHL
   \   000107   7402         MOV     A,#0x2
   \   000109   12....       LCALL   ?XSTACK_DISP0_8
   \   00010C   E582         MOV     A,DPL
   \   00010E   25..         ADD     A,?V0 + 0
   \   000110   F582         MOV     DPL,A
   \   000112   E583         MOV     A,DPH
   \   000114   35..         ADDC    A,?V0 + 1
   \   000116   F583         MOV     DPH,A
   \   000118   78..         MOV     R0,#?V0 + 0
   \   00011A   12....       LCALL   ?L_MOV_X
   \   00011D   78..         MOV     R0,#?V0 + 4
   \   00011F   79..         MOV     R1,#?V0 + 0
   \   000121   12....       LCALL   ?FLT_DIV
   \   000124   90....       MOV     DPTR,#__Constant_bf800000
   \   000127   78..         MOV     R0,#?V0 + 0
   \   000129   12....       LCALL   ?L_MOV_X
   \   00012C   78..         MOV     R0,#?V0 + 4
   \   00012E   79..         MOV     R1,#?V0 + 0
   \   000130   12....       LCALL   ?FLT_ADD
   \   000133   E5..         MOV     A,?V0 + 7
   \   000135   C2E7         CLR     0xE0 /* A   */.7
   \   000137   F5..         MOV     ?V0 + 7,A
   \   000139   90....       MOV     DPTR,#__Constant_3e0f5c2a
   \   00013C   78..         MOV     R0,#?V0 + 0
   \   00013E   12....       LCALL   ?L_MOV_X
   \   000141   78..         MOV     R0,#?V0 + 4
   \   000143   79..         MOV     R1,#?V0 + 0
   \   000145   12....       LCALL   ?FLT_GE
   \   000148   4003         JC      $+5
   \   00014A   02....       LJMP    ??accel_self_test_3 & 0xFFFF
   \                     ??accel_self_test_2:
   \   00014D   75..01       MOV     ?V0 + 0,#0x1
   \   000150   75..00       MOV     ?V0 + 1,#0x0
   \   000153   EE           MOV     A,R6
   \   000154   78..         MOV     R0,#?V0 + 0
   \   000156   12....       LCALL   ?S_SHL
   \   000159   E5..         MOV     A,?V0 + 0
   \   00015B   45..         ORL     A,?V0 + 12
   \   00015D   F5..         MOV     ?V0 + 12,A
   \   00015F   E5..         MOV     A,?V0 + 1
   \   000161   45..         ORL     A,?V0 + 13
   \   000163   F5..         MOV     ?V0 + 13,A
   \   000165   02....       LJMP    ??accel_self_test_3 & 0xFFFF
   1942                      result |= 1 << jj;
   1943              }
   1944          
   1945              return result;
   \                     ??accel_self_test_4:
   \   000168   AA..         MOV     R2,?V0 + 12
   \   00016A   AB..         MOV     R3,?V0 + 13
   \   00016C   740E         MOV     A,#0xe
   \   00016E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000171   7F10         MOV     R7,#0x10
   \   000173   02....       LJMP    ?BANKED_LEAVE_XDATA
   1946          }
   1947          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1948          static int gyro_self_test(long *bias_regular, long *bias_st)
   \                     gyro_self_test:
   1949          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7403         MOV     A,#0x3
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   8C..         MOV     ?V0 + 14,R4
   \   000016   8D..         MOV     ?V0 + 15,R5
   1950              int jj, result = 0;
   \   000018   75..00       MOV     ?V0 + 12,#0x0
   \   00001B   75..00       MOV     ?V0 + 13,#0x0
   1951              unsigned char tmp[3];
   1952              float st_shift, st_shift_cust, st_shift_var;
   1953          
   1954              if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
   \   00001E                ; Setup parameters for call to function MPU_Read_Len
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   AC82         MOV     R4,DPL
   \   000026   AD83         MOV     R5,DPH
   \   000028   7B03         MOV     R3,#0x3
   \   00002A   7A0D         MOV     R2,#0xd
   \   00002C   90....       MOV     DPTR,#st + 2
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F8           MOV     R0,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F583         MOV     DPH,A
   \   000035   8882         MOV     DPL,R0
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F9           MOV     R1,A
   \   000039   12....       LCALL   ??MPU_Read_Len?relay
   \   00003C   E9           MOV     A,R1
   \   00003D   6007         JZ      ??gyro_self_test_0
   1955                  return 0x07;
   \   00003F   7A07         MOV     R2,#0x7
   \   000041   7B00         MOV     R3,#0x0
   \   000043   02....       LJMP    ??gyro_self_test_1 & 0xFFFF
   1956          
   1957              tmp[0] &= 0x1F;
   \                     ??gyro_self_test_0:
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   541F         ANL     A,#0x1f
   \   00004F   F0           MOVX    @DPTR,A
   1958              tmp[1] &= 0x1F;
   \   000050   7401         MOV     A,#0x1
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   E0           MOVX    A,@DPTR
   \   000056   541F         ANL     A,#0x1f
   \   000058   F0           MOVX    @DPTR,A
   1959              tmp[2] &= 0x1F;
   \   000059   7402         MOV     A,#0x2
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   541F         ANL     A,#0x1f
   \   000061   F0           MOVX    @DPTR,A
   1960          
   1961              for (jj = 0; jj < 3; jj++) {
   \   000062   7E00         MOV     R6,#0x0
   \   000064   7F00         MOV     R7,#0x0
   \   000066   8030         SJMP    ??gyro_self_test_2
   1962                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   1963                  if (tmp[jj]) {
   1964                      st_shift = 3275.f / test.gyro_sens;
   1965                      while (--tmp[jj])
   1966                          st_shift *= 1.046f;
   1967                      st_shift_var = st_shift_cust / st_shift - 1.f;
   1968                      if (fabs(st_shift_var) > test.max_gyro_var)
   1969                          result |= 1 << jj;
   1970                  } else if ((st_shift_cust < test.min_dps) ||
   1971                      (st_shift_cust > test.max_dps))
   \                     ??gyro_self_test_3:
   \   000068   90....       MOV     DPTR,#__Constant_41200000
   \   00006B   78..         MOV     R0,#?V0 + 0
   \   00006D   12....       LCALL   ?L_MOV_X
   \   000070   78..         MOV     R0,#?V0 + 4
   \   000072   79..         MOV     R1,#?V0 + 0
   \   000074   12....       LCALL   ?FLT_LT
   \   000077   5003         JNC     $+5
   \   000079   02....       LJMP    ??gyro_self_test_4 & 0xFFFF
   \   00007C   90....       MOV     DPTR,#__Constant_42d20001
   \   00007F   78..         MOV     R0,#?V0 + 0
   \   000081   12....       LCALL   ?L_MOV_X
   \   000084   78..         MOV     R0,#?V0 + 4
   \   000086   79..         MOV     R1,#?V0 + 0
   \   000088   12....       LCALL   ?FLT_GE
   \   00008B   5003         JNC     $+5
   \   00008D   02....       LJMP    ??gyro_self_test_4 & 0xFFFF
   \                     ??gyro_self_test_5:
   \   000090   EE           MOV     A,R6
   \   000091   2401         ADD     A,#0x1
   \   000093   0E           INC     R6
   \   000094   EF           MOV     A,R7
   \   000095   3400         ADDC    A,#0x0
   \   000097   FF           MOV     R7,A
   \                     ??gyro_self_test_2:
   \   000098   C3           CLR     C
   \   000099   EE           MOV     A,R6
   \   00009A   9403         SUBB    A,#0x3
   \   00009C   EF           MOV     A,R7
   \   00009D   9400         SUBB    A,#0x0
   \   00009F   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000A1   65D0         XRL     A,PSW
   \   0000A3   33           RLC     A
   \   0000A4   4003         JC      $+5
   \   0000A6   02....       LJMP    ??gyro_self_test_6 & 0xFFFF
   \   0000A9   8E..         MOV     ?V0 + 0,R6
   \   0000AB   8F..         MOV     ?V0 + 1,R7
   \   0000AD   7402         MOV     A,#0x2
   \   0000AF   78..         MOV     R0,#?V0 + 0
   \   0000B1   12....       LCALL   ?S_SHL
   \   0000B4   AA..         MOV     R2,?V0 + 0
   \   0000B6   AB..         MOV     R3,?V0 + 1
   \   0000B8                ; Setup parameters for call to function labs
   \   0000B8   7403         MOV     A,#0x3
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   2A           ADD     A,R2
   \   0000BF   F8           MOV     R0,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   3B           ADDC    A,R3
   \   0000C3   8882         MOV     DPL,R0
   \   0000C5   F583         MOV     DPH,A
   \   0000C7   78..         MOV     R0,#?V0 + 0
   \   0000C9   12....       LCALL   ?L_MOV_X
   \   0000CC   E5..         MOV     A,?V0 + 14
   \   0000CE   2A           ADD     A,R2
   \   0000CF   F582         MOV     DPL,A
   \   0000D1   E5..         MOV     A,?V0 + 15
   \   0000D3   3B           ADDC    A,R3
   \   0000D4   F583         MOV     DPH,A
   \   0000D6   78..         MOV     R0,#?V0 + 0
   \   0000D8   12....       LCALL   ?L_SUB_X
   \   0000DB   AA..         MOV     R2,?V0 + 0
   \   0000DD   AB..         MOV     R3,?V0 + 1
   \   0000DF   AC..         MOV     R4,?V0 + 2
   \   0000E1   AD..         MOV     R5,?V0 + 3
   \   0000E3   12....       LCALL   ??labs?relay
   \   0000E6   8A..         MOV     ?V0 + 4,R2
   \   0000E8   8B..         MOV     ?V0 + 5,R3
   \   0000EA   8C..         MOV     ?V0 + 6,R4
   \   0000EC   8D..         MOV     ?V0 + 7,R5
   \   0000EE   78..         MOV     R0,#?V0 + 4
   \   0000F0   12....       LCALL   ?L_TO_FLT
   \   0000F3   90....       MOV     DPTR,#__Constant_37800000
   \   0000F6   78..         MOV     R0,#?V0 + 0
   \   0000F8   12....       LCALL   ?L_MOV_X
   \   0000FB   78..         MOV     R0,#?V0 + 4
   \   0000FD   79..         MOV     R1,#?V0 + 0
   \   0000FF   12....       LCALL   ?FLT_MUL
   \   000102   85..82       MOV     DPL,?XSP + 0
   \   000105   85..83       MOV     DPH,?XSP + 1
   \   000108   E582         MOV     A,DPL
   \   00010A   2E           ADD     A,R6
   \   00010B   FA           MOV     R2,A
   \   00010C   E583         MOV     A,DPH
   \   00010E   3F           ADDC    A,R7
   \   00010F   FB           MOV     R3,A
   \   000110   8A82         MOV     DPL,R2
   \   000112   8B83         MOV     DPH,R3
   \   000114   E0           MOVX    A,@DPTR
   \   000115   7003         JNZ     $+5
   \   000117   02....       LJMP    ??gyro_self_test_3 & 0xFFFF
   \   00011A   90....       MOV     DPTR,#__Constant_41c80000
   \   00011D   78..         MOV     R0,#?V0 + 0
   \   00011F   12....       LCALL   ?L_MOV_X
   \   000122   800F         SJMP    ??gyro_self_test_7
   \                     ??gyro_self_test_8:
   \   000124   90....       MOV     DPTR,#__Constant_3f85e354
   \   000127   78..         MOV     R0,#?V0 + 8
   \   000129   12....       LCALL   ?L_MOV_X
   \   00012C   78..         MOV     R0,#?V0 + 0
   \   00012E   79..         MOV     R1,#?V0 + 8
   \   000130   12....       LCALL   ?FLT_MUL
   \                     ??gyro_self_test_7:
   \   000133   8A82         MOV     DPL,R2
   \   000135   8B83         MOV     DPH,R3
   \   000137   E0           MOVX    A,@DPTR
   \   000138   14           DEC     A
   \   000139   F0           MOVX    @DPTR,A
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   70E7         JNZ     ??gyro_self_test_8
   \   00013D   78..         MOV     R0,#?V0 + 4
   \   00013F   79..         MOV     R1,#?V0 + 0
   \   000141   12....       LCALL   ?FLT_DIV
   \   000144   90....       MOV     DPTR,#__Constant_bf800000
   \   000147   78..         MOV     R0,#?V0 + 0
   \   000149   12....       LCALL   ?L_MOV_X
   \   00014C   78..         MOV     R0,#?V0 + 4
   \   00014E   79..         MOV     R1,#?V0 + 0
   \   000150   12....       LCALL   ?FLT_ADD
   \   000153   E5..         MOV     A,?V0 + 7
   \   000155   C2E7         CLR     0xE0 /* A   */.7
   \   000157   F5..         MOV     ?V0 + 7,A
   \   000159   90....       MOV     DPTR,#__Constant_3e0f5c2a
   \   00015C   78..         MOV     R0,#?V0 + 0
   \   00015E   12....       LCALL   ?L_MOV_X
   \   000161   78..         MOV     R0,#?V0 + 4
   \   000163   79..         MOV     R1,#?V0 + 0
   \   000165   12....       LCALL   ?FLT_GE
   \   000168   4003         JC      $+5
   \   00016A   02....       LJMP    ??gyro_self_test_5 & 0xFFFF
   \                     ??gyro_self_test_4:
   \   00016D   75..01       MOV     ?V0 + 0,#0x1
   \   000170   75..00       MOV     ?V0 + 1,#0x0
   \   000173   EE           MOV     A,R6
   \   000174   78..         MOV     R0,#?V0 + 0
   \   000176   12....       LCALL   ?S_SHL
   \   000179   E5..         MOV     A,?V0 + 0
   \   00017B   45..         ORL     A,?V0 + 12
   \   00017D   F5..         MOV     ?V0 + 12,A
   \   00017F   E5..         MOV     A,?V0 + 1
   \   000181   45..         ORL     A,?V0 + 13
   \   000183   F5..         MOV     ?V0 + 13,A
   \   000185   02....       LJMP    ??gyro_self_test_5 & 0xFFFF
   1972                      result |= 1 << jj;
   1973              }
   1974              return result;
   \                     ??gyro_self_test_6:
   \   000188   AA..         MOV     R2,?V0 + 12
   \   00018A   AB..         MOV     R3,?V0 + 13
   \                     ??gyro_self_test_1:
   \   00018C   7405         MOV     A,#0x5
   \   00018E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000191   7F10         MOV     R7,#0x10
   \   000193   02....       LJMP    ?BANKED_LEAVE_XDATA
   1975          }
   1976          
   1977          #ifdef AK89xx_SECONDARY
   1978          static int compass_self_test(void)
   1979          {
   1980              unsigned char tmp[6];
   1981              unsigned char tries = 10;
   1982              int result = 0x07;
   1983              short data;
   1984          
   1985              mpu_set_bypass(1);
   1986          
   1987              tmp[0] = AKM_POWER_DOWN;
   1988              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   1989                  return 0x07;
   1990              tmp[0] = AKM_BIT_SELF_TEST;
   1991              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
   1992                  goto AKM_restore;
   1993              tmp[0] = AKM_MODE_SELF_TEST;
   1994              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   1995                  goto AKM_restore;
   1996          
   1997              do {
   1998                  delay_ms(10);
   1999                  if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
   2000                      goto AKM_restore;
   2001                  if (tmp[0] & AKM_DATA_READY)
   2002                      break;
   2003              } while (tries--);
   2004              if (!(tmp[0] & AKM_DATA_READY))
   2005                  goto AKM_restore;
   2006          
   2007              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
   2008                  goto AKM_restore;
   2009          
   2010              result = 0;
   2011              data = (short)(tmp[1] << 8) | tmp[0];
   2012              if ((data > 100) || (data < -100))
   2013                  result |= 0x01;
   2014              data = (short)(tmp[3] << 8) | tmp[2];
   2015              if ((data > 100) || (data < -100))
   2016                  result |= 0x02;
   2017              data = (short)(tmp[5] << 8) | tmp[4];
   2018              if ((data > -300) || (data < -1000))
   2019                  result |= 0x04;
   2020          
   2021          AKM_restore:
   2022              tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
   2023              i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
   2024              tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
   2025              i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
   2026              mpu_set_bypass(0);
   2027              return result;
   2028          }
   2029          #endif
   2030          #endif
   2031          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2032          static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
   \                     get_st_biases:
   2033          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV     A,#-0x1f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740F         MOV     A,#0xf
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   740D         MOV     A,#0xd
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   EC           MOV     A,R4
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   ED           MOV     A,R5
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   E9           MOV     A,R1
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   F0           MOVX    @DPTR,A
   2034              unsigned char data[MAX_PACKET_LENGTH];
   2035              unsigned char packet_count, ii;
   2036              unsigned short fifo_count;
   2037          
   2038              data[0] = 0x01;
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   7401         MOV     A,#0x1
   \   00002D   F0           MOVX    @DPTR,A
   2039              data[1] = 0;
   \   00002E   04           INC     A
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E4           CLR     A
   \   000033   F0           MOVX    @DPTR,A
   2040              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \   000034                ; Setup parameters for call to function MPU_Write_Len
   \   000034   04           INC     A
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   7B02         MOV     R3,#0x2
   \   00003E   90....       MOV     DPTR,#st
   \   000041   E0           MOVX    A,@DPTR
   \   000042   2412         ADD     A,#0x12
   \   000044   F8           MOV     R0,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   3400         ADDC    A,#0x0
   \   000049   F9           MOV     R1,A
   \   00004A   8882         MOV     DPL,R0
   \   00004C   8983         MOV     DPH,R1
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   FA           MOV     R2,A
   \   000050   90....       MOV     DPTR,#st + 2
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F8           MOV     R0,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F583         MOV     DPH,A
   \   000059   8882         MOV     DPL,R0
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   12....       LCALL   ??MPU_Write_Len?relay
   \   000060   E9           MOV     A,R1
   \   000061   6007         JZ      ??get_st_biases_0
   2041                  return -1;
   \                     ??get_st_biases_1:
   \   000063   7AFF         MOV     R2,#-0x1
   \   000065   7BFF         MOV     R3,#-0x1
   \   000067   02....       LJMP    ??get_st_biases_2 & 0xFFFF
   2042              delay_ms(200);
   \                     ??get_st_biases_0:
   \   00006A                ; Setup parameters for call to function delay_ms
   \   00006A   90....       MOV     DPTR,#__Constant_c8
   \   00006D   12....       LCALL   ?XLOAD_R2345
   \   000070   12....       LCALL   ??delay_ms?relay
   2043              data[0] = 0;
   \   000073   7401         MOV     A,#0x1
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   E4           CLR     A
   \   000079   F0           MOVX    @DPTR,A
   2044              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \   00007A                ; Setup parameters for call to function MPU_Write_Len
   \   00007A   AC82         MOV     R4,DPL
   \   00007C   AD83         MOV     R5,DPH
   \   00007E   7B01         MOV     R3,#0x1
   \   000080   90....       MOV     DPTR,#st
   \   000083   E0           MOVX    A,@DPTR
   \   000084   240F         ADD     A,#0xf
   \   000086   F8           MOV     R0,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   3400         ADDC    A,#0x0
   \   00008B   F9           MOV     R1,A
   \   00008C   8882         MOV     DPL,R0
   \   00008E   8983         MOV     DPH,R1
   \   000090   E0           MOVX    A,@DPTR
   \   000091   FA           MOV     R2,A
   \   000092   90....       MOV     DPTR,#st + 2
   \   000095   E0           MOVX    A,@DPTR
   \   000096   F8           MOV     R0,A
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   F583         MOV     DPH,A
   \   00009B   8882         MOV     DPL,R0
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   F9           MOV     R1,A
   \   00009F   12....       LCALL   ??MPU_Write_Len?relay
   \   0000A2   E9           MOV     A,R1
   \   0000A3   70BE         JNZ     ??get_st_biases_1
   2045                  return -1;
   2046              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   0000A5                ; Setup parameters for call to function MPU_Write_Len
   \   0000A5   7401         MOV     A,#0x1
   \   0000A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AA   AC82         MOV     R4,DPL
   \   0000AC   AD83         MOV     R5,DPH
   \   0000AE   7B01         MOV     R3,#0x1
   \   0000B0   90....       MOV     DPTR,#st
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   F8           MOV     R0,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   F583         MOV     DPH,A
   \   0000B9   8882         MOV     DPL,R0
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   FA           MOV     R2,A
   \   0000C2   90....       MOV     DPTR,#st + 2
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   F8           MOV     R0,A
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F583         MOV     DPH,A
   \   0000CB   8882         MOV     DPL,R0
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   F9           MOV     R1,A
   \   0000CF   12....       LCALL   ??MPU_Write_Len?relay
   \   0000D2   E9           MOV     A,R1
   \   0000D3   708E         JNZ     ??get_st_biases_1
   2047                  return -1;
   2048              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \   0000D5                ; Setup parameters for call to function MPU_Write_Len
   \   0000D5   7401         MOV     A,#0x1
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   AC82         MOV     R4,DPL
   \   0000DC   AD83         MOV     R5,DPH
   \   0000DE   7B01         MOV     R3,#0x1
   \   0000E0   90....       MOV     DPTR,#st
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   2412         ADD     A,#0x12
   \   0000E6   F8           MOV     R0,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   3400         ADDC    A,#0x0
   \   0000EB   F9           MOV     R1,A
   \   0000EC   8882         MOV     DPL,R0
   \   0000EE   8983         MOV     DPH,R1
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   FA           MOV     R2,A
   \   0000F2   90....       MOV     DPTR,#st + 2
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   F8           MOV     R0,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   F583         MOV     DPH,A
   \   0000FB   8882         MOV     DPL,R0
   \   0000FD   E0           MOVX    A,@DPTR
   \   0000FE   F9           MOV     R1,A
   \   0000FF   12....       LCALL   ??MPU_Write_Len?relay
   \   000102   E9           MOV     A,R1
   \   000103   6003         JZ      $+5
   \   000105   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2049                  return -1;
   2050              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   \   000108                ; Setup parameters for call to function MPU_Write_Len
   \   000108   7401         MOV     A,#0x1
   \   00010A   12....       LCALL   ?XSTACK_DISP0_8
   \   00010D   AC82         MOV     R4,DPL
   \   00010F   AD83         MOV     R5,DPH
   \   000111   7B01         MOV     R3,#0x1
   \   000113   90....       MOV     DPTR,#st
   \   000116   E0           MOVX    A,@DPTR
   \   000117   2417         ADD     A,#0x17
   \   000119   F8           MOV     R0,A
   \   00011A   A3           INC     DPTR
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   3400         ADDC    A,#0x0
   \   00011E   F9           MOV     R1,A
   \   00011F   8882         MOV     DPL,R0
   \   000121   8983         MOV     DPH,R1
   \   000123   E0           MOVX    A,@DPTR
   \   000124   FA           MOV     R2,A
   \   000125   90....       MOV     DPTR,#st + 2
   \   000128   E0           MOVX    A,@DPTR
   \   000129   F8           MOV     R0,A
   \   00012A   A3           INC     DPTR
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   F583         MOV     DPH,A
   \   00012E   8882         MOV     DPL,R0
   \   000130   E0           MOVX    A,@DPTR
   \   000131   F9           MOV     R1,A
   \   000132   12....       LCALL   ??MPU_Write_Len?relay
   \   000135   E9           MOV     A,R1
   \   000136   6003         JZ      $+5
   \   000138   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2051                  return -1;
   2052              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   00013B                ; Setup parameters for call to function MPU_Write_Len
   \   00013B   7401         MOV     A,#0x1
   \   00013D   12....       LCALL   ?XSTACK_DISP0_8
   \   000140   AC82         MOV     R4,DPL
   \   000142   AD83         MOV     R5,DPH
   \   000144   7B01         MOV     R3,#0x1
   \   000146   90....       MOV     DPTR,#st
   \   000149   E0           MOVX    A,@DPTR
   \   00014A   F8           MOV     R0,A
   \   00014B   A3           INC     DPTR
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   F583         MOV     DPH,A
   \   00014F   8882         MOV     DPL,R0
   \   000151   A3           INC     DPTR
   \   000152   A3           INC     DPTR
   \   000153   A3           INC     DPTR
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   FA           MOV     R2,A
   \   000157   90....       MOV     DPTR,#st + 2
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   F8           MOV     R0,A
   \   00015C   A3           INC     DPTR
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   F583         MOV     DPH,A
   \   000160   8882         MOV     DPL,R0
   \   000162   E0           MOVX    A,@DPTR
   \   000163   F9           MOV     R1,A
   \   000164   12....       LCALL   ??MPU_Write_Len?relay
   \   000167   E9           MOV     A,R1
   \   000168   6003         JZ      $+5
   \   00016A   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2053                  return -1;
   2054              data[0] = BIT_FIFO_RST | BIT_DMP_RST;
   \   00016D   7401         MOV     A,#0x1
   \   00016F   12....       LCALL   ?XSTACK_DISP0_8
   \   000172   740C         MOV     A,#0xc
   \   000174   F0           MOVX    @DPTR,A
   2055              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   000175                ; Setup parameters for call to function MPU_Write_Len
   \   000175   AC82         MOV     R4,DPL
   \   000177   AD83         MOV     R5,DPH
   \   000179   7B01         MOV     R3,#0x1
   \   00017B   90....       MOV     DPTR,#st
   \   00017E   E0           MOVX    A,@DPTR
   \   00017F   F8           MOV     R0,A
   \   000180   A3           INC     DPTR
   \   000181   E0           MOVX    A,@DPTR
   \   000182   F583         MOV     DPH,A
   \   000184   8882         MOV     DPL,R0
   \   000186   A3           INC     DPTR
   \   000187   A3           INC     DPTR
   \   000188   A3           INC     DPTR
   \   000189   A3           INC     DPTR
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   FA           MOV     R2,A
   \   00018C   90....       MOV     DPTR,#st + 2
   \   00018F   E0           MOVX    A,@DPTR
   \   000190   F8           MOV     R0,A
   \   000191   A3           INC     DPTR
   \   000192   E0           MOVX    A,@DPTR
   \   000193   F583         MOV     DPH,A
   \   000195   8882         MOV     DPL,R0
   \   000197   E0           MOVX    A,@DPTR
   \   000198   F9           MOV     R1,A
   \   000199   12....       LCALL   ??MPU_Write_Len?relay
   \   00019C   E9           MOV     A,R1
   \   00019D   6003         JZ      $+5
   \   00019F   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2056                  return -1;
   2057              delay_ms(15);
   \   0001A2                ; Setup parameters for call to function delay_ms
   \   0001A2   90....       MOV     DPTR,#__Constant_f
   \   0001A5   12....       LCALL   ?XLOAD_R2345
   \   0001A8   12....       LCALL   ??delay_ms?relay
   2058              data[0] = st.test->reg_lpf;
   \   0001AB   90....       MOV     DPTR,#st + 33
   \   0001AE   E0           MOVX    A,@DPTR
   \   0001AF   F8           MOV     R0,A
   \   0001B0   A3           INC     DPTR
   \   0001B1   E0           MOVX    A,@DPTR
   \   0001B2   F583         MOV     DPH,A
   \   0001B4   8882         MOV     DPL,R0
   \   0001B6   A3           INC     DPTR
   \   0001B7   A3           INC     DPTR
   \   0001B8   A3           INC     DPTR
   \   0001B9   A3           INC     DPTR
   \   0001BA   A3           INC     DPTR
   \   0001BB   A3           INC     DPTR
   \   0001BC   A3           INC     DPTR
   \   0001BD   A3           INC     DPTR
   \   0001BE   A3           INC     DPTR
   \   0001BF   E0           MOVX    A,@DPTR
   \   0001C0   C0E0         PUSH    A
   \   0001C2   7401         MOV     A,#0x1
   \   0001C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C7   D0E0         POP     A
   \   0001C9   F0           MOVX    @DPTR,A
   2059              if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \   0001CA                ; Setup parameters for call to function MPU_Write_Len
   \   0001CA   AC82         MOV     R4,DPL
   \   0001CC   AD83         MOV     R5,DPH
   \   0001CE   7B01         MOV     R3,#0x1
   \   0001D0   90....       MOV     DPTR,#st
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   F8           MOV     R0,A
   \   0001D5   A3           INC     DPTR
   \   0001D6   E0           MOVX    A,@DPTR
   \   0001D7   F583         MOV     DPH,A
   \   0001D9   8882         MOV     DPL,R0
   \   0001DB   A3           INC     DPTR
   \   0001DC   A3           INC     DPTR
   \   0001DD   E0           MOVX    A,@DPTR
   \   0001DE   FA           MOV     R2,A
   \   0001DF   90....       MOV     DPTR,#st + 2
   \   0001E2   E0           MOVX    A,@DPTR
   \   0001E3   F8           MOV     R0,A
   \   0001E4   A3           INC     DPTR
   \   0001E5   E0           MOVX    A,@DPTR
   \   0001E6   F583         MOV     DPH,A
   \   0001E8   8882         MOV     DPL,R0
   \   0001EA   E0           MOVX    A,@DPTR
   \   0001EB   F9           MOV     R1,A
   \   0001EC   12....       LCALL   ??MPU_Write_Len?relay
   \   0001EF   E9           MOV     A,R1
   \   0001F0   6003         JZ      $+5
   \   0001F2   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2060                  return -1;
   2061              data[0] = st.test->reg_rate_div;
   \   0001F5   90....       MOV     DPTR,#st + 33
   \   0001F8   E0           MOVX    A,@DPTR
   \   0001F9   F8           MOV     R0,A
   \   0001FA   A3           INC     DPTR
   \   0001FB   E0           MOVX    A,@DPTR
   \   0001FC   F583         MOV     DPH,A
   \   0001FE   8882         MOV     DPL,R0
   \   000200   A3           INC     DPTR
   \   000201   A3           INC     DPTR
   \   000202   A3           INC     DPTR
   \   000203   A3           INC     DPTR
   \   000204   A3           INC     DPTR
   \   000205   A3           INC     DPTR
   \   000206   A3           INC     DPTR
   \   000207   A3           INC     DPTR
   \   000208   E0           MOVX    A,@DPTR
   \   000209   C0E0         PUSH    A
   \   00020B   7401         MOV     A,#0x1
   \   00020D   12....       LCALL   ?XSTACK_DISP0_8
   \   000210   D0E0         POP     A
   \   000212   F0           MOVX    @DPTR,A
   2062              if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
   \   000213                ; Setup parameters for call to function MPU_Write_Len
   \   000213   AC82         MOV     R4,DPL
   \   000215   AD83         MOV     R5,DPH
   \   000217   7B01         MOV     R3,#0x1
   \   000219   90....       MOV     DPTR,#st
   \   00021C   E0           MOVX    A,@DPTR
   \   00021D   F8           MOV     R0,A
   \   00021E   A3           INC     DPTR
   \   00021F   E0           MOVX    A,@DPTR
   \   000220   F583         MOV     DPH,A
   \   000222   8882         MOV     DPL,R0
   \   000224   A3           INC     DPTR
   \   000225   E0           MOVX    A,@DPTR
   \   000226   FA           MOV     R2,A
   \   000227   90....       MOV     DPTR,#st + 2
   \   00022A   E0           MOVX    A,@DPTR
   \   00022B   F8           MOV     R0,A
   \   00022C   A3           INC     DPTR
   \   00022D   E0           MOVX    A,@DPTR
   \   00022E   F583         MOV     DPH,A
   \   000230   8882         MOV     DPL,R0
   \   000232   E0           MOVX    A,@DPTR
   \   000233   F9           MOV     R1,A
   \   000234   12....       LCALL   ??MPU_Write_Len?relay
   \   000237   E9           MOV     A,R1
   \   000238   6003         JZ      $+5
   \   00023A   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2063                  return -1;
   2064              if (hw_test)
   \   00023D   90....       MOV     DPTR,#st + 33
   \   000240   E0           MOVX    A,@DPTR
   \   000241   240A         ADD     A,#0xa
   \   000243   F8           MOV     R0,A
   \   000244   A3           INC     DPTR
   \   000245   E0           MOVX    A,@DPTR
   \   000246   3400         ADDC    A,#0x0
   \   000248   F9           MOV     R1,A
   \   000249   85..82       MOV     DPL,?XSP + 0
   \   00024C   85..83       MOV     DPH,?XSP + 1
   \   00024F   E0           MOVX    A,@DPTR
   \   000250   8882         MOV     DPL,R0
   \   000252   8983         MOV     DPH,R1
   \   000254   6005         JZ      ??get_st_biases_3
   2065                  data[0] = st.test->reg_gyro_fsr | 0xE0;
   \   000256   E0           MOVX    A,@DPTR
   \   000257   44E0         ORL     A,#0xe0
   \   000259   8001         SJMP    ??get_st_biases_4
   2066              else
   2067                  data[0] = st.test->reg_gyro_fsr;
   \                     ??get_st_biases_3:
   \   00025B   E0           MOVX    A,@DPTR
   \                     ??get_st_biases_4:
   \   00025C   C0E0         PUSH    A
   \   00025E   7401         MOV     A,#0x1
   \   000260   12....       LCALL   ?XSTACK_DISP0_8
   \   000263   D0E0         POP     A
   \   000265   F0           MOVX    @DPTR,A
   2068              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
   \   000266                ; Setup parameters for call to function MPU_Write_Len
   \   000266   AC82         MOV     R4,DPL
   \   000268   AD83         MOV     R5,DPH
   \   00026A   7B01         MOV     R3,#0x1
   \   00026C   90....       MOV     DPTR,#st
   \   00026F   E0           MOVX    A,@DPTR
   \   000270   F8           MOV     R0,A
   \   000271   A3           INC     DPTR
   \   000272   E0           MOVX    A,@DPTR
   \   000273   F583         MOV     DPH,A
   \   000275   8882         MOV     DPL,R0
   \   000277   A3           INC     DPTR
   \   000278   A3           INC     DPTR
   \   000279   A3           INC     DPTR
   \   00027A   A3           INC     DPTR
   \   00027B   A3           INC     DPTR
   \   00027C   A3           INC     DPTR
   \   00027D   E0           MOVX    A,@DPTR
   \   00027E   FA           MOV     R2,A
   \   00027F   90....       MOV     DPTR,#st + 2
   \   000282   E0           MOVX    A,@DPTR
   \   000283   F8           MOV     R0,A
   \   000284   A3           INC     DPTR
   \   000285   E0           MOVX    A,@DPTR
   \   000286   F583         MOV     DPH,A
   \   000288   8882         MOV     DPL,R0
   \   00028A   E0           MOVX    A,@DPTR
   \   00028B   F9           MOV     R1,A
   \   00028C   12....       LCALL   ??MPU_Write_Len?relay
   \   00028F   E9           MOV     A,R1
   \   000290   6003         JZ      $+5
   \   000292   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2069                  return -1;
   2070          
   2071              if (hw_test)
   \   000295   85..82       MOV     DPL,?XSP + 0
   \   000298   85..83       MOV     DPH,?XSP + 1
   \   00029B   E0           MOVX    A,@DPTR
   \   00029C   601E         JZ      ??get_st_biases_5
   2072                  data[0] = st.test->reg_accel_fsr | 0xE0;
   \   00029E   90....       MOV     DPTR,#st + 33
   \   0002A1   E0           MOVX    A,@DPTR
   \   0002A2   240B         ADD     A,#0xb
   \   0002A4   F8           MOV     R0,A
   \   0002A5   A3           INC     DPTR
   \   0002A6   E0           MOVX    A,@DPTR
   \   0002A7   3400         ADDC    A,#0x0
   \   0002A9   F9           MOV     R1,A
   \   0002AA   8882         MOV     DPL,R0
   \   0002AC   8983         MOV     DPH,R1
   \   0002AE   E0           MOVX    A,@DPTR
   \   0002AF   44E0         ORL     A,#0xe0
   \   0002B1   C0E0         PUSH    A
   \   0002B3   7401         MOV     A,#0x1
   \   0002B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B8   D0E0         POP     A
   \   0002BA   8007         SJMP    ??get_st_biases_6
   2073              else
   2074                  data[0] = test.reg_accel_fsr;
   \                     ??get_st_biases_5:
   \   0002BC   7401         MOV     A,#0x1
   \   0002BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C1   7418         MOV     A,#0x18
   \                     ??get_st_biases_6:
   \   0002C3   F0           MOVX    @DPTR,A
   2075              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \   0002C4                ; Setup parameters for call to function MPU_Write_Len
   \   0002C4   AC82         MOV     R4,DPL
   \   0002C6   AD83         MOV     R5,DPH
   \   0002C8   7B01         MOV     R3,#0x1
   \   0002CA   90....       MOV     DPTR,#st
   \   0002CD   E0           MOVX    A,@DPTR
   \   0002CE   F8           MOV     R0,A
   \   0002CF   A3           INC     DPTR
   \   0002D0   E0           MOVX    A,@DPTR
   \   0002D1   F583         MOV     DPH,A
   \   0002D3   8882         MOV     DPL,R0
   \   0002D5   A3           INC     DPTR
   \   0002D6   A3           INC     DPTR
   \   0002D7   A3           INC     DPTR
   \   0002D8   A3           INC     DPTR
   \   0002D9   A3           INC     DPTR
   \   0002DA   A3           INC     DPTR
   \   0002DB   A3           INC     DPTR
   \   0002DC   E0           MOVX    A,@DPTR
   \   0002DD   FA           MOV     R2,A
   \   0002DE   90....       MOV     DPTR,#st + 2
   \   0002E1   E0           MOVX    A,@DPTR
   \   0002E2   F8           MOV     R0,A
   \   0002E3   A3           INC     DPTR
   \   0002E4   E0           MOVX    A,@DPTR
   \   0002E5   F583         MOV     DPH,A
   \   0002E7   8882         MOV     DPL,R0
   \   0002E9   E0           MOVX    A,@DPTR
   \   0002EA   F9           MOV     R1,A
   \   0002EB   12....       LCALL   ??MPU_Write_Len?relay
   \   0002EE   E9           MOV     A,R1
   \   0002EF   6003         JZ      $+5
   \   0002F1   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2076                  return -1;
   2077              if (hw_test)
   \   0002F4   85..82       MOV     DPL,?XSP + 0
   \   0002F7   85..83       MOV     DPH,?XSP + 1
   \   0002FA   E0           MOVX    A,@DPTR
   \   0002FB   6009         JZ      ??get_st_biases_7
   2078                  delay_ms(200);
   \   0002FD                ; Setup parameters for call to function delay_ms
   \   0002FD   90....       MOV     DPTR,#__Constant_c8
   \   000300   12....       LCALL   ?XLOAD_R2345
   \   000303   12....       LCALL   ??delay_ms?relay
   2079          
   2080              /* Fill FIFO for test.wait_ms milliseconds. */
   2081              data[0] = BIT_FIFO_EN;
   \                     ??get_st_biases_7:
   \   000306   7401         MOV     A,#0x1
   \   000308   12....       LCALL   ?XSTACK_DISP0_8
   \   00030B   7440         MOV     A,#0x40
   \   00030D   F0           MOVX    @DPTR,A
   2082              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   00030E                ; Setup parameters for call to function MPU_Write_Len
   \   00030E   AC82         MOV     R4,DPL
   \   000310   AD83         MOV     R5,DPH
   \   000312   7B01         MOV     R3,#0x1
   \   000314   90....       MOV     DPTR,#st
   \   000317   E0           MOVX    A,@DPTR
   \   000318   F8           MOV     R0,A
   \   000319   A3           INC     DPTR
   \   00031A   E0           MOVX    A,@DPTR
   \   00031B   F583         MOV     DPH,A
   \   00031D   8882         MOV     DPL,R0
   \   00031F   A3           INC     DPTR
   \   000320   A3           INC     DPTR
   \   000321   A3           INC     DPTR
   \   000322   A3           INC     DPTR
   \   000323   E0           MOVX    A,@DPTR
   \   000324   FA           MOV     R2,A
   \   000325   90....       MOV     DPTR,#st + 2
   \   000328   E0           MOVX    A,@DPTR
   \   000329   F8           MOV     R0,A
   \   00032A   A3           INC     DPTR
   \   00032B   E0           MOVX    A,@DPTR
   \   00032C   F583         MOV     DPH,A
   \   00032E   8882         MOV     DPL,R0
   \   000330   E0           MOVX    A,@DPTR
   \   000331   F9           MOV     R1,A
   \   000332   12....       LCALL   ??MPU_Write_Len?relay
   \   000335   E9           MOV     A,R1
   \   000336   6003         JZ      $+5
   \   000338   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2083                  return -1;
   2084          
   2085              data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
   \   00033B   7401         MOV     A,#0x1
   \   00033D   12....       LCALL   ?XSTACK_DISP0_8
   \   000340   7478         MOV     A,#0x78
   \   000342   F0           MOVX    @DPTR,A
   2086              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   000343                ; Setup parameters for call to function MPU_Write_Len
   \   000343   AC82         MOV     R4,DPL
   \   000345   AD83         MOV     R5,DPH
   \   000347   7B01         MOV     R3,#0x1
   \   000349   90....       MOV     DPTR,#st
   \   00034C   E0           MOVX    A,@DPTR
   \   00034D   F8           MOV     R0,A
   \   00034E   A3           INC     DPTR
   \   00034F   E0           MOVX    A,@DPTR
   \   000350   F583         MOV     DPH,A
   \   000352   8882         MOV     DPL,R0
   \   000354   A3           INC     DPTR
   \   000355   A3           INC     DPTR
   \   000356   A3           INC     DPTR
   \   000357   A3           INC     DPTR
   \   000358   A3           INC     DPTR
   \   000359   E0           MOVX    A,@DPTR
   \   00035A   FA           MOV     R2,A
   \   00035B   90....       MOV     DPTR,#st + 2
   \   00035E   E0           MOVX    A,@DPTR
   \   00035F   F8           MOV     R0,A
   \   000360   A3           INC     DPTR
   \   000361   E0           MOVX    A,@DPTR
   \   000362   F583         MOV     DPH,A
   \   000364   8882         MOV     DPL,R0
   \   000366   E0           MOVX    A,@DPTR
   \   000367   F9           MOV     R1,A
   \   000368   12....       LCALL   ??MPU_Write_Len?relay
   \   00036B   E9           MOV     A,R1
   \   00036C   6003         JZ      $+5
   \   00036E   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2087                  return -1;
   2088              delay_ms(test.wait_ms);
   \   000371                ; Setup parameters for call to function delay_ms
   \   000371   90....       MOV     DPTR,#__Constant_32
   \   000374   12....       LCALL   ?XLOAD_R2345
   \   000377   12....       LCALL   ??delay_ms?relay
   2089              data[0] = 0;
   \   00037A   7401         MOV     A,#0x1
   \   00037C   12....       LCALL   ?XSTACK_DISP0_8
   \   00037F   E4           CLR     A
   \   000380   F0           MOVX    @DPTR,A
   2090              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   000381                ; Setup parameters for call to function MPU_Write_Len
   \   000381   AC82         MOV     R4,DPL
   \   000383   AD83         MOV     R5,DPH
   \   000385   7B01         MOV     R3,#0x1
   \   000387   90....       MOV     DPTR,#st
   \   00038A   E0           MOVX    A,@DPTR
   \   00038B   F8           MOV     R0,A
   \   00038C   A3           INC     DPTR
   \   00038D   E0           MOVX    A,@DPTR
   \   00038E   F583         MOV     DPH,A
   \   000390   8882         MOV     DPL,R0
   \   000392   A3           INC     DPTR
   \   000393   A3           INC     DPTR
   \   000394   A3           INC     DPTR
   \   000395   A3           INC     DPTR
   \   000396   A3           INC     DPTR
   \   000397   E0           MOVX    A,@DPTR
   \   000398   FA           MOV     R2,A
   \   000399   90....       MOV     DPTR,#st + 2
   \   00039C   E0           MOVX    A,@DPTR
   \   00039D   F8           MOV     R0,A
   \   00039E   A3           INC     DPTR
   \   00039F   E0           MOVX    A,@DPTR
   \   0003A0   F583         MOV     DPH,A
   \   0003A2   8882         MOV     DPL,R0
   \   0003A4   E0           MOVX    A,@DPTR
   \   0003A5   F9           MOV     R1,A
   \   0003A6   12....       LCALL   ??MPU_Write_Len?relay
   \   0003A9   E9           MOV     A,R1
   \   0003AA   6003         JZ      $+5
   \   0003AC   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2091                  return -1;
   2092          
   2093              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \   0003AF                ; Setup parameters for call to function MPU_Read_Len
   \   0003AF   7401         MOV     A,#0x1
   \   0003B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B4   AC82         MOV     R4,DPL
   \   0003B6   AD83         MOV     R5,DPH
   \   0003B8   7B02         MOV     R3,#0x2
   \   0003BA   90....       MOV     DPTR,#st
   \   0003BD   E0           MOVX    A,@DPTR
   \   0003BE   F8           MOV     R0,A
   \   0003BF   A3           INC     DPTR
   \   0003C0   E0           MOVX    A,@DPTR
   \   0003C1   F583         MOV     DPH,A
   \   0003C3   8882         MOV     DPL,R0
   \   0003C5   A3           INC     DPTR
   \   0003C6   A3           INC     DPTR
   \   0003C7   A3           INC     DPTR
   \   0003C8   A3           INC     DPTR
   \   0003C9   A3           INC     DPTR
   \   0003CA   A3           INC     DPTR
   \   0003CB   A3           INC     DPTR
   \   0003CC   A3           INC     DPTR
   \   0003CD   A3           INC     DPTR
   \   0003CE   A3           INC     DPTR
   \   0003CF   E0           MOVX    A,@DPTR
   \   0003D0   FA           MOV     R2,A
   \   0003D1   90....       MOV     DPTR,#st + 2
   \   0003D4   E0           MOVX    A,@DPTR
   \   0003D5   F8           MOV     R0,A
   \   0003D6   A3           INC     DPTR
   \   0003D7   E0           MOVX    A,@DPTR
   \   0003D8   F583         MOV     DPH,A
   \   0003DA   8882         MOV     DPL,R0
   \   0003DC   E0           MOVX    A,@DPTR
   \   0003DD   F9           MOV     R1,A
   \   0003DE   12....       LCALL   ??MPU_Read_Len?relay
   \   0003E1   E9           MOV     A,R1
   \   0003E2   6003         JZ      $+5
   \   0003E4   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2094                  return -1;
   2095          
   2096              fifo_count = (data[0] << 8) | data[1];
   2097              packet_count = fifo_count / MAX_PACKET_LENGTH;
   \   0003E7   7401         MOV     A,#0x1
   \   0003E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EC   E0           MOVX    A,@DPTR
   \   0003ED   F9           MOV     R1,A
   \   0003EE   7402         MOV     A,#0x2
   \   0003F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F3   E0           MOVX    A,@DPTR
   \   0003F4   F8           MOV     R0,A
   \   0003F5   7A0C         MOV     R2,#0xc
   \   0003F7   7B00         MOV     R3,#0x0
   \   0003F9   12....       LCALL   ?US_DIV_MOD
   \   0003FC   E8           MOV     A,R0
   \   0003FD   F5..         MOV     ?V0 + 0,A
   2098              gyro[0] = gyro[1] = gyro[2] = 0;
   \   0003FF   740F         MOV     A,#0xf
   \   000401   12....       LCALL   ?XSTACK_DISP0_8
   \   000404   E0           MOVX    A,@DPTR
   \   000405   2408         ADD     A,#0x8
   \   000407   F5..         MOV     ?V0 + 14,A
   \   000409   A3           INC     DPTR
   \   00040A   E0           MOVX    A,@DPTR
   \   00040B   3400         ADDC    A,#0x0
   \   00040D   F5..         MOV     ?V0 + 15,A
   \   00040F   90....       MOV     DPTR,#__Constant_0
   \   000412   12....       LCALL   ?XLOAD_R2345
   \   000415   85..82       MOV     DPL,?V0 + 14
   \   000418   85..83       MOV     DPH,?V0 + 15
   \   00041B   12....       LCALL   ?XSTORE_R2345
   \   00041E   740F         MOV     A,#0xf
   \   000420   12....       LCALL   ?XSTACK_DISP0_8
   \   000423   E0           MOVX    A,@DPTR
   \   000424   2404         ADD     A,#0x4
   \   000426   F5..         MOV     ?V0 + 12,A
   \   000428   A3           INC     DPTR
   \   000429   E0           MOVX    A,@DPTR
   \   00042A   3400         ADDC    A,#0x0
   \   00042C   F5..         MOV     ?V0 + 13,A
   \   00042E   90....       MOV     DPTR,#__Constant_0
   \   000431   12....       LCALL   ?XLOAD_R2345
   \   000434   85..82       MOV     DPL,?V0 + 12
   \   000437   85..83       MOV     DPH,?V0 + 13
   \   00043A   12....       LCALL   ?XSTORE_R2345
   \   00043D   90....       MOV     DPTR,#__Constant_0
   \   000440   12....       LCALL   ?XLOAD_R2345
   \   000443   740F         MOV     A,#0xf
   \   000445   12....       LCALL   ?XSTACK_DISP0_8
   \   000448   E0           MOVX    A,@DPTR
   \   000449   F8           MOV     R0,A
   \   00044A   A3           INC     DPTR
   \   00044B   E0           MOVX    A,@DPTR
   \   00044C   F583         MOV     DPH,A
   \   00044E   8882         MOV     DPL,R0
   \   000450   12....       LCALL   ?XSTORE_R2345
   2099              accel[0] = accel[1] = accel[2] = 0;
   \   000453   740D         MOV     A,#0xd
   \   000455   12....       LCALL   ?XSTACK_DISP0_8
   \   000458   E0           MOVX    A,@DPTR
   \   000459   2408         ADD     A,#0x8
   \   00045B   FE           MOV     R6,A
   \   00045C   A3           INC     DPTR
   \   00045D   E0           MOVX    A,@DPTR
   \   00045E   3400         ADDC    A,#0x0
   \   000460   FF           MOV     R7,A
   \   000461   90....       MOV     DPTR,#__Constant_0
   \   000464   12....       LCALL   ?XLOAD_R2345
   \   000467   8E82         MOV     DPL,R6
   \   000469   8F83         MOV     DPH,R7
   \   00046B   12....       LCALL   ?XSTORE_R2345
   \   00046E   740D         MOV     A,#0xd
   \   000470   12....       LCALL   ?XSTACK_DISP0_8
   \   000473   E0           MOVX    A,@DPTR
   \   000474   2404         ADD     A,#0x4
   \   000476   F8           MOV     R0,A
   \   000477   A3           INC     DPTR
   \   000478   E0           MOVX    A,@DPTR
   \   000479   3400         ADDC    A,#0x0
   \   00047B   F9           MOV     R1,A
   \   00047C   7411         MOV     A,#0x11
   \   00047E   12....       LCALL   ?XSTACK_DISP0_8
   \   000481   E8           MOV     A,R0
   \   000482   F0           MOVX    @DPTR,A
   \   000483   A3           INC     DPTR
   \   000484   E9           MOV     A,R1
   \   000485   F0           MOVX    @DPTR,A
   \   000486   90....       MOV     DPTR,#__Constant_0
   \   000489   12....       LCALL   ?XLOAD_R2345
   \   00048C   7411         MOV     A,#0x11
   \   00048E   12....       LCALL   ?XSTACK_DISP0_8
   \   000491   E0           MOVX    A,@DPTR
   \   000492   F8           MOV     R0,A
   \   000493   A3           INC     DPTR
   \   000494   E0           MOVX    A,@DPTR
   \   000495   F583         MOV     DPH,A
   \   000497   8882         MOV     DPL,R0
   \   000499   12....       LCALL   ?XSTORE_R2345
   \   00049C   90....       MOV     DPTR,#__Constant_0
   \   00049F   12....       LCALL   ?XLOAD_R2345
   \   0004A2   740D         MOV     A,#0xd
   \   0004A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0004A7   E0           MOVX    A,@DPTR
   \   0004A8   F8           MOV     R0,A
   \   0004A9   A3           INC     DPTR
   \   0004AA   E0           MOVX    A,@DPTR
   \   0004AB   F583         MOV     DPH,A
   \   0004AD   8882         MOV     DPL,R0
   \   0004AF   12....       LCALL   ?XSTORE_R2345
   2100          
   2101              for (ii = 0; ii < packet_count; ii++) {
   \   0004B2   75..00       MOV     ?V0 + 1,#0x0
   \   0004B5   02....       LJMP    ??get_st_biases_8 & 0xFFFF
   2102                  short accel_cur[3], gyro_cur[3];
   2103                  if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
   \                     ??get_st_biases_9:
   \   0004B8                ; Setup parameters for call to function MPU_Read_Len
   \   0004B8   7401         MOV     A,#0x1
   \   0004BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0004BD   AC82         MOV     R4,DPL
   \   0004BF   AD83         MOV     R5,DPH
   \   0004C1   7B0C         MOV     R3,#0xc
   \   0004C3   90....       MOV     DPTR,#st
   \   0004C6   E0           MOVX    A,@DPTR
   \   0004C7   240B         ADD     A,#0xb
   \   0004C9   F8           MOV     R0,A
   \   0004CA   A3           INC     DPTR
   \   0004CB   E0           MOVX    A,@DPTR
   \   0004CC   3400         ADDC    A,#0x0
   \   0004CE   F9           MOV     R1,A
   \   0004CF   8882         MOV     DPL,R0
   \   0004D1   8983         MOV     DPH,R1
   \   0004D3   E0           MOVX    A,@DPTR
   \   0004D4   FA           MOV     R2,A
   \   0004D5   90....       MOV     DPTR,#st + 2
   \   0004D8   E0           MOVX    A,@DPTR
   \   0004D9   F8           MOV     R0,A
   \   0004DA   A3           INC     DPTR
   \   0004DB   E0           MOVX    A,@DPTR
   \   0004DC   F583         MOV     DPH,A
   \   0004DE   8882         MOV     DPL,R0
   \   0004E0   E0           MOVX    A,@DPTR
   \   0004E1   F9           MOV     R1,A
   \   0004E2   12....       LCALL   ??MPU_Read_Len?relay
   \   0004E5   E9           MOV     A,R1
   \   0004E6   6003         JZ      $+5
   \   0004E8   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2104                      return -1;
   2105                  accel_cur[0] = ((short)data[0] << 8) | data[1];
   \   0004EB   7401         MOV     A,#0x1
   \   0004ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0004F0   E0           MOVX    A,@DPTR
   \   0004F1   F9           MOV     R1,A
   \   0004F2   7402         MOV     A,#0x2
   \   0004F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0004F7   E0           MOVX    A,@DPTR
   \   0004F8   F8           MOV     R0,A
   \   0004F9   7419         MOV     A,#0x19
   \   0004FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0004FE   E8           MOV     A,R0
   \   0004FF   F0           MOVX    @DPTR,A
   \   000500   A3           INC     DPTR
   \   000501   E9           MOV     A,R1
   \   000502   F0           MOVX    @DPTR,A
   2106                  accel_cur[1] = ((short)data[2] << 8) | data[3];
   \   000503   7403         MOV     A,#0x3
   \   000505   12....       LCALL   ?XSTACK_DISP0_8
   \   000508   E0           MOVX    A,@DPTR
   \   000509   F9           MOV     R1,A
   \   00050A   7404         MOV     A,#0x4
   \   00050C   12....       LCALL   ?XSTACK_DISP0_8
   \   00050F   E0           MOVX    A,@DPTR
   \   000510   FC           MOV     R4,A
   \   000511   E9           MOV     A,R1
   \   000512   FD           MOV     R5,A
   \   000513   741B         MOV     A,#0x1b
   \   000515   12....       LCALL   ?XSTACK_DISP0_8
   \   000518   EC           MOV     A,R4
   \   000519   F0           MOVX    @DPTR,A
   \   00051A   A3           INC     DPTR
   \   00051B   ED           MOV     A,R5
   \   00051C   F0           MOVX    @DPTR,A
   2107                  accel_cur[2] = ((short)data[4] << 8) | data[5];
   \   00051D   7405         MOV     A,#0x5
   \   00051F   12....       LCALL   ?XSTACK_DISP0_8
   \   000522   E0           MOVX    A,@DPTR
   \   000523   F9           MOV     R1,A
   \   000524   7406         MOV     A,#0x6
   \   000526   12....       LCALL   ?XSTACK_DISP0_8
   \   000529   E0           MOVX    A,@DPTR
   \   00052A   FA           MOV     R2,A
   \   00052B   E9           MOV     A,R1
   \   00052C   FB           MOV     R3,A
   \   00052D   741D         MOV     A,#0x1d
   \   00052F   12....       LCALL   ?XSTACK_DISP0_8
   \   000532   EA           MOV     A,R2
   \   000533   F0           MOVX    @DPTR,A
   \   000534   A3           INC     DPTR
   \   000535   EB           MOV     A,R3
   \   000536   F0           MOVX    @DPTR,A
   2108                  accel[0] += (long)accel_cur[0];
   \   000537   7419         MOV     A,#0x19
   \   000539   12....       LCALL   ?XSTACK_DISP0_8
   \   00053C   E0           MOVX    A,@DPTR
   \   00053D   F5..         MOV     ?V0 + 4,A
   \   00053F   A3           INC     DPTR
   \   000540   E0           MOVX    A,@DPTR
   \   000541   F5..         MOV     ?V0 + 5,A
   \   000543   33           RLC     A
   \   000544   95E0         SUBB    A,0xE0 /* A   */
   \   000546   F5..         MOV     ?V0 + 6,A
   \   000548   F5..         MOV     ?V0 + 7,A
   \   00054A   740D         MOV     A,#0xd
   \   00054C   12....       LCALL   ?XSTACK_DISP0_8
   \   00054F   E0           MOVX    A,@DPTR
   \   000550   F8           MOV     R0,A
   \   000551   A3           INC     DPTR
   \   000552   E0           MOVX    A,@DPTR
   \   000553   F583         MOV     DPH,A
   \   000555   8882         MOV     DPL,R0
   \   000557   78..         MOV     R0,#?V0 + 4
   \   000559   12....       LCALL   ?L_ADD_TO_X
   2109                  accel[1] += (long)accel_cur[1];
   \   00055C   8C..         MOV     ?V0 + 4,R4
   \   00055E   ED           MOV     A,R5
   \   00055F   F5..         MOV     ?V0 + 5,A
   \   000561   33           RLC     A
   \   000562   95E0         SUBB    A,0xE0 /* A   */
   \   000564   F5..         MOV     ?V0 + 6,A
   \   000566   F5..         MOV     ?V0 + 7,A
   \   000568   7411         MOV     A,#0x11
   \   00056A   12....       LCALL   ?XSTACK_DISP0_8
   \   00056D   E0           MOVX    A,@DPTR
   \   00056E   F8           MOV     R0,A
   \   00056F   A3           INC     DPTR
   \   000570   E0           MOVX    A,@DPTR
   \   000571   F583         MOV     DPH,A
   \   000573   8882         MOV     DPL,R0
   \   000575   78..         MOV     R0,#?V0 + 4
   \   000577   12....       LCALL   ?L_ADD_TO_X
   2110                  accel[2] += (long)accel_cur[2];
   \   00057A   8A..         MOV     ?V0 + 4,R2
   \   00057C   EB           MOV     A,R3
   \   00057D   F5..         MOV     ?V0 + 5,A
   \   00057F   33           RLC     A
   \   000580   95E0         SUBB    A,0xE0 /* A   */
   \   000582   F5..         MOV     ?V0 + 6,A
   \   000584   F5..         MOV     ?V0 + 7,A
   \   000586   8E82         MOV     DPL,R6
   \   000588   8F83         MOV     DPH,R7
   \   00058A   78..         MOV     R0,#?V0 + 4
   \   00058C   12....       LCALL   ?L_ADD_TO_X
   2111                  gyro_cur[0] = (((short)data[6] << 8) | data[7]);
   \   00058F   7407         MOV     A,#0x7
   \   000591   12....       LCALL   ?XSTACK_DISP0_8
   \   000594   E0           MOVX    A,@DPTR
   \   000595   F9           MOV     R1,A
   \   000596   7408         MOV     A,#0x8
   \   000598   12....       LCALL   ?XSTACK_DISP0_8
   \   00059B   E0           MOVX    A,@DPTR
   \   00059C   F8           MOV     R0,A
   \   00059D   7413         MOV     A,#0x13
   \   00059F   12....       LCALL   ?XSTACK_DISP0_8
   \   0005A2   E8           MOV     A,R0
   \   0005A3   F0           MOVX    @DPTR,A
   \   0005A4   A3           INC     DPTR
   \   0005A5   E9           MOV     A,R1
   \   0005A6   F0           MOVX    @DPTR,A
   2112                  gyro_cur[1] = (((short)data[8] << 8) | data[9]);
   \   0005A7   7409         MOV     A,#0x9
   \   0005A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0005AC   E0           MOVX    A,@DPTR
   \   0005AD   F9           MOV     R1,A
   \   0005AE   740A         MOV     A,#0xa
   \   0005B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0005B3   E0           MOVX    A,@DPTR
   \   0005B4   FC           MOV     R4,A
   \   0005B5   E9           MOV     A,R1
   \   0005B6   FD           MOV     R5,A
   \   0005B7   7415         MOV     A,#0x15
   \   0005B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0005BC   EC           MOV     A,R4
   \   0005BD   F0           MOVX    @DPTR,A
   \   0005BE   A3           INC     DPTR
   \   0005BF   ED           MOV     A,R5
   \   0005C0   F0           MOVX    @DPTR,A
   2113                  gyro_cur[2] = (((short)data[10] << 8) | data[11]);
   \   0005C1   740B         MOV     A,#0xb
   \   0005C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0005C6   E0           MOVX    A,@DPTR
   \   0005C7   F9           MOV     R1,A
   \   0005C8   740C         MOV     A,#0xc
   \   0005CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0005CD   E0           MOVX    A,@DPTR
   \   0005CE   FA           MOV     R2,A
   \   0005CF   E9           MOV     A,R1
   \   0005D0   FB           MOV     R3,A
   \   0005D1   7417         MOV     A,#0x17
   \   0005D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0005D6   EA           MOV     A,R2
   \   0005D7   F0           MOVX    @DPTR,A
   \   0005D8   A3           INC     DPTR
   \   0005D9   EB           MOV     A,R3
   \   0005DA   F0           MOVX    @DPTR,A
   2114                  gyro[0] += (long)gyro_cur[0];
   \   0005DB   7413         MOV     A,#0x13
   \   0005DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0005E0   E0           MOVX    A,@DPTR
   \   0005E1   F5..         MOV     ?V0 + 4,A
   \   0005E3   A3           INC     DPTR
   \   0005E4   E0           MOVX    A,@DPTR
   \   0005E5   F5..         MOV     ?V0 + 5,A
   \   0005E7   33           RLC     A
   \   0005E8   95E0         SUBB    A,0xE0 /* A   */
   \   0005EA   F5..         MOV     ?V0 + 6,A
   \   0005EC   F5..         MOV     ?V0 + 7,A
   \   0005EE   740F         MOV     A,#0xf
   \   0005F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0005F3   E0           MOVX    A,@DPTR
   \   0005F4   F8           MOV     R0,A
   \   0005F5   A3           INC     DPTR
   \   0005F6   E0           MOVX    A,@DPTR
   \   0005F7   F583         MOV     DPH,A
   \   0005F9   8882         MOV     DPL,R0
   \   0005FB   78..         MOV     R0,#?V0 + 4
   \   0005FD   12....       LCALL   ?L_ADD_TO_X
   2115                  gyro[1] += (long)gyro_cur[1];
   \   000600   8C..         MOV     ?V0 + 4,R4
   \   000602   ED           MOV     A,R5
   \   000603   F5..         MOV     ?V0 + 5,A
   \   000605   33           RLC     A
   \   000606   95E0         SUBB    A,0xE0 /* A   */
   \   000608   F5..         MOV     ?V0 + 6,A
   \   00060A   F5..         MOV     ?V0 + 7,A
   \   00060C   85..82       MOV     DPL,?V0 + 12
   \   00060F   85..83       MOV     DPH,?V0 + 13
   \   000612   78..         MOV     R0,#?V0 + 4
   \   000614   12....       LCALL   ?L_ADD_TO_X
   2116                  gyro[2] += (long)gyro_cur[2];
   \   000617   8A..         MOV     ?V0 + 4,R2
   \   000619   EB           MOV     A,R3
   \   00061A   F5..         MOV     ?V0 + 5,A
   \   00061C   33           RLC     A
   \   00061D   95E0         SUBB    A,0xE0 /* A   */
   \   00061F   F5..         MOV     ?V0 + 6,A
   \   000621   F5..         MOV     ?V0 + 7,A
   \   000623   85..82       MOV     DPL,?V0 + 14
   \   000626   85..83       MOV     DPH,?V0 + 15
   \   000629   78..         MOV     R0,#?V0 + 4
   \   00062B   12....       LCALL   ?L_ADD_TO_X
   2117              }
   \   00062E   05..         INC     ?V0 + 1
   \                     ??get_st_biases_8:
   \   000630   E5..         MOV     A,?V0 + 1
   \   000632   C3           CLR     C
   \   000633   95..         SUBB    A,?V0 + 0
   \   000635   5003         JNC     $+5
   \   000637   02....       LJMP    ??get_st_biases_9 & 0xFFFF
   2118          #ifdef EMPL_NO_64BIT
   2119              gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
   2120              gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
   2121              gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
   2122              if (has_accel) {
   2123                  accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
   2124                      packet_count);
   2125                  accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
   2126                      packet_count);
   2127                  accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
   2128                      packet_count);
   2129                  /* Don't remove gravity! */
   2130                  accel[2] -= 65536L;
   2131              }
   2132          #else
   2133              gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
   \   00063A   E5..         MOV     A,?V0 + 0
   \   00063C   F5..         MOV     ?V0 + 4,A
   \   00063E   E4           CLR     A
   \   00063F   F5..         MOV     ?V0 + 5,A
   \   000641   F5..         MOV     ?V0 + 6,A
   \   000643   F5..         MOV     ?V0 + 7,A
   \   000645   740F         MOV     A,#0xf
   \   000647   12....       LCALL   ?XSTACK_DISP0_8
   \   00064A   E0           MOVX    A,@DPTR
   \   00064B   F8           MOV     R0,A
   \   00064C   A3           INC     DPTR
   \   00064D   E0           MOVX    A,@DPTR
   \   00064E   F583         MOV     DPH,A
   \   000650   8882         MOV     DPL,R0
   \   000652   78..         MOV     R0,#?V0 + 0
   \   000654   12....       LCALL   ?L_MOV_X
   \   000657   7410         MOV     A,#0x10
   \   000659   78..         MOV     R0,#?V0 + 0
   \   00065B   12....       LCALL   ?L_SHL
   \   00065E   90....       MOV     DPTR,#__Constant_83
   \   000661   78..         MOV     R0,#?V0 + 8
   \   000663   12....       LCALL   ?L_MOV_X
   \   000666   78..         MOV     R0,#?V0 + 0
   \   000668   79..         MOV     R1,#?V0 + 8
   \   00066A   12....       LCALL   ?UL_DIV_MOD
   \   00066D   85....       MOV     ?V0 + 8,?V0 + 4
   \   000670   85....       MOV     ?V0 + 9,?V0 + 5
   \   000673   85....       MOV     ?V0 + 10,?V0 + 6
   \   000676   85....       MOV     ?V0 + 11,?V0 + 7
   \   000679   78..         MOV     R0,#?V0 + 0
   \   00067B   79..         MOV     R1,#?V0 + 8
   \   00067D   12....       LCALL   ?UL_DIV_MOD
   \   000680   740F         MOV     A,#0xf
   \   000682   12....       LCALL   ?XSTACK_DISP0_8
   \   000685   E0           MOVX    A,@DPTR
   \   000686   F8           MOV     R0,A
   \   000687   A3           INC     DPTR
   \   000688   E0           MOVX    A,@DPTR
   \   000689   F583         MOV     DPH,A
   \   00068B   8882         MOV     DPL,R0
   \   00068D   78..         MOV     R0,#?V0 + 0
   \   00068F   12....       LCALL   ?L_MOV_TO_X
   2134              gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
   \   000692   85..82       MOV     DPL,?V0 + 12
   \   000695   85..83       MOV     DPH,?V0 + 13
   \   000698   78..         MOV     R0,#?V0 + 0
   \   00069A   12....       LCALL   ?L_MOV_X
   \   00069D   7410         MOV     A,#0x10
   \   00069F   78..         MOV     R0,#?V0 + 0
   \   0006A1   12....       LCALL   ?L_SHL
   \   0006A4   90....       MOV     DPTR,#__Constant_83
   \   0006A7   78..         MOV     R0,#?V0 + 8
   \   0006A9   12....       LCALL   ?L_MOV_X
   \   0006AC   78..         MOV     R0,#?V0 + 0
   \   0006AE   79..         MOV     R1,#?V0 + 8
   \   0006B0   12....       LCALL   ?UL_DIV_MOD
   \   0006B3   85....       MOV     ?V0 + 8,?V0 + 4
   \   0006B6   85....       MOV     ?V0 + 9,?V0 + 5
   \   0006B9   85....       MOV     ?V0 + 10,?V0 + 6
   \   0006BC   85....       MOV     ?V0 + 11,?V0 + 7
   \   0006BF   78..         MOV     R0,#?V0 + 0
   \   0006C1   79..         MOV     R1,#?V0 + 8
   \   0006C3   12....       LCALL   ?UL_DIV_MOD
   \   0006C6   85..82       MOV     DPL,?V0 + 12
   \   0006C9   85..83       MOV     DPH,?V0 + 13
   \   0006CC   78..         MOV     R0,#?V0 + 0
   \   0006CE   12....       LCALL   ?L_MOV_TO_X
   2135              gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
   \   0006D1   85..82       MOV     DPL,?V0 + 14
   \   0006D4   85..83       MOV     DPH,?V0 + 15
   \   0006D7   78..         MOV     R0,#?V0 + 0
   \   0006D9   12....       LCALL   ?L_MOV_X
   \   0006DC   7410         MOV     A,#0x10
   \   0006DE   78..         MOV     R0,#?V0 + 0
   \   0006E0   12....       LCALL   ?L_SHL
   \   0006E3   90....       MOV     DPTR,#__Constant_83
   \   0006E6   78..         MOV     R0,#?V0 + 8
   \   0006E8   12....       LCALL   ?L_MOV_X
   \   0006EB   78..         MOV     R0,#?V0 + 0
   \   0006ED   79..         MOV     R1,#?V0 + 8
   \   0006EF   12....       LCALL   ?UL_DIV_MOD
   \   0006F2   85....       MOV     ?V0 + 8,?V0 + 4
   \   0006F5   85....       MOV     ?V0 + 9,?V0 + 5
   \   0006F8   85....       MOV     ?V0 + 10,?V0 + 6
   \   0006FB   85....       MOV     ?V0 + 11,?V0 + 7
   \   0006FE   78..         MOV     R0,#?V0 + 0
   \   000700   79..         MOV     R1,#?V0 + 8
   \   000702   12....       LCALL   ?UL_DIV_MOD
   \   000705   85..82       MOV     DPL,?V0 + 14
   \   000708   85..83       MOV     DPH,?V0 + 15
   \   00070B   78..         MOV     R0,#?V0 + 0
   \   00070D   12....       LCALL   ?L_MOV_TO_X
   2136              accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
   2137                  packet_count);
   \   000710   740D         MOV     A,#0xd
   \   000712   12....       LCALL   ?XSTACK_DISP0_8
   \   000715   E0           MOVX    A,@DPTR
   \   000716   F8           MOV     R0,A
   \   000717   A3           INC     DPTR
   \   000718   E0           MOVX    A,@DPTR
   \   000719   F583         MOV     DPH,A
   \   00071B   8882         MOV     DPL,R0
   \   00071D   78..         MOV     R0,#?V0 + 8
   \   00071F   12....       LCALL   ?L_MOV_X
   \   000722   7410         MOV     A,#0x10
   \   000724   78..         MOV     R0,#?V0 + 8
   \   000726   12....       LCALL   ?L_SHL
   \   000729   740B         MOV     A,#0xb
   \   00072B   78..         MOV     R0,#?V0 + 8
   \   00072D   12....       LCALL   ?UL_SHR
   \   000730   85....       MOV     ?V0 + 0,?V0 + 4
   \   000733   F5..         MOV     ?V0 + 1,A
   \   000735   F5..         MOV     ?V0 + 2,A
   \   000737   F5..         MOV     ?V0 + 3,A
   \   000739   78..         MOV     R0,#?V0 + 8
   \   00073B   79..         MOV     R1,#?V0 + 0
   \   00073D   12....       LCALL   ?UL_DIV_MOD
   \   000740   740D         MOV     A,#0xd
   \   000742   12....       LCALL   ?XSTACK_DISP0_8
   \   000745   E0           MOVX    A,@DPTR
   \   000746   F8           MOV     R0,A
   \   000747   A3           INC     DPTR
   \   000748   E0           MOVX    A,@DPTR
   \   000749   F583         MOV     DPH,A
   \   00074B   8882         MOV     DPL,R0
   \   00074D   78..         MOV     R0,#?V0 + 8
   \   00074F   12....       LCALL   ?L_MOV_TO_X
   2138              accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
   2139                  packet_count);
   \   000752   7411         MOV     A,#0x11
   \   000754   12....       LCALL   ?XSTACK_DISP0_8
   \   000757   E0           MOVX    A,@DPTR
   \   000758   F8           MOV     R0,A
   \   000759   A3           INC     DPTR
   \   00075A   E0           MOVX    A,@DPTR
   \   00075B   F583         MOV     DPH,A
   \   00075D   8882         MOV     DPL,R0
   \   00075F   78..         MOV     R0,#?V0 + 8
   \   000761   12....       LCALL   ?L_MOV_X
   \   000764   7410         MOV     A,#0x10
   \   000766   78..         MOV     R0,#?V0 + 8
   \   000768   12....       LCALL   ?L_SHL
   \   00076B   740B         MOV     A,#0xb
   \   00076D   78..         MOV     R0,#?V0 + 8
   \   00076F   12....       LCALL   ?UL_SHR
   \   000772   85....       MOV     ?V0 + 0,?V0 + 4
   \   000775   F5..         MOV     ?V0 + 1,A
   \   000777   F5..         MOV     ?V0 + 2,A
   \   000779   F5..         MOV     ?V0 + 3,A
   \   00077B   78..         MOV     R0,#?V0 + 8
   \   00077D   79..         MOV     R1,#?V0 + 0
   \   00077F   12....       LCALL   ?UL_DIV_MOD
   \   000782   7411         MOV     A,#0x11
   \   000784   12....       LCALL   ?XSTACK_DISP0_8
   \   000787   E0           MOVX    A,@DPTR
   \   000788   F8           MOV     R0,A
   \   000789   A3           INC     DPTR
   \   00078A   E0           MOVX    A,@DPTR
   \   00078B   F583         MOV     DPH,A
   \   00078D   8882         MOV     DPL,R0
   \   00078F   78..         MOV     R0,#?V0 + 8
   \   000791   12....       LCALL   ?L_MOV_TO_X
   2140              accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
   2141                  packet_count);
   \   000794   8E82         MOV     DPL,R6
   \   000796   8F83         MOV     DPH,R7
   \   000798   78..         MOV     R0,#?V0 + 0
   \   00079A   12....       LCALL   ?L_MOV_X
   \   00079D   7410         MOV     A,#0x10
   \   00079F   78..         MOV     R0,#?V0 + 0
   \   0007A1   12....       LCALL   ?L_SHL
   \   0007A4   740B         MOV     A,#0xb
   \   0007A6   78..         MOV     R0,#?V0 + 0
   \   0007A8   12....       LCALL   ?UL_SHR
   \   0007AB   78..         MOV     R0,#?V0 + 0
   \   0007AD   79..         MOV     R1,#?V0 + 4
   \   0007AF   12....       LCALL   ?UL_DIV_MOD
   \   0007B2   8E82         MOV     DPL,R6
   \   0007B4   8F83         MOV     DPH,R7
   \   0007B6   78..         MOV     R0,#?V0 + 0
   \   0007B8   12....       LCALL   ?L_MOV_TO_X
   2142              /* Don't remove gravity! */
   2143              if (accel[2] > 0L)
   \   0007BB   8E82         MOV     DPL,R6
   \   0007BD   8F83         MOV     DPH,R7
   \   0007BF   C082         PUSH    DPL
   \   0007C1   C083         PUSH    DPH
   \   0007C3   90....       MOV     DPTR,#__Constant_1
   \   0007C6   78..         MOV     R0,#?V0 + 0
   \   0007C8   12....       LCALL   ?L_MOV_X
   \   0007CB   D083         POP     DPH
   \   0007CD   D082         POP     DPL
   \   0007CF   78..         MOV     R0,#?V0 + 0
   \   0007D1   12....       LCALL   ?SL_GT_X
   \   0007D4   4005         JC      ??get_st_biases_10
   2144                  accel[2] -= 65536L;
   \   0007D6   90....       MOV     DPTR,#__Constant_ffff0000
   \   0007D9   8003         SJMP    ??get_st_biases_11
   2145              else
   2146                  accel[2] += 65536L;
   \                     ??get_st_biases_10:
   \   0007DB   90....       MOV     DPTR,#__Constant_10000
   \                     ??get_st_biases_11:
   \   0007DE   78..         MOV     R0,#?V0 + 0
   \   0007E0   12....       LCALL   ?L_MOV_X
   \   0007E3   8E82         MOV     DPL,R6
   \   0007E5   8F83         MOV     DPH,R7
   \   0007E7   78..         MOV     R0,#?V0 + 0
   \   0007E9   12....       LCALL   ?L_ADD_TO_X
   2147          #endif
   2148          
   2149              return 0;
   \   0007EC   7A00         MOV     R2,#0x0
   \   0007EE   7B00         MOV     R3,#0x0
   \                     ??get_st_biases_2:
   \   0007F0   741F         MOV     A,#0x1f
   \   0007F2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0007F5   7F10         MOV     R7,#0x10
   \   0007F7   02....       LJMP    ?BANKED_LEAVE_XDATA
   2150          }
   2151          
   2152          /**
   2153           *  @brief      Trigger gyro/accel/compass self-test.
   2154           *  On success/error, the self-test returns a mask representing the sensor(s)
   2155           *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
   2156           *  a zero (0) indicates a failure.
   2157           *
   2158           *  \n The mask is defined as follows:
   2159           *  \n Bit 0:   Gyro.
   2160           *  \n Bit 1:   Accel.
   2161           *  \n Bit 2:   Compass.
   2162           *
   2163           *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
   2164           *  this function can still be used to obtain the accel and gyro biases.
   2165           *
   2166           *  \n This function must be called with the device either face-up or face-down
   2167           *  (z-axis is parallel to gravity).
   2168           *  @param[out] gyro        Gyro biases in q16 format.
   2169           *  @param[out] accel       Accel biases (if applicable) in q16 format.
   2170           *  @return     Result mask (see above).
   2171           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2172          int mpu_run_self_test(long *gyro, long *accel)
   \                     mpu_run_self_test:
   2173          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   2174          #ifdef MPU6050
   2175              const unsigned char tries = 2;
   2176              long gyro_st[3], accel_st[3];
   2177              unsigned char accel_result, gyro_result;
   2178          #ifdef AK89xx_SECONDARY
   2179              unsigned char compass_result;
   2180          #endif
   2181              int ii;
   2182          #endif
   2183              int result;
   2184              unsigned char accel_fsr, fifo_sensors, sensors_on;
   2185              unsigned short gyro_fsr, sample_rate, lpf;
   2186              unsigned char dmp_was_on;
   2187          
   2188              if (st.chip_cfg.dmp_on) {
   \   000012   90....       MOV     DPTR,#st + 29
   \   000015   E0           MOVX    A,@DPTR
   \   000016   600A         JZ      ??mpu_run_self_test_0
   2189                  mpu_set_dmp_state(0);
   \   000018                ; Setup parameters for call to function mpu_set_dmp_state
   \   000018   7900         MOV     R1,#0x0
   \   00001A   12....       LCALL   ??mpu_set_dmp_state?relay
   2190                  dmp_was_on = 1;
   \   00001D   75..01       MOV     ?V0 + 0,#0x1
   \   000020   8003         SJMP    ??mpu_run_self_test_1
   2191              } else
   2192                  dmp_was_on = 0;
   \                     ??mpu_run_self_test_0:
   \   000022   75..00       MOV     ?V0 + 0,#0x0
   2193          
   2194              /* Get initial settings. */
   2195              mpu_get_gyro_fsr(&gyro_fsr);
   \                     ??mpu_run_self_test_1:
   \   000025                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000025   7406         MOV     A,#0x6
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   AA82         MOV     R2,DPL
   \   00002C   AB83         MOV     R3,DPH
   \   00002E   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2196              mpu_get_accel_fsr(&accel_fsr);
   \   000031                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000031   7401         MOV     A,#0x1
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   12....       LCALL   ??mpu_get_accel_fsr?relay
   2197              mpu_get_lpf(&lpf);
   \   00003D                ; Setup parameters for call to function mpu_get_lpf
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   AA82         MOV     R2,DPL
   \   000044   AB83         MOV     R3,DPH
   \   000046   12....       LCALL   ??mpu_get_lpf?relay
   2198              mpu_get_sample_rate(&sample_rate);
   \   000049                ; Setup parameters for call to function mpu_get_sample_rate
   \   000049   7404         MOV     A,#0x4
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   AA82         MOV     R2,DPL
   \   000050   AB83         MOV     R3,DPH
   \   000052   12....       LCALL   ??mpu_get_sample_rate?relay
   2199              sensors_on = st.chip_cfg.sensors;
   \   000055   90....       MOV     DPTR,#st + 6
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5..         MOV     ?V0 + 1,A
   2200              mpu_get_fifo_config(&fifo_sensors);
   \   00005B                ; Setup parameters for call to function mpu_get_fifo_config
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   ??mpu_get_fifo_config?relay
   2201          
   2202              /* For older chips, the self-test will be different. */
   2203          #if defined MPU6050
   2204              for (ii = 0; ii < tries; ii++)
   \   000068   7E00         MOV     R6,#0x0
   \   00006A   7F00         MOV     R7,#0x0
   \   00006C   8008         SJMP    ??mpu_run_self_test_2
   \                     ??mpu_run_self_test_3:
   \   00006E   EE           MOV     A,R6
   \   00006F   2401         ADD     A,#0x1
   \   000071   0E           INC     R6
   \   000072   EF           MOV     A,R7
   \   000073   3400         ADDC    A,#0x0
   \   000075   FF           MOV     R7,A
   \                     ??mpu_run_self_test_2:
   \   000076   C3           CLR     C
   \   000077   EE           MOV     A,R6
   \   000078   9402         SUBB    A,#0x2
   \   00007A   EF           MOV     A,R7
   \   00007B   9400         SUBB    A,#0x0
   \   00007D   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00007F   65D0         XRL     A,PSW
   \   000081   33           RLC     A
   \   000082   5014         JNC     ??mpu_run_self_test_4
   2205                  if (!get_st_biases(gyro, accel, 0))
   \   000084                ; Setup parameters for call to function get_st_biases
   \   000084   7900         MOV     R1,#0x0
   \   000086   AC..         MOV     R4,?V0 + 2
   \   000088   AD..         MOV     R5,?V0 + 3
   \   00008A   AA..         MOV     R2,?V0 + 4
   \   00008C   AB..         MOV     R3,?V0 + 5
   \   00008E   12....       LCALL   ??get_st_biases?relay
   \   000091   8B..         MOV     ?V0 + 7,R3
   \   000093   EA           MOV     A,R2
   \   000094   45..         ORL     A,?V0 + 7
   \   000096   70D6         JNZ     ??mpu_run_self_test_3
   2206                      break;
   2207              if (ii == tries) {
   \                     ??mpu_run_self_test_4:
   \   000098   7402         MOV     A,#0x2
   \   00009A   6E           XRL     A,R6
   \   00009B   7001         JNZ     ??mpu_run_self_test_5
   \   00009D   EF           MOV     A,R7
   \                     ??mpu_run_self_test_5:
   \   00009E   7004         JNZ     ??mpu_run_self_test_6
   2208                  /* If we reach this point, we most likely encountered an I2C error.
   2209                   * We'll just report an error for all three sensors.
   2210                   */
   2211                  result = 0;
   \                     ??mpu_run_self_test_7:
   \   0000A0   7E00         MOV     R6,#0x0
   2212                  goto restore;
   \   0000A2   8073         SJMP    ??mpu_run_self_test_8
   2213              }
   2214              for (ii = 0; ii < tries; ii++)
   \                     ??mpu_run_self_test_6:
   \   0000A4   7E00         MOV     R6,#0x0
   \   0000A6   7F00         MOV     R7,#0x0
   \   0000A8   8008         SJMP    ??mpu_run_self_test_9
   \                     ??mpu_run_self_test_10:
   \   0000AA   EE           MOV     A,R6
   \   0000AB   2401         ADD     A,#0x1
   \   0000AD   0E           INC     R6
   \   0000AE   EF           MOV     A,R7
   \   0000AF   3400         ADDC    A,#0x0
   \   0000B1   FF           MOV     R7,A
   \                     ??mpu_run_self_test_9:
   \   0000B2   C3           CLR     C
   \   0000B3   EE           MOV     A,R6
   \   0000B4   9402         SUBB    A,#0x2
   \   0000B6   EF           MOV     A,R7
   \   0000B7   9400         SUBB    A,#0x0
   \   0000B9   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000BB   65D0         XRL     A,PSW
   \   0000BD   33           RLC     A
   \   0000BE   501E         JNC     ??mpu_run_self_test_11
   2215                  if (!get_st_biases(gyro_st, accel_st, 1))
   \   0000C0                ; Setup parameters for call to function get_st_biases
   \   0000C0   7901         MOV     R1,#0x1
   \   0000C2   7408         MOV     A,#0x8
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   AC82         MOV     R4,DPL
   \   0000C9   AD83         MOV     R5,DPH
   \   0000CB   7414         MOV     A,#0x14
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   AA82         MOV     R2,DPL
   \   0000D2   AB83         MOV     R3,DPH
   \   0000D4   12....       LCALL   ??get_st_biases?relay
   \   0000D7   8B..         MOV     ?V0 + 7,R3
   \   0000D9   EA           MOV     A,R2
   \   0000DA   45..         ORL     A,?V0 + 7
   \   0000DC   70CC         JNZ     ??mpu_run_self_test_10
   2216                      break;
   2217              if (ii == tries) {
   \                     ??mpu_run_self_test_11:
   \   0000DE   7402         MOV     A,#0x2
   \   0000E0   6E           XRL     A,R6
   \   0000E1   7001         JNZ     ??mpu_run_self_test_12
   \   0000E3   EF           MOV     A,R7
   \                     ??mpu_run_self_test_12:
   \   0000E4   60BA         JZ      ??mpu_run_self_test_7
   2218                  /* Again, probably an I2C error. */
   2219                  result = 0;
   2220                  goto restore;
   2221              }
   2222              accel_result = accel_self_test(accel, accel_st);
   \   0000E6                ; Setup parameters for call to function accel_self_test
   \   0000E6   7408         MOV     A,#0x8
   \   0000E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EB   AC82         MOV     R4,DPL
   \   0000ED   AD83         MOV     R5,DPH
   \   0000EF   AA..         MOV     R2,?V0 + 2
   \   0000F1   AB..         MOV     R3,?V0 + 3
   \   0000F3   12....       LCALL   ??accel_self_test?relay
   \   0000F6   EA           MOV     A,R2
   \   0000F7   F5..         MOV     ?V0 + 2,A
   2223              gyro_result = gyro_self_test(gyro, gyro_st);
   \   0000F9                ; Setup parameters for call to function gyro_self_test
   \   0000F9   7414         MOV     A,#0x14
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   AC82         MOV     R4,DPL
   \   000100   AD83         MOV     R5,DPH
   \   000102   AA..         MOV     R2,?V0 + 4
   \   000104   AB..         MOV     R3,?V0 + 5
   \   000106   12....       LCALL   ??gyro_self_test?relay
   \   000109   EA           MOV     A,R2
   2224          
   2225              result = 0;
   \   00010A   7E00         MOV     R6,#0x0
   2226              if (!gyro_result)
   \   00010C   7001         JNZ     ??mpu_run_self_test_13
   2227                  result |= 0x01;
   \   00010E   0E           INC     R6
   2228              if (!accel_result)
   \                     ??mpu_run_self_test_13:
   \   00010F   E5..         MOV     A,?V0 + 2
   \   000111   7004         JNZ     ??mpu_run_self_test_8
   2229                  result |= 0x02;
   \   000113   7402         MOV     A,#0x2
   \   000115   4E           ORL     A,R6
   \   000116   FE           MOV     R6,A
   2230          
   2231          #ifdef AK89xx_SECONDARY
   2232              compass_result = compass_self_test();
   2233              if (!compass_result)
   2234                  result |= 0x04;
   2235          #endif
   2236          restore:
   2237          #elif defined MPU6500
   2238              /* For now, this function will return a "pass" result for all three sensors
   2239               * for compatibility with current test applications.
   2240               */
   2241              get_st_biases(gyro, accel, 0);
   2242              result = 0x7;
   2243          #endif
   2244              /* Set to invalid values to ensure no I2C writes are skipped. */
   2245              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_run_self_test_8:
   \   000117   90....       MOV     DPTR,#st + 4
   \   00011A   74FF         MOV     A,#-0x1
   \   00011C   F0           MOVX    @DPTR,A
   2246              st.chip_cfg.accel_fsr = 0xFF;
   \   00011D   A3           INC     DPTR
   \   00011E   F0           MOVX    @DPTR,A
   2247              st.chip_cfg.lpf = 0xFF;
   \   00011F   90....       MOV     DPTR,#st + 7
   \   000122   F0           MOVX    @DPTR,A
   2248              st.chip_cfg.sample_rate = 0xFFFF;
   \   000123   90....       MOV     DPTR,#st + 9
   \   000126   F0           MOVX    @DPTR,A
   \   000127   A3           INC     DPTR
   \   000128   F0           MOVX    @DPTR,A
   2249              st.chip_cfg.sensors = 0xFF;
   \   000129   90....       MOV     DPTR,#st + 6
   \   00012C   F0           MOVX    @DPTR,A
   2250              st.chip_cfg.fifo_enable = 0xFF;
   \   00012D   90....       MOV     DPTR,#st + 11
   \   000130   F0           MOVX    @DPTR,A
   2251              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   000131   90....       MOV     DPTR,#st + 8
   \   000134   7401         MOV     A,#0x1
   \   000136   F0           MOVX    @DPTR,A
   2252              mpu_set_gyro_fsr(gyro_fsr);
   \   000137                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   000137   7406         MOV     A,#0x6
   \   000139   12....       LCALL   ?XSTACK_DISP0_8
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   FA           MOV     R2,A
   \   00013E   A3           INC     DPTR
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   FB           MOV     R3,A
   \   000141   12....       LCALL   ??mpu_set_gyro_fsr?relay
   2253              mpu_set_accel_fsr(accel_fsr);
   \   000144                ; Setup parameters for call to function mpu_set_accel_fsr
   \   000144   7401         MOV     A,#0x1
   \   000146   12....       LCALL   ?XSTACK_DISP0_8
   \   000149   E0           MOVX    A,@DPTR
   \   00014A   F9           MOV     R1,A
   \   00014B   12....       LCALL   ??mpu_set_accel_fsr?relay
   2254              mpu_set_lpf(lpf);
   \   00014E                ; Setup parameters for call to function mpu_set_lpf
   \   00014E   7402         MOV     A,#0x2
   \   000150   12....       LCALL   ?XSTACK_DISP0_8
   \   000153   E0           MOVX    A,@DPTR
   \   000154   FA           MOV     R2,A
   \   000155   A3           INC     DPTR
   \   000156   E0           MOVX    A,@DPTR
   \   000157   FB           MOV     R3,A
   \   000158   12....       LCALL   ??mpu_set_lpf?relay
   2255              mpu_set_sample_rate(sample_rate);
   \   00015B                ; Setup parameters for call to function mpu_set_sample_rate
   \   00015B   7404         MOV     A,#0x4
   \   00015D   12....       LCALL   ?XSTACK_DISP0_8
   \   000160   E0           MOVX    A,@DPTR
   \   000161   FA           MOV     R2,A
   \   000162   A3           INC     DPTR
   \   000163   E0           MOVX    A,@DPTR
   \   000164   FB           MOV     R3,A
   \   000165   12....       LCALL   ??mpu_set_sample_rate?relay
   2256              mpu_set_sensors(sensors_on);
   \   000168                ; Setup parameters for call to function mpu_set_sensors
   \   000168   A9..         MOV     R1,?V0 + 1
   \   00016A   12....       LCALL   ??mpu_set_sensors?relay
   2257              mpu_configure_fifo(fifo_sensors);
   \   00016D                ; Setup parameters for call to function mpu_configure_fifo
   \   00016D   85..82       MOV     DPL,?XSP + 0
   \   000170   85..83       MOV     DPH,?XSP + 1
   \   000173   E0           MOVX    A,@DPTR
   \   000174   F9           MOV     R1,A
   \   000175   12....       LCALL   ??mpu_configure_fifo?relay
   2258          
   2259              if (dmp_was_on)
   \   000178   E5..         MOV     A,?V0 + 0
   \   00017A   6005         JZ      ??mpu_run_self_test_14
   2260                  mpu_set_dmp_state(1);
   \   00017C                ; Setup parameters for call to function mpu_set_dmp_state
   \   00017C   7901         MOV     R1,#0x1
   \   00017E   12....       LCALL   ??mpu_set_dmp_state?relay
   2261          
   2262              return result;
   \                     ??mpu_run_self_test_14:
   \   000181   EE           MOV     A,R6
   \   000182   FA           MOV     R2,A
   \   000183   7B00         MOV     R3,#0x0
   \   000185   7420         MOV     A,#0x20
   \   000187   12....       LCALL   ?DEALLOC_XSTACK8
   \   00018A   7F08         MOV     R7,#0x8
   \   00018C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2263          }
   2264          
   2265          /**
   2266           *  @brief      Write to the DMP memory.
   2267           *  This function prevents I2C writes past the bank boundaries. The DMP memory
   2268           *  is only accessible when the chip is awake.
   2269           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2270           *  @param[in]  length      Number of bytes to write.
   2271           *  @param[in]  data        Bytes to write to memory.
   2272           *  @return     0 if successful.
   2273           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2274          int mpu_write_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_write_mem:
   2275                  unsigned char *data)
   2276          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740E         MOV     A,#0xe
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   2277              unsigned char tmp[2];
   2278          
   2279              if (!data)
   \   00001A   E5..         MOV     A,?V0 + 0
   \   00001C   45..         ORL     A,?V0 + 1
   \   00001E   7007         JNZ     ??mpu_write_mem_0
   2280                  return -1;
   \                     ??mpu_write_mem_1:
   \   000020   7AFF         MOV     R2,#-0x1
   \   000022   7BFF         MOV     R3,#-0x1
   \   000024   02....       LJMP    ??mpu_write_mem_2 & 0xFFFF
   2281              if (!st.chip_cfg.sensors)
   \                     ??mpu_write_mem_0:
   \   000027   90....       MOV     DPTR,#st + 6
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   60F3         JZ      ??mpu_write_mem_1
   2282                  return -1;
   2283          
   2284              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   00002D   EB           MOV     A,R3
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   F0           MOVX    @DPTR,A
   2285              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   000035   EA           MOV     A,R2
   \   000036   C0E0         PUSH    A
   \   000038   7401         MOV     A,#0x1
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   D0E0         POP     A
   \   00003F   F0           MOVX    @DPTR,A
   2286          
   2287              /* Check bank boundaries. */
   2288              if (tmp[1] + length > st.hw->bank_size)
   \   000040   90....       MOV     DPTR,#st + 2
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F8           MOV     R0,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   8983         MOV     DPH,R1
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   C082         PUSH    DPL
   \   000056   C083         PUSH    DPH
   \   000058   7401         MOV     A,#0x1
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2E           ADD     A,R6
   \   00005F   FA           MOV     R2,A
   \   000060   E4           CLR     A
   \   000061   3F           ADDC    A,R7
   \   000062   FB           MOV     R3,A
   \   000063   D083         POP     DPH
   \   000065   D082         POP     DPL
   \   000067   C3           CLR     C
   \   000068   E0           MOVX    A,@DPTR
   \   000069   9A           SUBB    A,R2
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   9B           SUBB    A,R3
   \   00006D   40B1         JC      ??mpu_write_mem_1
   2289                  return -1;
   2290          
   2291              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   00006F                ; Setup parameters for call to function MPU_Write_Len
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   AC82         MOV     R4,DPL
   \   000077   AD83         MOV     R5,DPH
   \   000079   7B02         MOV     R3,#0x2
   \   00007B   90....       MOV     DPTR,#st
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   2418         ADD     A,#0x18
   \   000081   F5..         MOV     ?V0 + 2,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   3400         ADDC    A,#0x0
   \   000087   85..82       MOV     DPL,?V0 + 2
   \   00008A   F583         MOV     DPH,A
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   FA           MOV     R2,A
   \   00008E   8882         MOV     DPL,R0
   \   000090   8983         MOV     DPH,R1
   \   000092   E0           MOVX    A,@DPTR
   \   000093   F9           MOV     R1,A
   \   000094   12....       LCALL   ??MPU_Write_Len?relay
   \   000097   E9           MOV     A,R1
   \   000098   7086         JNZ     ??mpu_write_mem_1
   2292                  return -1;
   2293              if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
   \   00009A                ; Setup parameters for call to function MPU_Write_Len
   \   00009A   AC..         MOV     R4,?V0 + 0
   \   00009C   AD..         MOV     R5,?V0 + 1
   \   00009E   EE           MOV     A,R6
   \   00009F   FB           MOV     R3,A
   \   0000A0   90....       MOV     DPTR,#st
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   2415         ADD     A,#0x15
   \   0000A6   F8           MOV     R0,A
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   3400         ADDC    A,#0x0
   \   0000AB   F9           MOV     R1,A
   \   0000AC   8882         MOV     DPL,R0
   \   0000AE   8983         MOV     DPH,R1
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   FA           MOV     R2,A
   \   0000B2   90....       MOV     DPTR,#st + 2
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   F8           MOV     R0,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F583         MOV     DPH,A
   \   0000BB   8882         MOV     DPL,R0
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   F9           MOV     R1,A
   \   0000BF   12....       LCALL   ??MPU_Write_Len?relay
   \   0000C2   E9           MOV     A,R1
   \   0000C3   6003         JZ      $+5
   \   0000C5   02....       LJMP    ??mpu_write_mem_1 & 0xFFFF
   2294                  return -1;
   2295              return 0;
   \   0000C8   7A00         MOV     R2,#0x0
   \   0000CA   7B00         MOV     R3,#0x0
   \                     ??mpu_write_mem_2:
   \   0000CC   7402         MOV     A,#0x2
   \   0000CE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D1   7F04         MOV     R7,#0x4
   \   0000D3   02....       LJMP    ?BANKED_LEAVE_XDATA
   2296          }
   2297          
   2298          /**
   2299           *  @brief      Read from the DMP memory.
   2300           *  This function prevents I2C reads past the bank boundaries. The DMP memory
   2301           *  is only accessible when the chip is awake.
   2302           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2303           *  @param[in]  length      Number of bytes to read.
   2304           *  @param[out] data        Bytes read from memory.
   2305           *  @return     0 if successful.
   2306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2307          int mpu_read_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_read_mem:
   2308                  unsigned char *data)
   2309          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740E         MOV     A,#0xe
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   2310              unsigned char tmp[2];
   2311          
   2312              if (!data)
   \   00001A   E5..         MOV     A,?V0 + 0
   \   00001C   45..         ORL     A,?V0 + 1
   \   00001E   7007         JNZ     ??mpu_read_mem_0
   2313                  return -1;
   \                     ??mpu_read_mem_1:
   \   000020   7AFF         MOV     R2,#-0x1
   \   000022   7BFF         MOV     R3,#-0x1
   \   000024   02....       LJMP    ??mpu_read_mem_2 & 0xFFFF
   2314              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_mem_0:
   \   000027   90....       MOV     DPTR,#st + 6
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   60F3         JZ      ??mpu_read_mem_1
   2315                  return -1;
   2316          
   2317              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   00002D   EB           MOV     A,R3
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   F0           MOVX    @DPTR,A
   2318              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   000035   EA           MOV     A,R2
   \   000036   C0E0         PUSH    A
   \   000038   7401         MOV     A,#0x1
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   D0E0         POP     A
   \   00003F   F0           MOVX    @DPTR,A
   2319          
   2320              /* Check bank boundaries. */
   2321              if (tmp[1] + length > st.hw->bank_size)
   \   000040   90....       MOV     DPTR,#st + 2
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F8           MOV     R0,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   8983         MOV     DPH,R1
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   C082         PUSH    DPL
   \   000056   C083         PUSH    DPH
   \   000058   7401         MOV     A,#0x1
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2E           ADD     A,R6
   \   00005F   FA           MOV     R2,A
   \   000060   E4           CLR     A
   \   000061   3F           ADDC    A,R7
   \   000062   FB           MOV     R3,A
   \   000063   D083         POP     DPH
   \   000065   D082         POP     DPL
   \   000067   C3           CLR     C
   \   000068   E0           MOVX    A,@DPTR
   \   000069   9A           SUBB    A,R2
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   9B           SUBB    A,R3
   \   00006D   40B1         JC      ??mpu_read_mem_1
   2322                  return -1;
   2323          
   2324              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   00006F                ; Setup parameters for call to function MPU_Write_Len
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   AC82         MOV     R4,DPL
   \   000077   AD83         MOV     R5,DPH
   \   000079   7B02         MOV     R3,#0x2
   \   00007B   90....       MOV     DPTR,#st
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   2418         ADD     A,#0x18
   \   000081   F5..         MOV     ?V0 + 2,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   3400         ADDC    A,#0x0
   \   000087   85..82       MOV     DPL,?V0 + 2
   \   00008A   F583         MOV     DPH,A
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   FA           MOV     R2,A
   \   00008E   8882         MOV     DPL,R0
   \   000090   8983         MOV     DPH,R1
   \   000092   E0           MOVX    A,@DPTR
   \   000093   F9           MOV     R1,A
   \   000094   12....       LCALL   ??MPU_Write_Len?relay
   \   000097   E9           MOV     A,R1
   \   000098   7086         JNZ     ??mpu_read_mem_1
   2325                  return -1;
   2326              if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
   \   00009A                ; Setup parameters for call to function MPU_Read_Len
   \   00009A   AC..         MOV     R4,?V0 + 0
   \   00009C   AD..         MOV     R5,?V0 + 1
   \   00009E   EE           MOV     A,R6
   \   00009F   FB           MOV     R3,A
   \   0000A0   90....       MOV     DPTR,#st
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   2415         ADD     A,#0x15
   \   0000A6   F8           MOV     R0,A
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   3400         ADDC    A,#0x0
   \   0000AB   F9           MOV     R1,A
   \   0000AC   8882         MOV     DPL,R0
   \   0000AE   8983         MOV     DPH,R1
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   FA           MOV     R2,A
   \   0000B2   90....       MOV     DPTR,#st + 2
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   F8           MOV     R0,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F583         MOV     DPH,A
   \   0000BB   8882         MOV     DPL,R0
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   F9           MOV     R1,A
   \   0000BF   12....       LCALL   ??MPU_Read_Len?relay
   \   0000C2   E9           MOV     A,R1
   \   0000C3   6003         JZ      $+5
   \   0000C5   02....       LJMP    ??mpu_read_mem_1 & 0xFFFF
   2327                  return -1;
   2328              return 0;
   \   0000C8   7A00         MOV     R2,#0x0
   \   0000CA   7B00         MOV     R3,#0x0
   \                     ??mpu_read_mem_2:
   \   0000CC   7402         MOV     A,#0x2
   \   0000CE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D1   7F04         MOV     R7,#0x4
   \   0000D3   02....       LJMP    ?BANKED_LEAVE_XDATA
   2329          }
   2330          
   2331          /**
   2332           *  @brief      Load and verify DMP image.
   2333           *  @param[in]  length      Length of DMP image.
   2334           *  @param[in]  firmware    DMP code.
   2335           *  @param[in]  start_addr  Starting address of DMP code memory.
   2336           *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
   2337           *  @return     0 if successful.
   2338           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2339          int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
   \                     mpu_load_firmware:
   2340              unsigned short start_addr, unsigned short sample_rate)
   2341          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   \   000012   7428         MOV     A,#0x28
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
   \   00001E   742A         MOV     A,#0x2a
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 6,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F5..         MOV     ?V0 + 7,A
   2342              unsigned short ii;
   2343              unsigned short this_write;
   2344              /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
   2345          #define LOAD_CHUNK  (16)
   2346              unsigned char cur[LOAD_CHUNK], tmp[2];
   2347          
   2348              if (st.chip_cfg.dmp_loaded)
   \   00002A   90....       MOV     DPTR,#st + 30
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6007         JZ      ??mpu_load_firmware_0
   2349                  /* DMP should only be loaded once. */
   2350                  return -1;
   \                     ??mpu_load_firmware_1:
   \   000030   7AFF         MOV     R2,#-0x1
   \                     ??mpu_load_firmware_2:
   \   000032   7BFF         MOV     R3,#-0x1
   \   000034   02....       LJMP    ??mpu_load_firmware_3 & 0xFFFF
   2351          
   2352              if (!firmware)
   \                     ??mpu_load_firmware_0:
   \   000037   EC           MOV     A,R4
   \   000038   45..         ORL     A,?V0 + 5
   \   00003A   60F4         JZ      ??mpu_load_firmware_1
   2353                  return -1;
   2354              for (ii = 0; ii < length; ii += this_write) {
   \   00003C   7E00         MOV     R6,#0x0
   \   00003E   7F00         MOV     R7,#0x0
   \   000040   8008         SJMP    ??mpu_load_firmware_4
   \                     ??mpu_load_firmware_5:
   \   000042   EE           MOV     A,R6
   \   000043   25..         ADD     A,?V0 + 10
   \   000045   FE           MOV     R6,A
   \   000046   EF           MOV     A,R7
   \   000047   35..         ADDC    A,?V0 + 11
   \   000049   FF           MOV     R7,A
   \                     ??mpu_load_firmware_4:
   \   00004A   C3           CLR     C
   \   00004B   EE           MOV     A,R6
   \   00004C   95..         SUBB    A,?V0 + 2
   \   00004E   EF           MOV     A,R7
   \   00004F   95..         SUBB    A,?V0 + 3
   \   000051   4003         JC      $+5
   \   000053   02....       LJMP    ??mpu_load_firmware_6 & 0xFFFF
   2355                  this_write = min(LOAD_CHUNK, length - ii);
   \   000056   E5..         MOV     A,?V0 + 2
   \   000058   C3           CLR     C
   \   000059   9E           SUBB    A,R6
   \   00005A   F8           MOV     R0,A
   \   00005B   E5..         MOV     A,?V0 + 3
   \   00005D   9F           SUBB    A,R7
   \   00005E   F9           MOV     R1,A
   \   00005F   C3           CLR     C
   \   000060   E8           MOV     A,R0
   \   000061   9411         SUBB    A,#0x11
   \   000063   E9           MOV     A,R1
   \   000064   9400         SUBB    A,#0x0
   \   000066   4008         JC      ??mpu_load_firmware_7
   \   000068   75..10       MOV     ?V0 + 10,#0x10
   \   00006B   75..00       MOV     ?V0 + 11,#0x0
   \   00006E   8004         SJMP    ??mpu_load_firmware_8
   \                     ??mpu_load_firmware_7:
   \   000070   88..         MOV     ?V0 + 10,R0
   \   000072   89..         MOV     ?V0 + 11,R1
   2356                  if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
   \                     ??mpu_load_firmware_8:
   \   000074   E5..         MOV     A,?V0 + 4
   \   000076   2E           ADD     A,R6
   \   000077   F5..         MOV     ?V0 + 12,A
   \   000079   E5..         MOV     A,?V0 + 5
   \   00007B   3F           ADDC    A,R7
   \   00007C   F5..         MOV     ?V0 + 13,A
   \   00007E                ; Setup parameters for call to function mpu_write_mem
   \   00007E   78..         MOV     R0,#?V0 + 12
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000083   AC..         MOV     R4,?V0 + 10
   \   000085   AD..         MOV     R5,?V0 + 11
   \   000087   EE           MOV     A,R6
   \   000088   FA           MOV     R2,A
   \   000089   EF           MOV     A,R7
   \   00008A   FB           MOV     R3,A
   \   00008B   12....       LCALL   ??mpu_write_mem?relay
   \   00008E   7402         MOV     A,#0x2
   \   000090   12....       LCALL   ?DEALLOC_XSTACK8
   \   000093   8B..         MOV     ?V0 + 9,R3
   \   000095   EA           MOV     A,R2
   \   000096   45..         ORL     A,?V0 + 9
   \   000098   7096         JNZ     ??mpu_load_firmware_1
   2357                      return -1;
   2358                  if (mpu_read_mem(ii, this_write, cur))
   \   00009A                ; Setup parameters for call to function mpu_read_mem
   \   00009A   7402         MOV     A,#0x2
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   8582..       MOV     ?V0 + 8,DPL
   \   0000A2   8583..       MOV     ?V0 + 9,DPH
   \   0000A5   78..         MOV     R0,#?V0 + 8
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AA   AC..         MOV     R4,?V0 + 10
   \   0000AC   AD..         MOV     R5,?V0 + 11
   \   0000AE   EE           MOV     A,R6
   \   0000AF   FA           MOV     R2,A
   \   0000B0   EF           MOV     A,R7
   \   0000B1   FB           MOV     R3,A
   \   0000B2   12....       LCALL   ??mpu_read_mem?relay
   \   0000B5   7402         MOV     A,#0x2
   \   0000B7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BA   8B..         MOV     ?V0 + 9,R3
   \   0000BC   EA           MOV     A,R2
   \   0000BD   45..         ORL     A,?V0 + 9
   \   0000BF   6003         JZ      $+5
   \   0000C1   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2359                      return -1;
   2360                  if (memcmp(firmware+ii, cur, this_write))
   \   0000C4                ; Setup parameters for call to function memcmp
   \   0000C4   78..         MOV     R0,#?V0 + 10
   \   0000C6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C9   7404         MOV     A,#0x4
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   AC82         MOV     R4,DPL
   \   0000D0   AD83         MOV     R5,DPH
   \   0000D2   AA..         MOV     R2,?V0 + 12
   \   0000D4   AB..         MOV     R3,?V0 + 13
   \   0000D6   12....       LCALL   ??memcmp?relay
   \   0000D9   7402         MOV     A,#0x2
   \   0000DB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DE   8B..         MOV     ?V0 + 9,R3
   \   0000E0   EA           MOV     A,R2
   \   0000E1   45..         ORL     A,?V0 + 9
   \   0000E3   7003         JNZ     $+5
   \   0000E5   02....       LJMP    ??mpu_load_firmware_5 & 0xFFFF
   2361                      return -2;
   \   0000E8   7AFE         MOV     R2,#-0x2
   \   0000EA   02....       LJMP    ??mpu_load_firmware_2 & 0xFFFF
   2362              }
   2363          
   2364              /* Set program start address. */
   2365              tmp[0] = start_addr >> 8;
   \                     ??mpu_load_firmware_6:
   \   0000ED   85..82       MOV     DPL,?XSP + 0
   \   0000F0   85..83       MOV     DPH,?XSP + 1
   \   0000F3   E5..         MOV     A,?V0 + 1
   \   0000F5   F0           MOVX    @DPTR,A
   2366              tmp[1] = start_addr & 0xFF;
   \   0000F6   7401         MOV     A,#0x1
   \   0000F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FB   E5..         MOV     A,?V0 + 0
   \   0000FD   F0           MOVX    @DPTR,A
   2367              if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
   \   0000FE                ; Setup parameters for call to function MPU_Write_Len
   \   0000FE   85..82       MOV     DPL,?XSP + 0
   \   000101   85..83       MOV     DPH,?XSP + 1
   \   000104   AC82         MOV     R4,DPL
   \   000106   AD83         MOV     R5,DPH
   \   000108   7B02         MOV     R3,#0x2
   \   00010A   90....       MOV     DPTR,#st
   \   00010D   E0           MOVX    A,@DPTR
   \   00010E   241A         ADD     A,#0x1a
   \   000110   F8           MOV     R0,A
   \   000111   A3           INC     DPTR
   \   000112   E0           MOVX    A,@DPTR
   \   000113   3400         ADDC    A,#0x0
   \   000115   F9           MOV     R1,A
   \   000116   8882         MOV     DPL,R0
   \   000118   8983         MOV     DPH,R1
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   FA           MOV     R2,A
   \   00011C   90....       MOV     DPTR,#st + 2
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   F8           MOV     R0,A
   \   000121   A3           INC     DPTR
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F583         MOV     DPH,A
   \   000125   8882         MOV     DPL,R0
   \   000127   E0           MOVX    A,@DPTR
   \   000128   F9           MOV     R1,A
   \   000129   12....       LCALL   ??MPU_Write_Len?relay
   \   00012C   E9           MOV     A,R1
   \   00012D   6003         JZ      $+5
   \   00012F   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2368                  return -1;
   2369          
   2370              st.chip_cfg.dmp_loaded = 1;
   \   000132   90....       MOV     DPTR,#st + 30
   \   000135   7401         MOV     A,#0x1
   \   000137   F0           MOVX    @DPTR,A
   2371              st.chip_cfg.dmp_sample_rate = sample_rate;
   \   000138   A3           INC     DPTR
   \   000139   E5..         MOV     A,?V0 + 6
   \   00013B   F0           MOVX    @DPTR,A
   \   00013C   A3           INC     DPTR
   \   00013D   E5..         MOV     A,?V0 + 7
   \   00013F   F0           MOVX    @DPTR,A
   2372              return 0;
   \   000140   7A00         MOV     R2,#0x0
   \   000142   7B00         MOV     R3,#0x0
   \                     ??mpu_load_firmware_3:
   \   000144   7412         MOV     A,#0x12
   \   000146   12....       LCALL   ?DEALLOC_XSTACK8
   \   000149   7F0E         MOV     R7,#0xe
   \   00014B   02....       LJMP    ?BANKED_LEAVE_XDATA
   2373          }
   2374          
   2375          /**
   2376           *  @brief      Enable/disable DMP support.
   2377           *  @param[in]  enable  1 to turn on the DMP.
   2378           *  @return     0 if successful.
   2379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2380          int mpu_set_dmp_state(unsigned char enable)
   \                     mpu_set_dmp_state:
   2381          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2382              unsigned char tmp;
   2383              if (st.chip_cfg.dmp_on == enable)
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   700E         JNZ     ??mpu_set_dmp_state_0
   2384                  return 0;
   \                     ??mpu_set_dmp_state_1:
   \   000013   7A00         MOV     R2,#0x0
   \   000015   7B00         MOV     R3,#0x0
   \                     ??mpu_set_dmp_state_2:
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001C   7F01         MOV     R7,#0x1
   \   00001E   02....       LJMP    ?BANKED_LEAVE_XDATA
   2385          
   2386              if (enable) {
   \                     ??mpu_set_dmp_state_0:
   \   000021   EE           MOV     A,R6
   \   000022   604E         JZ      ??mpu_set_dmp_state_3
   2387                  if (!st.chip_cfg.dmp_loaded)
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   7006         JNZ     ??mpu_set_dmp_state_4
   2388                      return -1;
   \   000028   7AFF         MOV     R2,#-0x1
   \   00002A   7BFF         MOV     R3,#-0x1
   \   00002C   80E9         SJMP    ??mpu_set_dmp_state_2
   2389                  /* Disable data ready interrupt. */
   2390                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_4:
   \   00002E                ; Setup parameters for call to function set_int_enable
   \   00002E   7900         MOV     R1,#0x0
   \   000030   12....       LCALL   ??set_int_enable?relay
   2391                  /* Disable bypass mode. */
   2392                  mpu_set_bypass(0);
   \   000033                ; Setup parameters for call to function mpu_set_bypass
   \   000033   7900         MOV     R1,#0x0
   \   000035   12....       LCALL   ??mpu_set_bypass?relay
   2393                  /* Keep constant sample rate, FIFO rate controlled by DMP. */
   2394                  mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
   \   000038                ; Setup parameters for call to function mpu_set_sample_rate
   \   000038   90....       MOV     DPTR,#st + 31
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FA           MOV     R2,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FB           MOV     R3,A
   \   000040   12....       LCALL   ??mpu_set_sample_rate?relay
   2395                  /* Remove FIFO elements. */
   2396                  tmp = 0;
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   E4           CLR     A
   \   00004A   F0           MOVX    @DPTR,A
   2397                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   \   00004B                ; Setup parameters for call to function MPU_Write_Len
   \   00004B   AC82         MOV     R4,DPL
   \   00004D   AD83         MOV     R5,DPH
   \   00004F   7B01         MOV     R3,#0x1
   \   000051   7A23         MOV     R2,#0x23
   \   000053   90....       MOV     DPTR,#st + 2
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F8           MOV     R0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F583         MOV     DPH,A
   \   00005C   8882         MOV     DPL,R0
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   12....       LCALL   ??MPU_Write_Len?relay
   2398                  st.chip_cfg.dmp_on = 1;
   \   000063   90....       MOV     DPTR,#st + 29
   \   000066   7401         MOV     A,#0x1
   \   000068   F0           MOVX    @DPTR,A
   2399                  /* Enable DMP interrupt. */
   2400                  set_int_enable(1);
   \   000069                ; Setup parameters for call to function set_int_enable
   \   000069   F9           MOV     R1,A
   \   00006A   12....       LCALL   ??set_int_enable?relay
   2401                  mpu_reset_fifo();
   \   00006D                ; Setup parameters for call to function mpu_reset_fifo
   \                     ??mpu_set_dmp_state_5:
   \   00006D   12....       LCALL   ??mpu_reset_fifo?relay
   \   000070   80A1         SJMP    ??mpu_set_dmp_state_1
   2402              } else {
   2403                  /* Disable DMP interrupt. */
   2404                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_3:
   \   000072                ; Setup parameters for call to function set_int_enable
   \   000072   7900         MOV     R1,#0x0
   \   000074   12....       LCALL   ??set_int_enable?relay
   2405                  /* Restore FIFO settings. */
   2406                  tmp = st.chip_cfg.fifo_enable;
   \   000077   90....       MOV     DPTR,#st + 11
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   F0           MOVX    @DPTR,A
   2407                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   \   000082                ; Setup parameters for call to function MPU_Write_Len
   \   000082   AC82         MOV     R4,DPL
   \   000084   AD83         MOV     R5,DPH
   \   000086   7B01         MOV     R3,#0x1
   \   000088   7A23         MOV     R2,#0x23
   \   00008A   90....       MOV     DPTR,#st + 2
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   F8           MOV     R0,A
   \   00008F   A3           INC     DPTR
   \   000090   E0           MOVX    A,@DPTR
   \   000091   F583         MOV     DPH,A
   \   000093   8882         MOV     DPL,R0
   \   000095   E0           MOVX    A,@DPTR
   \   000096   F9           MOV     R1,A
   \   000097   12....       LCALL   ??MPU_Write_Len?relay
   2408                  st.chip_cfg.dmp_on = 0;
   \   00009A   90....       MOV     DPTR,#st + 29
   \   00009D   E4           CLR     A
   \   00009E   F0           MOVX    @DPTR,A
   2409                  mpu_reset_fifo();
   \   00009F                ; Setup parameters for call to function mpu_reset_fifo
   \   00009F   80CC         SJMP    ??mpu_set_dmp_state_5
   2410              }
   2411              return 0;
   2412          }
   2413          
   2414          /**
   2415           *  @brief      Get DMP state.
   2416           *  @param[out] enabled 1 if enabled.
   2417           *  @return     0 if successful.
   2418           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2419          int mpu_get_dmp_state(unsigned char *enabled)
   \                     mpu_get_dmp_state:
   2420          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2421              enabled[0] = st.chip_cfg.dmp_on;
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   E0           MOVX    A,@DPTR
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   F0           MOVX    @DPTR,A
   2422              return 0;
   \   00000D   7A00         MOV     R2,#0x0
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   D083         POP     DPH
   \   000013   D082         POP     DPL
   \   000015   02....       LJMP    ?BRET
   2423          }
   2424          
   2425          
   2426          /* This initialization is similar to the one in ak8975.c. */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2427          int setup_compass(void)
   \                     setup_compass:
   2428          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2429          #ifdef AK89xx_SECONDARY
   2430              unsigned char data[4], akm_addr;
   2431          
   2432              mpu_set_bypass(1);
   2433          
   2434              /* Find compass. Possible addresses range from 0x0C to 0x0F. */
   2435              for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
   2436                  int result;
   2437                  result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
   2438                  if (!result && (data[0] == AKM_WHOAMI))
   2439                      break;
   2440              }
   2441          
   2442              if (akm_addr > 0x0F) {
   2443                  /* TODO: Handle this case in all compass-related functions. */
   2444                  log_e("Compass not found.\n");
   2445                  return -1;
   2446              }
   2447          
   2448              st.chip_cfg.compass_addr = akm_addr;
   2449          
   2450              data[0] = AKM_POWER_DOWN;
   2451              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2452                  return -1;
   2453              delay_ms(1);
   2454          
   2455              data[0] = AKM_FUSE_ROM_ACCESS;
   2456              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2457                  return -1;
   2458              delay_ms(1);
   2459          
   2460              /* Get sensitivity adjustment data from fuse ROM. */
   2461              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
   2462                  return -1;
   2463              st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
   2464              st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
   2465              st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
   2466          
   2467              data[0] = AKM_POWER_DOWN;
   2468              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2469                  return -1;
   2470              delay_ms(1);
   2471          
   2472              mpu_set_bypass(0);
   2473          
   2474              /* Set up master mode, master clock, and ES bit. */
   2475              data[0] = 0x40;
   2476              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   2477                  return -1;
   2478          
   2479              /* Slave 0 reads from AKM data registers. */
   2480              data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
   2481              if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
   2482                  return -1;
   2483          
   2484              /* Compass reads start at this register. */
   2485              data[0] = AKM_REG_ST1;
   2486              if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
   2487                  return -1;
   2488          
   2489              /* Enable slave 0, 8-byte reads. */
   2490              data[0] = BIT_SLAVE_EN | 8;
   2491              if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
   2492                  return -1;
   2493          
   2494              /* Slave 1 changes AKM measurement mode. */
   2495              data[0] = st.chip_cfg.compass_addr;
   2496              if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
   2497                  return -1;
   2498          
   2499              /* AKM measurement mode register. */
   2500              data[0] = AKM_REG_CNTL;
   2501              if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
   2502                  return -1;
   2503          
   2504              /* Enable slave 1, 1-byte writes. */
   2505              data[0] = BIT_SLAVE_EN | 1;
   2506              if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
   2507                  return -1;
   2508          
   2509              /* Set slave 1 data. */
   2510              data[0] = AKM_SINGLE_MEASUREMENT;
   2511              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
   2512                  return -1;
   2513          
   2514              /* Trigger slave 0 and slave 1 actions at each sample. */
   2515              data[0] = 0x03;
   2516              if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
   2517                  return -1;
   2518          
   2519          #ifdef MPU9150
   2520              /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
   2521              data[0] = BIT_I2C_MST_VDDIO;
   2522              if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
   2523                  return -1;
   2524          #endif
   2525          
   2526              return 0;
   2527          #else
   2528              return -1;
   \   000000   7AFF         MOV     R2,#-0x1
   \   000002   7BFF         MOV     R3,#-0x1
   \   000004   02....       LJMP    ?BRET
   2529          #endif
   2530          }
   2531          
   2532          /**
   2533           *  @brief      Read raw compass data.
   2534           *  @param[out] data        Raw data in hardware units.
   2535           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   2536           *  @return     0 if successful.
   2537           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2538          int mpu_get_compass_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_compass_reg:
   2539          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2540          #ifdef AK89xx_SECONDARY
   2541              unsigned char tmp[9];
   2542          
   2543              if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   2544                  return -1;
   2545          
   2546          #ifdef AK89xx_BYPASS
   2547              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
   2548                  return -1;
   2549              tmp[8] = AKM_SINGLE_MEASUREMENT;
   2550              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
   2551                  return -1;
   2552          #else
   2553              if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
   2554                  return -1;
   2555          #endif
   2556          
   2557          #if defined AK8975_SECONDARY
   2558              /* AK8975 doesn't have the overrun error bit. */
   2559              if (!(tmp[0] & AKM_DATA_READY))
   2560                  return -2;
   2561              if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
   2562                  return -3;
   2563          #elif defined AK8963_SECONDARY
   2564              /* AK8963 doesn't have the data read error bit. */
   2565              if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
   2566                  return -2;
   2567              if (tmp[7] & AKM_OVERFLOW)
   2568                  return -3;
   2569          #endif
   2570              data[0] = (tmp[2] << 8) | tmp[1];
   2571              data[1] = (tmp[4] << 8) | tmp[3];
   2572              data[2] = (tmp[6] << 8) | tmp[5];
   2573          
   2574              data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
   2575              data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
   2576              data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
   2577          
   2578              if (timestamp)
   2579                  get_ms(timestamp);
   2580              return 0;
   2581          #else
   2582              return -1;
   \   000000   7AFF         MOV     R2,#-0x1
   \   000002   7BFF         MOV     R3,#-0x1
   \   000004   02....       LJMP    ?BRET
   2583          #endif
   2584          }
   2585          
   2586          /**
   2587           *  @brief      Get the compass full-scale range.
   2588           *  @param[out] fsr Current full-scale range.
   2589           *  @return     0 if successful.
   2590           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2591          int mpu_get_compass_fsr(unsigned short *fsr)
   \                     mpu_get_compass_fsr:
   2592          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2593          #ifdef AK89xx_SECONDARY
   2594              fsr[0] = st.hw->compass_fsr;
   2595              return 0;
   2596          #else
   2597              return -1;
   \   000000   7AFF         MOV     R2,#-0x1
   \   000002   7BFF         MOV     R3,#-0x1
   \   000004   02....       LJMP    ?BRET
   2598          #endif
   2599          }
   2600          
   2601          /**
   2602           *  @brief      Enters LP accel motion interrupt mode.
   2603           *  The behavior of this feature is very different between the MPU6050 and the
   2604           *  MPU6500. Each chip's version of this feature is explained below.
   2605           *
   2606           *  \n MPU6050:
   2607           *  \n When this mode is first enabled, the hardware captures a single accel
   2608           *  sample, and subsequent samples are compared with this one to determine if
   2609           *  the device is in motion. Therefore, whenever this "locked" sample needs to
   2610           *  be changed, this function must be called again.
   2611           *
   2612           *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
   2613           *  increments.
   2614           *
   2615           *  \n Low-power accel mode supports the following frequencies:
   2616           *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
   2617           *
   2618           *  \n MPU6500:
   2619           *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
   2620           *  sample. The hardware monitors the accel data and detects any large change
   2621           *  over a short period of time.
   2622           *
   2623           *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
   2624           *  increments.
   2625           *
   2626           *  \n MPU6500 Low-power accel mode supports the following frequencies:
   2627           *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
   2628           *
   2629           *  \n\n NOTES:
   2630           *  \n The driver will round down @e thresh to the nearest supported value if
   2631           *  an unsupported threshold is selected.
   2632           *  \n To select a fractional wake-up frequency, round down the value passed to
   2633           *  @e lpa_freq.
   2634           *  \n The MPU6500 does not support a delay parameter. If this function is used
   2635           *  for the MPU6500, the value passed to @e time will be ignored.
   2636           *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
   2637           *  the previous configuration.
   2638           *
   2639           *  @param[in]  thresh      Motion threshold in mg.
   2640           *  @param[in]  time        Duration in milliseconds that the accel data must
   2641           *                          exceed @e thresh before motion is reported.
   2642           *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
   2643           *  @return     0 if successful.
   2644           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2645          int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
   \                     mpu_lp_motion_interrupt:
   2646              unsigned char lpa_freq)
   2647          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
   2648              unsigned char data[3];
   2649          
   2650              if (lpa_freq) {
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??mpu_lp_motion_interrupt_0 & 0xFFFF
   2651                  unsigned char thresh_hw;
   2652          
   2653          #if defined MPU6050
   2654                  /* TODO: Make these const/#defines. */
   2655                  /* 1LSb = 32mg. */
   2656                  if (thresh > 8160)
   \   000013   C3           CLR     C
   \   000014   EA           MOV     A,R2
   \   000015   94E1         SUBB    A,#-0x1f
   \   000017   EB           MOV     A,R3
   \   000018   941F         SUBB    A,#0x1f
   \   00001A   4005         JC      ??mpu_lp_motion_interrupt_1
   2657                      thresh_hw = 255;
   \   00001C   75..FF       MOV     ?V0 + 0,#-0x1
   \   00001F   8019         SJMP    ??mpu_lp_motion_interrupt_2
   2658                  else if (thresh < 32)
   \                     ??mpu_lp_motion_interrupt_1:
   \   000021   C3           CLR     C
   \   000022   EA           MOV     A,R2
   \   000023   9420         SUBB    A,#0x20
   \   000025   EB           MOV     A,R3
   \   000026   9400         SUBB    A,#0x0
   \   000028   5005         JNC     ??mpu_lp_motion_interrupt_3
   2659                      thresh_hw = 1;
   \   00002A   75..01       MOV     ?V0 + 0,#0x1
   \   00002D   800B         SJMP    ??mpu_lp_motion_interrupt_2
   2660                  else
   2661                      thresh_hw = thresh >> 5;
   \                     ??mpu_lp_motion_interrupt_3:
   \   00002F   8A..         MOV     ?V0 + 0,R2
   \   000031   8B..         MOV     ?V0 + 1,R3
   \   000033   7405         MOV     A,#0x5
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?US_SHR
   2662          #elif defined MPU6500
   2663                  /* 1LSb = 4mg. */
   2664                  if (thresh > 1020)
   2665                      thresh_hw = 255;
   2666                  else if (thresh < 4)
   2667                      thresh_hw = 1;
   2668                  else
   2669                      thresh_hw = thresh >> 2;
   2670          #endif
   2671          
   2672                  if (!time)
   \                     ??mpu_lp_motion_interrupt_2:
   \   00003A   EF           MOV     A,R7
   \   00003B   7002         JNZ     ??mpu_lp_motion_interrupt_4
   2673                      /* Minimum duration must be 1ms. */
   2674                      time = 1;
   \   00003D   7F01         MOV     R7,#0x1
   2675          
   2676          #if defined MPU6050
   2677                  if (lpa_freq > 40)
   \                     ??mpu_lp_motion_interrupt_4:
   \   00003F   EE           MOV     A,R6
   \   000040   C3           CLR     C
   \   000041   9429         SUBB    A,#0x29
   \   000043   4007         JC      ??mpu_lp_motion_interrupt_5
   2678          #elif defined MPU6500
   2679                  if (lpa_freq > 640)
   2680          #endif
   2681                      /* At this point, the chip has not been re-configured, so the
   2682                       * function can safely exit.
   2683                       */
   2684                      return -1;
   \                     ??mpu_lp_motion_interrupt_6:
   \   000045   7AFF         MOV     R2,#-0x1
   \   000047   7BFF         MOV     R3,#-0x1
   \   000049   02....       LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
   2685          
   2686                  if (!st.chip_cfg.int_motion_only) {
   \                     ??mpu_lp_motion_interrupt_5:
   \   00004C   90....       MOV     DPTR,#st + 16
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   7042         JNZ     ??mpu_lp_motion_interrupt_8
   2687                      /* Store current settings for later. */
   2688                      if (st.chip_cfg.dmp_on) {
   \   000052   90....       MOV     DPTR,#st + 29
   \   000055   E0           MOVX    A,@DPTR
   \   000056   600C         JZ      ??mpu_lp_motion_interrupt_9
   2689                          mpu_set_dmp_state(0);
   \   000058                ; Setup parameters for call to function mpu_set_dmp_state
   \   000058   7900         MOV     R1,#0x0
   \   00005A   12....       LCALL   ??mpu_set_dmp_state?relay
   2690                          st.chip_cfg.cache.dmp_on = 1;
   \   00005D   90....       MOV     DPTR,#st + 26
   \   000060   7401         MOV     A,#0x1
   \   000062   8004         SJMP    ??mpu_lp_motion_interrupt_10
   2691                      } else
   2692                          st.chip_cfg.cache.dmp_on = 0;
   \                     ??mpu_lp_motion_interrupt_9:
   \   000064   90....       MOV     DPTR,#st + 26
   \   000067   E4           CLR     A
   \                     ??mpu_lp_motion_interrupt_10:
   \   000068   F0           MOVX    @DPTR,A
   2693                      mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
   \   000069                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000069   7A..         MOV     R2,#(st + 17) & 0xff
   \   00006B   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   00006D   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2694                      mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
   \   000070                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000070   7A..         MOV     R2,#(st + 19) & 0xff
   \   000072   7B..         MOV     R3,#((st + 19) >> 8) & 0xff
   \   000074   12....       LCALL   ??mpu_get_accel_fsr?relay
   2695                      mpu_get_lpf(&st.chip_cfg.cache.lpf);
   \   000077                ; Setup parameters for call to function mpu_get_lpf
   \   000077   7A..         MOV     R2,#(st + 20) & 0xff
   \   000079   7B..         MOV     R3,#((st + 20) >> 8) & 0xff
   \   00007B   12....       LCALL   ??mpu_get_lpf?relay
   2696                      mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
   \   00007E                ; Setup parameters for call to function mpu_get_sample_rate
   \   00007E   7A..         MOV     R2,#(st + 22) & 0xff
   \   000080   7B..         MOV     R3,#((st + 22) >> 8) & 0xff
   \   000082   12....       LCALL   ??mpu_get_sample_rate?relay
   2697                      st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
   \   000085   90....       MOV     DPTR,#st + 6
   \   000088   E0           MOVX    A,@DPTR
   \   000089   90....       MOV     DPTR,#st + 24
   \   00008C   F0           MOVX    @DPTR,A
   2698                      mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
   \   00008D                ; Setup parameters for call to function mpu_get_fifo_config
   \   00008D   7A..         MOV     R2,#(st + 25) & 0xff
   \   00008F   7B..         MOV     R3,#((st + 25) >> 8) & 0xff
   \   000091   12....       LCALL   ??mpu_get_fifo_config?relay
   2699                  }
   2700          
   2701          #ifdef MPU6050
   2702                  /* Disable hardware interrupts for now. */
   2703                  set_int_enable(0);
   \                     ??mpu_lp_motion_interrupt_8:
   \   000094                ; Setup parameters for call to function set_int_enable
   \   000094   7900         MOV     R1,#0x0
   \   000096   12....       LCALL   ??set_int_enable?relay
   2704          
   2705                  /* Enter full-power accel-only mode. */
   2706                  mpu_lp_accel_mode(0);
   \   000099                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000099   7900         MOV     R1,#0x0
   \   00009B   12....       LCALL   ??mpu_lp_accel_mode?relay
   2707          
   2708                  /* Override current LPF (and HPF) settings to obtain a valid accel
   2709                   * reading.
   2710                   */
   2711                  data[0] = INV_FILTER_256HZ_NOLPF2;
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   E4           CLR     A
   \   0000A5   F0           MOVX    @DPTR,A
   2712                  if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \   0000A6                ; Setup parameters for call to function MPU_Write_Len
   \   0000A6   AC82         MOV     R4,DPL
   \   0000A8   AD83         MOV     R5,DPH
   \   0000AA   7B01         MOV     R3,#0x1
   \   0000AC   90....       MOV     DPTR,#st
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   F8           MOV     R0,A
   \   0000B1   A3           INC     DPTR
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   8882         MOV     DPL,R0
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   FA           MOV     R2,A
   \   0000BB   90....       MOV     DPTR,#st + 2
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F8           MOV     R0,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F583         MOV     DPH,A
   \   0000C4   8882         MOV     DPL,R0
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F9           MOV     R1,A
   \   0000C8   12....       LCALL   ??MPU_Write_Len?relay
   \   0000CB   E9           MOV     A,R1
   \   0000CC   6003         JZ      $+5
   \   0000CE   02....       LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
   2713                      return -1;
   2714          
   2715                  /* NOTE: Digital high pass filter should be configured here. Since this
   2716                   * driver doesn't modify those bits anywhere, they should already be
   2717                   * cleared by default.
   2718                   */
   2719          
   2720                  /* Configure the device to send motion interrupts. */
   2721                  /* Enable motion interrupt. */
   2722                  data[0] = BIT_MOT_INT_EN;
   \   0000D1   85..82       MOV     DPL,?XSP + 0
   \   0000D4   85..83       MOV     DPH,?XSP + 1
   \   0000D7   7440         MOV     A,#0x40
   \   0000D9   F0           MOVX    @DPTR,A
   2723                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \   0000DA                ; Setup parameters for call to function MPU_Write_Len
   \   0000DA   AC82         MOV     R4,DPL
   \   0000DC   AD83         MOV     R5,DPH
   \   0000DE   7B01         MOV     R3,#0x1
   \   0000E0   90....       MOV     DPTR,#st
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   240F         ADD     A,#0xf
   \   0000E6   F8           MOV     R0,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   3400         ADDC    A,#0x0
   \   0000EB   F9           MOV     R1,A
   \   0000EC   8882         MOV     DPL,R0
   \   0000EE   8983         MOV     DPH,R1
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   FA           MOV     R2,A
   \   0000F2   90....       MOV     DPTR,#st + 2
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   F8           MOV     R0,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   F583         MOV     DPH,A
   \   0000FB   8882         MOV     DPL,R0
   \   0000FD   E0           MOVX    A,@DPTR
   \   0000FE   F9           MOV     R1,A
   \   0000FF   12....       LCALL   ??MPU_Write_Len?relay
   \   000102   E9           MOV     A,R1
   \   000103   6003         JZ      $+5
   \   000105   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2724                      goto lp_int_restore;
   2725          
   2726                  /* Set motion interrupt parameters. */
   2727                  data[0] = thresh_hw;
   \   000108   85..82       MOV     DPL,?XSP + 0
   \   00010B   85..83       MOV     DPH,?XSP + 1
   \   00010E   E5..         MOV     A,?V0 + 0
   \   000110   F0           MOVX    @DPTR,A
   2728                  data[1] = time;
   \   000111   EF           MOV     A,R7
   \   000112   C0E0         PUSH    A
   \   000114   7401         MOV     A,#0x1
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   D0E0         POP     A
   \   00011B   F0           MOVX    @DPTR,A
   2729                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
   \   00011C                ; Setup parameters for call to function MPU_Write_Len
   \   00011C   85..82       MOV     DPL,?XSP + 0
   \   00011F   85..83       MOV     DPH,?XSP + 1
   \   000122   AC82         MOV     R4,DPL
   \   000124   AD83         MOV     R5,DPH
   \   000126   7B02         MOV     R3,#0x2
   \   000128   90....       MOV     DPTR,#st
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   F8           MOV     R0,A
   \   00012D   A3           INC     DPTR
   \   00012E   E0           MOVX    A,@DPTR
   \   00012F   F583         MOV     DPH,A
   \   000131   8882         MOV     DPL,R0
   \   000133   A3           INC     DPTR
   \   000134   A3           INC     DPTR
   \   000135   A3           INC     DPTR
   \   000136   A3           INC     DPTR
   \   000137   A3           INC     DPTR
   \   000138   A3           INC     DPTR
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   FA           MOV     R2,A
   \   00013D   90....       MOV     DPTR,#st + 2
   \   000140   E0           MOVX    A,@DPTR
   \   000141   F8           MOV     R0,A
   \   000142   A3           INC     DPTR
   \   000143   E0           MOVX    A,@DPTR
   \   000144   F583         MOV     DPH,A
   \   000146   8882         MOV     DPL,R0
   \   000148   E0           MOVX    A,@DPTR
   \   000149   F9           MOV     R1,A
   \   00014A   12....       LCALL   ??MPU_Write_Len?relay
   \   00014D   E9           MOV     A,R1
   \   00014E   6003         JZ      $+5
   \   000150   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2730                      goto lp_int_restore;
   2731          
   2732                  /* Force hardware to "lock" current accel sample. */
   2733                  delay_ms(5);
   \   000153                ; Setup parameters for call to function delay_ms
   \   000153   90....       MOV     DPTR,#__Constant_5
   \   000156   12....       LCALL   ?XLOAD_R2345
   \   000159   12....       LCALL   ??delay_ms?relay
   2734                  data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
   \   00015C   90....       MOV     DPTR,#st + 5
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   33           RLC     A
   \   000161   33           RLC     A
   \   000162   33           RLC     A
   \   000163   54F8         ANL     A,#0xf8
   \   000165   4407         ORL     A,#0x7
   \   000167   85..82       MOV     DPL,?XSP + 0
   \   00016A   85..83       MOV     DPH,?XSP + 1
   \   00016D   F0           MOVX    @DPTR,A
   2735                  if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \   00016E                ; Setup parameters for call to function MPU_Write_Len
   \   00016E   AC82         MOV     R4,DPL
   \   000170   AD83         MOV     R5,DPH
   \   000172   7B01         MOV     R3,#0x1
   \   000174   90....       MOV     DPTR,#st
   \   000177   E0           MOVX    A,@DPTR
   \   000178   F8           MOV     R0,A
   \   000179   A3           INC     DPTR
   \   00017A   E0           MOVX    A,@DPTR
   \   00017B   F583         MOV     DPH,A
   \   00017D   8882         MOV     DPL,R0
   \   00017F   A3           INC     DPTR
   \   000180   A3           INC     DPTR
   \   000181   A3           INC     DPTR
   \   000182   A3           INC     DPTR
   \   000183   A3           INC     DPTR
   \   000184   A3           INC     DPTR
   \   000185   A3           INC     DPTR
   \   000186   E0           MOVX    A,@DPTR
   \   000187   FA           MOV     R2,A
   \   000188   90....       MOV     DPTR,#st + 2
   \   00018B   E0           MOVX    A,@DPTR
   \   00018C   F8           MOV     R0,A
   \   00018D   A3           INC     DPTR
   \   00018E   E0           MOVX    A,@DPTR
   \   00018F   F583         MOV     DPH,A
   \   000191   8882         MOV     DPL,R0
   \   000193   E0           MOVX    A,@DPTR
   \   000194   F9           MOV     R1,A
   \   000195   12....       LCALL   ??MPU_Write_Len?relay
   \   000198   E9           MOV     A,R1
   \   000199   6003         JZ      $+5
   \   00019B   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2736                      goto lp_int_restore;
   2737          
   2738                  /* Set up LP accel mode. */
   2739                  data[0] = BIT_LPA_CYCLE;
   \   00019E   85..82       MOV     DPL,?XSP + 0
   \   0001A1   85..83       MOV     DPH,?XSP + 1
   \   0001A4   7420         MOV     A,#0x20
   \   0001A6   F0           MOVX    @DPTR,A
   2740                  if (lpa_freq == 1)
   \   0001A7   7401         MOV     A,#0x1
   \   0001A9   6E           XRL     A,R6
   \   0001AA   7008         JNZ     ??mpu_lp_motion_interrupt_12
   2741                      data[1] = INV_LPA_1_25HZ;
   \   0001AC   7401         MOV     A,#0x1
   \   0001AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B1   E4           CLR     A
   \   0001B2   8023         SJMP    ??mpu_lp_motion_interrupt_13
   2742                  else if (lpa_freq <= 5)
   \                     ??mpu_lp_motion_interrupt_12:
   \   0001B4   EE           MOV     A,R6
   \   0001B5   C3           CLR     C
   \   0001B6   9406         SUBB    A,#0x6
   \   0001B8   5009         JNC     ??mpu_lp_motion_interrupt_14
   2743                      data[1] = INV_LPA_5HZ;
   \   0001BA   7401         MOV     A,#0x1
   \   0001BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BF   7401         MOV     A,#0x1
   \   0001C1   8014         SJMP    ??mpu_lp_motion_interrupt_13
   2744                  else if (lpa_freq <= 20)
   \                     ??mpu_lp_motion_interrupt_14:
   \   0001C3   EE           MOV     A,R6
   \   0001C4   C3           CLR     C
   \   0001C5   9415         SUBB    A,#0x15
   \   0001C7   7401         MOV     A,#0x1
   \   0001C9   5007         JNC     ??mpu_lp_motion_interrupt_15
   2745                      data[1] = INV_LPA_20HZ;
   \   0001CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CE   7402         MOV     A,#0x2
   \   0001D0   8005         SJMP    ??mpu_lp_motion_interrupt_13
   2746                  else
   2747                      data[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_motion_interrupt_15:
   \   0001D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D5   7403         MOV     A,#0x3
   \                     ??mpu_lp_motion_interrupt_13:
   \   0001D7   F0           MOVX    @DPTR,A
   2748                  data[1] = (data[1] << 6) | BIT_STBY_XYZG;
   \   0001D8   7401         MOV     A,#0x1
   \   0001DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DD   E0           MOVX    A,@DPTR
   \   0001DE   C4           SWAP    A
   \   0001DF   33           RLC     A
   \   0001E0   33           RLC     A
   \   0001E1   54C0         ANL     A,#0xc0
   \   0001E3   4407         ORL     A,#0x7
   \   0001E5   F0           MOVX    @DPTR,A
   2749                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \   0001E6                ; Setup parameters for call to function MPU_Write_Len
   \   0001E6   85..82       MOV     DPL,?XSP + 0
   \   0001E9   85..83       MOV     DPH,?XSP + 1
   \   0001EC   AC82         MOV     R4,DPL
   \   0001EE   AD83         MOV     R5,DPH
   \   0001F0   7B02         MOV     R3,#0x2
   \   0001F2   90....       MOV     DPTR,#st
   \   0001F5   E0           MOVX    A,@DPTR
   \   0001F6   2412         ADD     A,#0x12
   \   0001F8   F8           MOV     R0,A
   \   0001F9   A3           INC     DPTR
   \   0001FA   E0           MOVX    A,@DPTR
   \   0001FB   3400         ADDC    A,#0x0
   \   0001FD   F9           MOV     R1,A
   \   0001FE   8882         MOV     DPL,R0
   \   000200   8983         MOV     DPH,R1
   \   000202   E0           MOVX    A,@DPTR
   \   000203   FA           MOV     R2,A
   \   000204   90....       MOV     DPTR,#st + 2
   \   000207   E0           MOVX    A,@DPTR
   \   000208   F8           MOV     R0,A
   \   000209   A3           INC     DPTR
   \   00020A   E0           MOVX    A,@DPTR
   \   00020B   F583         MOV     DPH,A
   \   00020D   8882         MOV     DPL,R0
   \   00020F   E0           MOVX    A,@DPTR
   \   000210   F9           MOV     R1,A
   \   000211   12....       LCALL   ??MPU_Write_Len?relay
   \   000214   E9           MOV     A,R1
   \   000215   7034         JNZ     ??mpu_lp_motion_interrupt_11
   2750                      goto lp_int_restore;
   2751          
   2752                  st.chip_cfg.int_motion_only = 1;
   \   000217   90....       MOV     DPTR,#st + 16
   \   00021A   7401         MOV     A,#0x1
   \   00021C   F0           MOVX    @DPTR,A
   2753                  return 0;
   \   00021D   7A00         MOV     R2,#0x0
   \   00021F   7B00         MOV     R3,#0x0
   \   000221   02....       LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
   2754          #elif defined MPU6500
   2755                  /* Disable hardware interrupts. */
   2756                  set_int_enable(0);
   2757          
   2758                  /* Enter full-power accel-only mode, no FIFO/DMP. */
   2759                  data[0] = 0;
   2760                  data[1] = 0;
   2761                  data[2] = BIT_STBY_XYZG;
   2762                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
   2763                      goto lp_int_restore;
   2764          
   2765                  /* Set motion threshold. */
   2766                  data[0] = thresh_hw;
   2767                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
   2768                      goto lp_int_restore;
   2769          
   2770                  /* Set wake frequency. */
   2771                  if (lpa_freq == 1)
   2772                      data[0] = INV_LPA_1_25HZ;
   2773                  else if (lpa_freq == 2)
   2774                      data[0] = INV_LPA_2_5HZ;
   2775                  else if (lpa_freq <= 5)
   2776                      data[0] = INV_LPA_5HZ;
   2777                  else if (lpa_freq <= 10)
   2778                      data[0] = INV_LPA_10HZ;
   2779                  else if (lpa_freq <= 20)
   2780                      data[0] = INV_LPA_20HZ;
   2781                  else if (lpa_freq <= 40)
   2782                      data[0] = INV_LPA_40HZ;
   2783                  else if (lpa_freq <= 80)
   2784                      data[0] = INV_LPA_80HZ;
   2785                  else if (lpa_freq <= 160)
   2786                      data[0] = INV_LPA_160HZ;
   2787                  else if (lpa_freq <= 320)
   2788                      data[0] = INV_LPA_320HZ;
   2789                  else
   2790                      data[0] = INV_LPA_640HZ;
   2791                  if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
   2792                      goto lp_int_restore;
   2793          
   2794                  /* Enable motion interrupt (MPU6500 version). */
   2795                  data[0] = BITS_WOM_EN;
   2796                  if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2797                      goto lp_int_restore;
   2798          
   2799                  /* Enable cycle mode. */
   2800                  data[0] = BIT_LPA_CYCLE;
   2801                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   2802                      goto lp_int_restore;
   2803          
   2804                  /* Enable interrupt. */
   2805                  data[0] = BIT_MOT_INT_EN;
   2806                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   2807                      goto lp_int_restore;
   2808          
   2809                  st.chip_cfg.int_motion_only = 1;
   2810                  return 0;
   2811          #endif
   2812              } else {
   2813                  /* Don't "restore" the previous state if no state has been saved. */
   2814                  int ii;
   2815                  char *cache_ptr = (char*)&st.chip_cfg.cache;
   2816                  for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
   \                     ??mpu_lp_motion_interrupt_0:
   \   000224   7800         MOV     R0,#0x0
   \   000226   7900         MOV     R1,#0x0
   \   000228   8008         SJMP    ??mpu_lp_motion_interrupt_16
   \                     ??mpu_lp_motion_interrupt_17:
   \   00022A   E8           MOV     A,R0
   \   00022B   2401         ADD     A,#0x1
   \   00022D   08           INC     R0
   \   00022E   E9           MOV     A,R1
   \   00022F   3400         ADDC    A,#0x0
   \   000231   F9           MOV     R1,A
   \                     ??mpu_lp_motion_interrupt_16:
   \   000232   C3           CLR     C
   \   000233   E8           MOV     A,R0
   \   000234   940A         SUBB    A,#0xa
   \   000236   E9           MOV     A,R1
   \   000237   9400         SUBB    A,#0x0
   \   000239   4003         JC      $+5
   \   00023B   02....       LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
   2817                      if (cache_ptr[ii] != 0)
   \   00023E   74..         MOV     A,#(st + 17) & 0xff
   \   000240   28           ADD     A,R0
   \   000241   F582         MOV     DPL,A
   \   000243   74..         MOV     A,#((st + 17) >> 8) & 0xff
   \   000245   39           ADDC    A,R1
   \   000246   F583         MOV     DPH,A
   \   000248   E0           MOVX    A,@DPTR
   \   000249   60DF         JZ      ??mpu_lp_motion_interrupt_17
   2818                          goto lp_int_restore;
   2819                  }
   2820                  /* If we reach this point, motion interrupt mode hasn't been used yet. */
   2821                  return -1;
   2822              }
   2823          lp_int_restore:
   2824              /* Set to invalid values to ensure no I2C writes are skipped. */
   2825              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_lp_motion_interrupt_11:
   \   00024B   90....       MOV     DPTR,#st + 4
   \   00024E   74FF         MOV     A,#-0x1
   \   000250   F0           MOVX    @DPTR,A
   2826              st.chip_cfg.accel_fsr = 0xFF;
   \   000251   A3           INC     DPTR
   \   000252   F0           MOVX    @DPTR,A
   2827              st.chip_cfg.lpf = 0xFF;
   \   000253   90....       MOV     DPTR,#st + 7
   \   000256   F0           MOVX    @DPTR,A
   2828              st.chip_cfg.sample_rate = 0xFFFF;
   \   000257   90....       MOV     DPTR,#st + 9
   \   00025A   F0           MOVX    @DPTR,A
   \   00025B   A3           INC     DPTR
   \   00025C   F0           MOVX    @DPTR,A
   2829              st.chip_cfg.sensors = 0xFF;
   \   00025D   90....       MOV     DPTR,#st + 6
   \   000260   F0           MOVX    @DPTR,A
   2830              st.chip_cfg.fifo_enable = 0xFF;
   \   000261   90....       MOV     DPTR,#st + 11
   \   000264   F0           MOVX    @DPTR,A
   2831              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   000265   90....       MOV     DPTR,#st + 8
   \   000268   7401         MOV     A,#0x1
   \   00026A   F0           MOVX    @DPTR,A
   2832              mpu_set_sensors(st.chip_cfg.cache.sensors_on);
   \   00026B                ; Setup parameters for call to function mpu_set_sensors
   \   00026B   90....       MOV     DPTR,#st + 24
   \   00026E   E0           MOVX    A,@DPTR
   \   00026F   F9           MOV     R1,A
   \   000270   12....       LCALL   ??mpu_set_sensors?relay
   2833              mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
   \   000273                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   000273   90....       MOV     DPTR,#st + 17
   \   000276   E0           MOVX    A,@DPTR
   \   000277   FA           MOV     R2,A
   \   000278   A3           INC     DPTR
   \   000279   E0           MOVX    A,@DPTR
   \   00027A   FB           MOV     R3,A
   \   00027B   12....       LCALL   ??mpu_set_gyro_fsr?relay
   2834              mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
   \   00027E                ; Setup parameters for call to function mpu_set_accel_fsr
   \   00027E   90....       MOV     DPTR,#st + 19
   \   000281   E0           MOVX    A,@DPTR
   \   000282   F9           MOV     R1,A
   \   000283   12....       LCALL   ??mpu_set_accel_fsr?relay
   2835              mpu_set_lpf(st.chip_cfg.cache.lpf);
   \   000286                ; Setup parameters for call to function mpu_set_lpf
   \   000286   90....       MOV     DPTR,#st + 20
   \   000289   E0           MOVX    A,@DPTR
   \   00028A   FA           MOV     R2,A
   \   00028B   A3           INC     DPTR
   \   00028C   E0           MOVX    A,@DPTR
   \   00028D   FB           MOV     R3,A
   \   00028E   12....       LCALL   ??mpu_set_lpf?relay
   2836              mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
   \   000291                ; Setup parameters for call to function mpu_set_sample_rate
   \   000291   90....       MOV     DPTR,#st + 22
   \   000294   E0           MOVX    A,@DPTR
   \   000295   FA           MOV     R2,A
   \   000296   A3           INC     DPTR
   \   000297   E0           MOVX    A,@DPTR
   \   000298   FB           MOV     R3,A
   \   000299   12....       LCALL   ??mpu_set_sample_rate?relay
   2837              mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
   \   00029C                ; Setup parameters for call to function mpu_configure_fifo
   \   00029C   90....       MOV     DPTR,#st + 25
   \   00029F   E0           MOVX    A,@DPTR
   \   0002A0   F9           MOV     R1,A
   \   0002A1   12....       LCALL   ??mpu_configure_fifo?relay
   2838          
   2839              if (st.chip_cfg.cache.dmp_on)
   \   0002A4   90....       MOV     DPTR,#st + 26
   \   0002A7   E0           MOVX    A,@DPTR
   \   0002A8   6005         JZ      ??mpu_lp_motion_interrupt_18
   2840                  mpu_set_dmp_state(1);
   \   0002AA                ; Setup parameters for call to function mpu_set_dmp_state
   \   0002AA   7901         MOV     R1,#0x1
   \   0002AC   12....       LCALL   ??mpu_set_dmp_state?relay
   2841          
   2842          #ifdef MPU6500
   2843              /* Disable motion interrupt (MPU6500 version). */
   2844              data[0] = 0;
   2845              if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2846                  goto lp_int_restore;
   2847          #endif
   2848          
   2849              st.chip_cfg.int_motion_only = 0;
   \                     ??mpu_lp_motion_interrupt_18:
   \   0002AF   90....       MOV     DPTR,#st + 16
   \   0002B2   E4           CLR     A
   \   0002B3   F0           MOVX    @DPTR,A
   2850              return 0;
   \   0002B4   FA           MOV     R2,A
   \   0002B5   FB           MOV     R3,A
   \                     ??mpu_lp_motion_interrupt_7:
   \   0002B6   7403         MOV     A,#0x3
   \   0002B8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002BB   7F02         MOV     R7,#0x2
   \   0002BD   02....       LJMP    ?BANKED_LEAVE_XDATA
   2851          }
   2852          
   2853          //q30¸ñÊ½,long×ªfloatÊ±µÄ³ýÊý.
   2854          #define q30  1073741824.0f
   2855          
   2856          //ÍÓÂÝÒÇ·½ÏòÉèÖÃ

   \                                 In  segment XDATA_I, align 1, keep-with-next
   2857          static signed char gyro_orientation[9] = { 1, 0, 0,
   \                     gyro_orientation:
   \   000000                DS 9
   \   000009                REQUIRE `?<Initializer for gyro_orientation>`
   \   000009                REQUIRE __INIT_XDATA_I
   2858                                                     0, 1, 0,
   2859                                                     0, 0, 1};
   2860          //MPU6050×Ô²âÊÔ
   2861          //·µ»ØÖµ:0,Õý³£
   2862          //    ÆäËû,Ê§°Ü

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2863          u8 run_self_test(void)
   \                     run_self_test:
   2864          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2865            int result;
   2866            //char test_packet[4] = {0};
   2867            long gyro[3], accel[3]; 
   2868            result = mpu_run_self_test(gyro, accel);
   2869            if (result == 0x3) 
   \   00000A                ; Setup parameters for call to function mpu_run_self_test
   \   00000A   7412         MOV     A,#0x12
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   7406         MOV     A,#0x6
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??mpu_run_self_test?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   7403         MOV     A,#0x3
   \   000023   65..         XRL     A,?V0 + 0
   \   000025   7001         JNZ     ??run_self_test_0
   \   000027   EB           MOV     A,R3
   \                     ??run_self_test_0:
   \   000028   6003         JZ      $+5
   \   00002A   02....       LJMP    ??run_self_test_1 & 0xFFFF
   2870            {
   2871                /* Test passed. We can trust the gyro data here, so let's push it down
   2872                * to the DMP.
   2873                */
   2874                float sens;
   2875                unsigned short accel_sens;
   2876                mpu_get_gyro_sens(&sens);
   \   00002D                ; Setup parameters for call to function mpu_get_gyro_sens
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   AA82         MOV     R2,DPL
   \   000034   AB83         MOV     R3,DPH
   \   000036   12....       LCALL   ??mpu_get_gyro_sens?relay
   2877                gyro[0] = (long)(gyro[0] * sens);
   \   000039   7406         MOV     A,#0x6
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?L_MOV_X
   \   000043   78..         MOV     R0,#?V0 + 0
   \   000045   12....       LCALL   ?L_TO_FLT
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   78..         MOV     R0,#?V0 + 4
   \   00004F   12....       LCALL   ?L_MOV_X
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   79..         MOV     R1,#?V0 + 4
   \   000056   12....       LCALL   ?FLT_MUL
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?FLT_TO_L
   \   00005E   7406         MOV     A,#0x6
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_MOV_TO_X
   2878                gyro[1] = (long)(gyro[1] * sens);
   \   000068   740A         MOV     A,#0xa
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 0
   \   000074   12....       LCALL   ?L_TO_FLT
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   78..         MOV     R0,#?V0 + 4
   \   00007E   12....       LCALL   ?L_MOV_X
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   79..         MOV     R1,#?V0 + 4
   \   000085   12....       LCALL   ?FLT_MUL
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?FLT_TO_L
   \   00008D   740A         MOV     A,#0xa
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?L_MOV_TO_X
   2879                gyro[2] = (long)(gyro[2] * sens);
   \   000097   740E         MOV     A,#0xe
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?L_MOV_X
   \   0000A1   78..         MOV     R0,#?V0 + 0
   \   0000A3   12....       LCALL   ?L_TO_FLT
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?L_MOV_X
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   79..         MOV     R1,#?V0 + 4
   \   0000B4   12....       LCALL   ?FLT_MUL
   \   0000B7   78..         MOV     R0,#?V0 + 0
   \   0000B9   12....       LCALL   ?FLT_TO_L
   \   0000BC   740E         MOV     A,#0xe
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   78..         MOV     R0,#?V0 + 0
   \   0000C3   12....       LCALL   ?L_MOV_TO_X
   2880                dmp_set_gyro_bias(gyro);
   \   0000C6                ; Setup parameters for call to function dmp_set_gyro_bias
   \   0000C6   7406         MOV     A,#0x6
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   AA82         MOV     R2,DPL
   \   0000CD   AB83         MOV     R3,DPH
   \   0000CF   12....       LCALL   ??dmp_set_gyro_bias?relay
   2881                mpu_get_accel_sens(&accel_sens);
   \   0000D2                ; Setup parameters for call to function mpu_get_accel_sens
   \   0000D2   85..82       MOV     DPL,?XSP + 0
   \   0000D5   85..83       MOV     DPH,?XSP + 1
   \   0000D8   AA82         MOV     R2,DPL
   \   0000DA   AB83         MOV     R3,DPH
   \   0000DC   12....       LCALL   ??mpu_get_accel_sens?relay
   2882                accel_sens=0;
   \   0000DF   85..82       MOV     DPL,?XSP + 0
   \   0000E2   85..83       MOV     DPH,?XSP + 1
   \   0000E5   E4           CLR     A
   \   0000E6   F0           MOVX    @DPTR,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   F0           MOVX    @DPTR,A
   2883                accel[0] *= accel_sens;
   \   0000E9   90....       MOV     DPTR,#__Constant_0
   \   0000EC   12....       LCALL   ?XLOAD_R2345
   \   0000EF   7412         MOV     A,#0x12
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   12....       LCALL   ?XSTORE_R2345
   2884                accel[1] *= accel_sens;
   \   0000F7   90....       MOV     DPTR,#__Constant_0
   \   0000FA   12....       LCALL   ?XLOAD_R2345
   \   0000FD   7416         MOV     A,#0x16
   \   0000FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000102   12....       LCALL   ?XSTORE_R2345
   2885                accel[2] *= accel_sens;
   \   000105   90....       MOV     DPTR,#__Constant_0
   \   000108   12....       LCALL   ?XLOAD_R2345
   \   00010B   741A         MOV     A,#0x1a
   \   00010D   12....       LCALL   ?XSTACK_DISP0_8
   \   000110   12....       LCALL   ?XSTORE_R2345
   2886                dmp_set_accel_bias(accel);
   \   000113                ; Setup parameters for call to function dmp_set_accel_bias
   \   000113   7412         MOV     A,#0x12
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   AA82         MOV     R2,DPL
   \   00011A   AB83         MOV     R3,DPH
   \   00011C   12....       LCALL   ??dmp_set_accel_bias?relay
   2887                return 0;
   \   00011F   7900         MOV     R1,#0x0
   \   000121   8002         SJMP    ??run_self_test_2
   2888            }else return 1;
   \                     ??run_self_test_1:
   \   000123   7901         MOV     R1,#0x1
   \                     ??run_self_test_2:
   \   000125   741E         MOV     A,#0x1e
   \   000127   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012A   7F08         MOV     R7,#0x8
   \   00012C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2889          }
   2890          //ÍÓÂÝÒÇ·½Ïò¿ØÖÆ

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2891          unsigned short inv_orientation_matrix_to_scalar(
   \                     inv_orientation_matrix_to_scalar:
   2892              const signed char *mtx)
   2893          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2894              unsigned short scalar; 
   2895              /*
   2896                 XYZ  010_001_000 Identity Matrix
   2897                 XZY  001_010_000
   2898                 YXZ  010_000_001
   2899                 YZX  000_010_001
   2900                 ZXY  001_000_010
   2901                 ZYX  000_001_010
   2902               */
   2903          
   2904              scalar = inv_row_2_scale(mtx);
   \   000009                ; Setup parameters for call to function inv_row_2_scale
   \   000009   12....       LCALL   ??inv_row_2_scale?relay
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   2905              scalar |= inv_row_2_scale(mtx + 3) << 3;
   \   000010                ; Setup parameters for call to function inv_row_2_scale
   \   000010   EE           MOV     A,R6
   \   000011   2403         ADD     A,#0x3
   \   000013   FA           MOV     R2,A
   \   000014   EF           MOV     A,R7
   \   000015   3400         ADDC    A,#0x0
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   ??inv_row_2_scale?relay
   \   00001B   8A..         MOV     ?V0 + 2,R2
   \   00001D   8B..         MOV     ?V0 + 3,R3
   \   00001F   7403         MOV     A,#0x3
   \   000021   78..         MOV     R0,#?V0 + 2
   \   000023   12....       LCALL   ?S_SHL
   \   000026   E5..         MOV     A,?V0 + 2
   \   000028   45..         ORL     A,?V0 + 0
   \   00002A   F5..         MOV     ?V0 + 0,A
   \   00002C   E5..         MOV     A,?V0 + 3
   \   00002E   45..         ORL     A,?V0 + 1
   \   000030   F5..         MOV     ?V0 + 1,A
   2906              scalar |= inv_row_2_scale(mtx + 6) << 6;
   \   000032                ; Setup parameters for call to function inv_row_2_scale
   \   000032   EE           MOV     A,R6
   \   000033   2406         ADD     A,#0x6
   \   000035   FA           MOV     R2,A
   \   000036   EF           MOV     A,R7
   \   000037   3400         ADDC    A,#0x0
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??inv_row_2_scale?relay
   \   00003D   8A..         MOV     ?V0 + 2,R2
   \   00003F   8B..         MOV     ?V0 + 3,R3
   \   000041   7406         MOV     A,#0x6
   \   000043   78..         MOV     R0,#?V0 + 2
   \   000045   12....       LCALL   ?S_SHL
   \   000048   E5..         MOV     A,?V0 + 2
   \   00004A   45..         ORL     A,?V0 + 0
   \   00004C   F5..         MOV     ?V0 + 0,A
   \   00004E   E5..         MOV     A,?V0 + 3
   \   000050   45..         ORL     A,?V0 + 1
   2907          
   2908          
   2909              return scalar;
   \   000052   AA..         MOV     R2,?V0 + 0
   \   000054   FB           MOV     R3,A
   \   000055   7F04         MOV     R7,#0x4
   \   000057   02....       LJMP    ?BANKED_LEAVE_XDATA
   2910          }
   2911          //·½Ïò×ª»»

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2912          unsigned short inv_row_2_scale(const signed char *row)
   \                     inv_row_2_scale:
   2913          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2914              unsigned short b;
   2915          
   2916              if (row[0] > 0)
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   C3           CLR     C
   \   00000A   9401         SUBB    A,#0x1
   \   00000C   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00000E   65D0         XRL     A,PSW
   \   000010   33           RLC     A
   \   000011   4004         JC      ??inv_row_2_scale_0
   2917                  b = 0;
   \   000013   7A00         MOV     R2,#0x0
   \   000015   8058         SJMP    ??inv_row_2_scale_1
   2918              else if (row[0] < 0)
   \                     ??inv_row_2_scale_0:
   \   000017   E0           MOVX    A,@DPTR
   \   000018   C3           CLR     C
   \   000019   9400         SUBB    A,#0x0
   \   00001B   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00001D   65D0         XRL     A,PSW
   \   00001F   33           RLC     A
   \   000020   5004         JNC     ??inv_row_2_scale_2
   2919                  b = 4;
   \   000022   7A04         MOV     R2,#0x4
   \   000024   8049         SJMP    ??inv_row_2_scale_1
   2920              else if (row[1] > 0)
   \                     ??inv_row_2_scale_2:
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C3           CLR     C
   \   000029   9401         SUBB    A,#0x1
   \   00002B   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00002D   65D0         XRL     A,PSW
   \   00002F   33           RLC     A
   \   000030   4004         JC      ??inv_row_2_scale_3
   2921                  b = 1;
   \   000032   7A01         MOV     R2,#0x1
   \   000034   8039         SJMP    ??inv_row_2_scale_1
   2922              else if (row[1] < 0)
   \                     ??inv_row_2_scale_3:
   \   000036   E0           MOVX    A,@DPTR
   \   000037   C3           CLR     C
   \   000038   9400         SUBB    A,#0x0
   \   00003A   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00003C   65D0         XRL     A,PSW
   \   00003E   33           RLC     A
   \   00003F   5004         JNC     ??inv_row_2_scale_4
   2923                  b = 5;
   \   000041   7A05         MOV     R2,#0x5
   \   000043   802A         SJMP    ??inv_row_2_scale_1
   2924              else if (row[2] > 0)
   \                     ??inv_row_2_scale_4:
   \   000045   EA           MOV     A,R2
   \   000046   2402         ADD     A,#0x2
   \   000048   F582         MOV     DPL,A
   \   00004A   EB           MOV     A,R3
   \   00004B   3400         ADDC    A,#0x0
   \   00004D   F583         MOV     DPH,A
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   C3           CLR     C
   \   000051   9401         SUBB    A,#0x1
   \   000053   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000055   65D0         XRL     A,PSW
   \   000057   33           RLC     A
   \   000058   4004         JC      ??inv_row_2_scale_5
   2925                  b = 2;
   \   00005A   7A02         MOV     R2,#0x2
   \   00005C   8011         SJMP    ??inv_row_2_scale_1
   2926              else if (row[2] < 0)
   \                     ??inv_row_2_scale_5:
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   C3           CLR     C
   \   000060   9400         SUBB    A,#0x0
   \   000062   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000064   65D0         XRL     A,PSW
   \   000066   33           RLC     A
   \   000067   5004         JNC     ??inv_row_2_scale_6
   2927                  b = 6;
   \   000069   7A06         MOV     R2,#0x6
   \   00006B   8002         SJMP    ??inv_row_2_scale_1
   2928              else
   2929                  b = 7;      // error
   \                     ??inv_row_2_scale_6:
   \   00006D   7A07         MOV     R2,#0x7
   \                     ??inv_row_2_scale_1:
   \   00006F   7B00         MOV     R3,#0x0
   2930              return b;
   \   000071   D083         POP     DPH
   \   000073   D082         POP     DPL
   \   000075   02....       LJMP    ?BRET
   2931          }
   2932          //¿Õº¯Êý,Î´ÓÃµ½.

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2933          void mget_ms(unsigned long *time)
   \                     mget_ms:
   2934          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2935          
   2936          }
   \   000000   02....       LJMP    ?BRET
   2937          //mpu6050,dmp³õÊ¼»¯
   2938          //·µ»ØÖµ:0,Õý³£
   2939          //    ÆäËû,Ê§°Ü

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2940          u8 mpu_dmp_init(void)
   \                     mpu_dmp_init:
   2941          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2942            u8 res=0;
   2943            MPU_IIC_Init(); 	//³õÊ¼»¯MPU_IIC×ÜÏß
   \   000005                ; Setup parameters for call to function MPU_IIC_Init
   \   000005   12....       LCALL   ??MPU_IIC_Init?relay
   2944            if(mpu_init()==0)	//³õÊ¼»¯MPU6050
   \   000008                ; Setup parameters for call to function mpu_init
   \   000008   12....       LCALL   ??mpu_init?relay
   \   00000B   8B..         MOV     ?V0 + 1,R3
   \   00000D   EA           MOV     A,R2
   \   00000E   45..         ORL     A,?V0 + 1
   \   000010   706D         JNZ     ??mpu_dmp_init_0
   2945            {	 
   2946                res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);    //ÉèÖÃËùÐèÒªµÄ´«¸ÐÆ÷
   \   000012                ; Setup parameters for call to function mpu_set_sensors
   \   000012   7978         MOV     R1,#0x78
   \   000014   12....       LCALL   ??mpu_set_sensors?relay
   \   000017   EA           MOV     A,R2
   2947                if(res)return 1; 
   \   000018   6004         JZ      ??mpu_dmp_init_1
   \   00001A   7901         MOV     R1,#0x1
   \   00001C   8063         SJMP    ??mpu_dmp_init_2
   2948                res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL); //ÉèÖÃFIFO
   \                     ??mpu_dmp_init_1:
   \   00001E                ; Setup parameters for call to function mpu_configure_fifo
   \   00001E   7978         MOV     R1,#0x78
   \   000020   12....       LCALL   ??mpu_configure_fifo?relay
   \   000023   EA           MOV     A,R2
   2949                if(res)return 2; 
   \   000024   6004         JZ      ??mpu_dmp_init_3
   \   000026   7902         MOV     R1,#0x2
   \   000028   8057         SJMP    ??mpu_dmp_init_2
   2950                res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	          //ÉèÖÃ²ÉÑùÂÊ
   \                     ??mpu_dmp_init_3:
   \   00002A                ; Setup parameters for call to function mpu_set_sample_rate
   \   00002A   7A64         MOV     R2,#0x64
   \   00002C   7B00         MOV     R3,#0x0
   \   00002E   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000031   EA           MOV     A,R2
   2951                if(res)return 3; 
   \   000032   6004         JZ      ??mpu_dmp_init_4
   \   000034   7903         MOV     R1,#0x3
   \   000036   8049         SJMP    ??mpu_dmp_init_2
   2952                res=dmp_load_motion_driver_firmware();		  //¼ÓÔØdmp¹Ì¼þ
   \                     ??mpu_dmp_init_4:
   \   000038                ; Setup parameters for call to function dmp_load_motion_driver_firmware
   \   000038   12....       LCALL   ??dmp_load_motion_driver_firmware?relay
   \   00003B   EA           MOV     A,R2
   2953                if(res)return 4; 
   \   00003C   6004         JZ      ??mpu_dmp_init_5
   \   00003E   7904         MOV     R1,#0x4
   \   000040   803F         SJMP    ??mpu_dmp_init_2
   2954                res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//ÉèÖÃÍÓÂÝÒÇ·½Ïò
   \                     ??mpu_dmp_init_5:
   \   000042                ; Setup parameters for call to function dmp_set_orientation
   \   000042                ; Setup parameters for call to function inv_orientation_matrix_to_scalar
   \   000042   7A..         MOV     R2,#gyro_orientation & 0xff
   \   000044   7B..         MOV     R3,#(gyro_orientation >> 8) & 0xff
   \   000046   12....       LCALL   ??inv_orientation_matrix_to_scalar?relay
   \   000049   12....       LCALL   ??dmp_set_orientation?relay
   \   00004C   EA           MOV     A,R2
   2955                if(res)return 5; 
   \   00004D   6004         JZ      ??mpu_dmp_init_6
   \   00004F   7905         MOV     R1,#0x5
   \   000051   802E         SJMP    ??mpu_dmp_init_2
   2956                res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	          //ÉèÖÃdmp¹¦ÄÜ
   2957                    DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
   2958                    DMP_FEATURE_GYRO_CAL);
   \                     ??mpu_dmp_init_6:
   \   000053                ; Setup parameters for call to function dmp_enable_feature
   \   000053   7A73         MOV     R2,#0x73
   \   000055   7B01         MOV     R3,#0x1
   \   000057   12....       LCALL   ??dmp_enable_feature?relay
   \   00005A   EA           MOV     A,R2
   2959                if(res)return 6; 
   \   00005B   6004         JZ      ??mpu_dmp_init_7
   \   00005D   7906         MOV     R1,#0x6
   \   00005F   8020         SJMP    ??mpu_dmp_init_2
   2960                res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);  //ÉèÖÃDMPÊä³öËÙÂÊ(×î´ó²»³¬¹ý200Hz)
   \                     ??mpu_dmp_init_7:
   \   000061                ; Setup parameters for call to function dmp_set_fifo_rate
   \   000061   7A64         MOV     R2,#0x64
   \   000063   7B00         MOV     R3,#0x0
   \   000065   12....       LCALL   ??dmp_set_fifo_rate?relay
   \   000068   EA           MOV     A,R2
   2961                if(res)return 7;   
   \   000069   6004         JZ      ??mpu_dmp_init_8
   \   00006B   7907         MOV     R1,#0x7
   \   00006D   8012         SJMP    ??mpu_dmp_init_2
   2962          //      res=run_self_test();		      //×Ô¼ì
   2963          //      if(res)return 8;    
   2964                res=mpu_set_dmp_state(1);	              //Ê¹ÄÜDMP
   \                     ??mpu_dmp_init_8:
   \   00006F                ; Setup parameters for call to function mpu_set_dmp_state
   \   00006F   7901         MOV     R1,#0x1
   \   000071   12....       LCALL   ??mpu_set_dmp_state?relay
   \   000074   EA           MOV     A,R2
   2965                if(res)return 9;     
   \   000075   6004         JZ      ??mpu_dmp_init_9
   \   000077   7909         MOV     R1,#0x9
   \   000079   8006         SJMP    ??mpu_dmp_init_2
   2966            }else return 10;
   2967            return 0;
   \                     ??mpu_dmp_init_9:
   \   00007B   7900         MOV     R1,#0x0
   \   00007D   8002         SJMP    ??mpu_dmp_init_2
   \                     ??mpu_dmp_init_0:
   \   00007F   790A         MOV     R1,#0xa
   \                     ??mpu_dmp_init_2:
   \   000081   7F02         MOV     R7,#0x2
   \   000083   02....       LJMP    ?BANKED_LEAVE_XDATA
   2968          }
   2969          
   2970          //µÃµ½dmp´¦ÀíºóµÄÊý¾Ý(×¢Òâ,±¾º¯ÊýÐèÒª±È½Ï¶à¶ÑÕ»,¾Ö²¿±äÁ¿ÓÐµã¶à)
   2971          //pitch:¸©Ñö½Ç ¾«¶È:0.1¡ã   ·¶Î§:-90.0¡ã <---> +90.0¡ã
   2972          //roll:ºá¹ö½Ç  ¾«¶È:0.1¡ã   ·¶Î§:-180.0¡ã<---> +180.0¡ã
   2973          //yaw:º½Ïò½Ç   ¾«¶È:0.1¡ã   ·¶Î§:-180.0¡ã<---> +180.0¡ã
   2974          //·µ»ØÖµ:0,Õý³£
   2975          //    ÆäËû,Ê§°Ü

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2976          u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
   \                     mpu_dmp_get_data:
   2977          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 55
   \   000005   74C9         MOV     A,#-0x37
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7415         MOV     A,#0x15
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   7413         MOV     A,#0x13
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   EC           MOV     A,R4
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   ED           MOV     A,R5
   \   00001D   F0           MOVX    @DPTR,A
   2978          	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
   2979          	unsigned long sensor_timestamp;
   2980          	short gyro[3], accel[3], sensors;
   2981          	unsigned char more;
   2982          	long quat[4]; 
   2983          	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))
   \   00001E                ; Setup parameters for call to function dmp_read_fifo
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   8582..       MOV     ?V0 + 0,DPL
   \   000027   8583..       MOV     ?V0 + 1,DPH
   \   00002A   78..         MOV     R0,#?V0 + 0
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   740F         MOV     A,#0xf
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   8582..       MOV     ?V0 + 0,DPL
   \   000037   8583..       MOV     ?V0 + 1,DPH
   \   00003A   78..         MOV     R0,#?V0 + 0
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   741B         MOV     A,#0x1b
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   8582..       MOV     ?V0 + 0,DPL
   \   000047   8583..       MOV     ?V0 + 1,DPH
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   7421         MOV     A,#0x21
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   8582..       MOV     ?V0 + 0,DPL
   \   000057   8583..       MOV     ?V0 + 1,DPH
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005F   7433         MOV     A,#0x33
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   AC82         MOV     R4,DPL
   \   000066   AD83         MOV     R5,DPH
   \   000068   7439         MOV     A,#0x39
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   AA82         MOV     R2,DPL
   \   00006F   AB83         MOV     R3,DPH
   \   000071   12....       LCALL   ??dmp_read_fifo?relay
   \   000074   7408         MOV     A,#0x8
   \   000076   12....       LCALL   ?DEALLOC_XSTACK8
   \   000079   8B..         MOV     ?V0 + 1,R3
   \   00007B   EA           MOV     A,R2
   \   00007C   45..         ORL     A,?V0 + 1
   \   00007E   6005         JZ      ??mpu_dmp_get_data_0
   2984                  {
   2985                    //printf("read dmp_read_fifo error\r\n");
   2986                    return 1;	 //gyro
   \   000080   7901         MOV     R1,#0x1
   \   000082   02....       LJMP    ??mpu_dmp_get_data_1 & 0xFFFF
   2987                  }
   2988          	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
   2989          	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
   2990          	**/
   2991          	/*if (sensors & INV_XYZ_GYRO )
   2992          	send_packet(PACKET_TYPE_GYRO, gyro);
   2993          	if (sensors & INV_XYZ_ACCEL)
   2994          	send_packet(PACKET_TYPE_ACCEL, accel); */
   2995          	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
   2996          	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
   2997          	**/
   2998          	if(sensors&INV_WXYZ_QUAT) 
   \                     ??mpu_dmp_get_data_0:
   \   000085   740D         MOV     A,#0xd
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   5401         ANL     A,#0x1
   \   00008E   7003         JNZ     $+5
   \   000090   02....       LJMP    ??mpu_dmp_get_data_2 & 0xFFFF
   2999          	{
   3000          		q0 = quat[0] / q30;	//q30¸ñÊ½×ª»»Îª¸¡µãÊý
   \   000093   741B         MOV     A,#0x1b
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   78..         MOV     R0,#?V0 + 0
   \   00009A   12....       LCALL   ?L_MOV_X
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?L_TO_FLT
   \   0000A2   90....       MOV     DPTR,#__Constant_30800000
   \   0000A5   78..         MOV     R0,#?V0 + 4
   \   0000A7   12....       LCALL   ?L_MOV_X
   \   0000AA   78..         MOV     R0,#?V0 + 0
   \   0000AC   79..         MOV     R1,#?V0 + 4
   \   0000AE   12....       LCALL   ?FLT_MUL
   \   0000B1   740F         MOV     A,#0xf
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?L_MOV_TO_X
   3001          		q1 = quat[1] / q30;
   \   0000BB   741F         MOV     A,#0x1f
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   78..         MOV     R0,#?V0 + 0
   \   0000C2   12....       LCALL   ?L_MOV_X
   \   0000C5   78..         MOV     R0,#?V0 + 0
   \   0000C7   12....       LCALL   ?L_TO_FLT
   \   0000CA   90....       MOV     DPTR,#__Constant_30800000
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   12....       LCALL   ?L_MOV_X
   \   0000D2   78..         MOV     R0,#?V0 + 0
   \   0000D4   79..         MOV     R1,#?V0 + 4
   \   0000D6   12....       LCALL   ?FLT_MUL
   \   0000D9   7405         MOV     A,#0x5
   \   0000DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DE   78..         MOV     R0,#?V0 + 0
   \   0000E0   12....       LCALL   ?L_MOV_TO_X
   3002          		q2 = quat[2] / q30;
   \   0000E3   7423         MOV     A,#0x23
   \   0000E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E8   78..         MOV     R0,#?V0 + 0
   \   0000EA   12....       LCALL   ?L_MOV_X
   \   0000ED   78..         MOV     R0,#?V0 + 0
   \   0000EF   12....       LCALL   ?L_TO_FLT
   \   0000F2   90....       MOV     DPTR,#__Constant_30800000
   \   0000F5   78..         MOV     R0,#?V0 + 4
   \   0000F7   12....       LCALL   ?L_MOV_X
   \   0000FA   78..         MOV     R0,#?V0 + 0
   \   0000FC   79..         MOV     R1,#?V0 + 4
   \   0000FE   12....       LCALL   ?FLT_MUL
   \   000101   7401         MOV     A,#0x1
   \   000103   12....       LCALL   ?XSTACK_DISP0_8
   \   000106   78..         MOV     R0,#?V0 + 0
   \   000108   12....       LCALL   ?L_MOV_TO_X
   3003          		q3 = quat[3] / q30; 
   \   00010B   7427         MOV     A,#0x27
   \   00010D   12....       LCALL   ?XSTACK_DISP0_8
   \   000110   78..         MOV     R0,#?V0 + 0
   \   000112   12....       LCALL   ?L_MOV_X
   \   000115   78..         MOV     R0,#?V0 + 0
   \   000117   12....       LCALL   ?L_TO_FLT
   \   00011A   90....       MOV     DPTR,#__Constant_30800000
   \   00011D   78..         MOV     R0,#?V0 + 4
   \   00011F   12....       LCALL   ?L_MOV_X
   \   000122   78..         MOV     R0,#?V0 + 0
   \   000124   79..         MOV     R1,#?V0 + 4
   \   000126   12....       LCALL   ?FLT_MUL
   \   000129   7409         MOV     A,#0x9
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   78..         MOV     R0,#?V0 + 0
   \   000130   12....       LCALL   ?L_MOV_TO_X
   3004          		//¼ÆËãµÃµ½¸©Ñö½Ç/ºá¹ö½Ç/º½Ïò½Ç
   3005          		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
   \   000133   740F         MOV     A,#0xf
   \   000135   12....       LCALL   ?XSTACK_DISP0_8
   \   000138   78..         MOV     R0,#?V0 + 4
   \   00013A   12....       LCALL   ?L_MOV_X
   \   00013D   90....       MOV     DPTR,#__Constant_40000000
   \   000140   78..         MOV     R0,#?V0 + 0
   \   000142   12....       LCALL   ?L_MOV_X
   \   000145   78..         MOV     R0,#?V0 + 4
   \   000147   79..         MOV     R1,#?V0 + 0
   \   000149   12....       LCALL   ?FLT_MUL
   \   00014C   7405         MOV     A,#0x5
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   78..         MOV     R0,#?V0 + 12
   \   000153   12....       LCALL   ?L_MOV_X
   \   000156   90....       MOV     DPTR,#__Constant_c0000000
   \   000159   78..         MOV     R0,#?V0 + 0
   \   00015B   12....       LCALL   ?L_MOV_X
   \   00015E   78..         MOV     R0,#?V0 + 12
   \   000160   79..         MOV     R1,#?V0 + 0
   \   000162   12....       LCALL   ?FLT_MUL
   \   000165                ; Setup parameters for call to function asin
   \   000165   85....       MOV     ?V0 + 0,?V0 + 12
   \   000168   85....       MOV     ?V0 + 1,?V0 + 13
   \   00016B   85....       MOV     ?V0 + 2,?V0 + 14
   \   00016E   85....       MOV     ?V0 + 3,?V0 + 15
   \   000171   7409         MOV     A,#0x9
   \   000173   12....       LCALL   ?XSTACK_DISP0_8
   \   000176   78..         MOV     R0,#?V0 + 8
   \   000178   12....       LCALL   ?L_MOV_X
   \   00017B   78..         MOV     R0,#?V0 + 0
   \   00017D   79..         MOV     R1,#?V0 + 8
   \   00017F   12....       LCALL   ?FLT_MUL
   \   000182   C0..         PUSH    ?V0 + 0
   \   000184   C0..         PUSH    ?V0 + 1
   \   000186   C0..         PUSH    ?V0 + 2
   \   000188   C0..         PUSH    ?V0 + 3
   \   00018A   85....       MOV     ?V0 + 0,?V0 + 4
   \   00018D   85....       MOV     ?V0 + 1,?V0 + 5
   \   000190   85....       MOV     ?V0 + 2,?V0 + 6
   \   000193   85....       MOV     ?V0 + 3,?V0 + 7
   \   000196   7401         MOV     A,#0x1
   \   000198   12....       LCALL   ?XSTACK_DISP0_8
   \   00019B   78..         MOV     R0,#?V0 + 8
   \   00019D   12....       LCALL   ?L_MOV_X
   \   0001A0   78..         MOV     R0,#?V0 + 0
   \   0001A2   79..         MOV     R1,#?V0 + 8
   \   0001A4   12....       LCALL   ?FLT_MUL
   \   0001A7   D0..         POP     ?V0 + 11
   \   0001A9   D0..         POP     ?V0 + 10
   \   0001AB   D0..         POP     ?V0 + 9
   \   0001AD   D0..         POP     ?V0 + 8
   \   0001AF   78..         MOV     R0,#?V0 + 8
   \   0001B1   79..         MOV     R1,#?V0 + 0
   \   0001B3   12....       LCALL   ?FLT_ADD
   \   0001B6   AA..         MOV     R2,?V0 + 8
   \   0001B8   AB..         MOV     R3,?V0 + 9
   \   0001BA   AC..         MOV     R4,?V0 + 10
   \   0001BC   AD..         MOV     R5,?V0 + 11
   \   0001BE   12....       LCALL   ??asin?relay
   \   0001C1   8A..         MOV     ?V0 + 0,R2
   \   0001C3   8B..         MOV     ?V0 + 1,R3
   \   0001C5   8C..         MOV     ?V0 + 2,R4
   \   0001C7   8D..         MOV     ?V0 + 3,R5
   \   0001C9   90....       MOV     DPTR,#__Constant_42653333
   \   0001CC   78..         MOV     R0,#?V0 + 8
   \   0001CE   12....       LCALL   ?L_MOV_X
   \   0001D1   78..         MOV     R0,#?V0 + 0
   \   0001D3   79..         MOV     R1,#?V0 + 8
   \   0001D5   12....       LCALL   ?FLT_MUL
   \   0001D8   7415         MOV     A,#0x15
   \   0001DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DD   E0           MOVX    A,@DPTR
   \   0001DE   F8           MOV     R0,A
   \   0001DF   A3           INC     DPTR
   \   0001E0   E0           MOVX    A,@DPTR
   \   0001E1   F583         MOV     DPH,A
   \   0001E3   8882         MOV     DPL,R0
   \   0001E5   78..         MOV     R0,#?V0 + 0
   \   0001E7   12....       LCALL   ?L_MOV_TO_X
   3006          		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
   \   0001EA   7401         MOV     A,#0x1
   \   0001EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EF   78..         MOV     R0,#?V0 + 8
   \   0001F1   12....       LCALL   ?L_MOV_X
   \   0001F4   90....       MOV     DPTR,#__Constant_40000000
   \   0001F7   78..         MOV     R0,#?V0 + 0
   \   0001F9   12....       LCALL   ?L_MOV_X
   \   0001FC   78..         MOV     R0,#?V0 + 8
   \   0001FE   79..         MOV     R1,#?V0 + 0
   \   000200   12....       LCALL   ?FLT_MUL
   \   000203                ; Setup parameters for call to function atan2
   \   000203   7405         MOV     A,#0x5
   \   000205   12....       LCALL   ?XSTACK_DISP0_8
   \   000208   78..         MOV     R0,#?V0 + 0
   \   00020A   12....       LCALL   ?L_MOV_X
   \   00020D   78..         MOV     R0,#?V0 + 12
   \   00020F   79..         MOV     R1,#?V0 + 0
   \   000211   12....       LCALL   ?FLT_MUL
   \   000214   C0..         PUSH    ?V0 + 12
   \   000216   C0..         PUSH    ?V0 + 13
   \   000218   C0..         PUSH    ?V0 + 14
   \   00021A   C0..         PUSH    ?V0 + 15
   \   00021C   85....       MOV     ?V0 + 0,?V0 + 8
   \   00021F   85....       MOV     ?V0 + 1,?V0 + 9
   \   000222   85....       MOV     ?V0 + 2,?V0 + 10
   \   000225   85....       MOV     ?V0 + 3,?V0 + 11
   \   000228   7401         MOV     A,#0x1
   \   00022A   12....       LCALL   ?XSTACK_DISP0_8
   \   00022D   78..         MOV     R0,#?V0 + 12
   \   00022F   12....       LCALL   ?L_MOV_X
   \   000232   78..         MOV     R0,#?V0 + 0
   \   000234   79..         MOV     R1,#?V0 + 12
   \   000236   12....       LCALL   ?FLT_MUL
   \   000239   D0..         POP     ?V0 + 15
   \   00023B   D0..         POP     ?V0 + 14
   \   00023D   D0..         POP     ?V0 + 13
   \   00023F   D0..         POP     ?V0 + 12
   \   000241   78..         MOV     R0,#?V0 + 12
   \   000243   79..         MOV     R1,#?V0 + 0
   \   000245   12....       LCALL   ?FLT_SUB
   \   000248   90....       MOV     DPTR,#__Constant_3f800000
   \   00024B   78..         MOV     R0,#?V0 + 0
   \   00024D   12....       LCALL   ?L_MOV_X
   \   000250   78..         MOV     R0,#?V0 + 12
   \   000252   79..         MOV     R1,#?V0 + 0
   \   000254   12....       LCALL   ?FLT_ADD
   \   000257   78..         MOV     R0,#?V0 + 12
   \   000259   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00025C   740D         MOV     A,#0xd
   \   00025E   12....       LCALL   ?XSTACK_DISP0_8
   \   000261   78..         MOV     R0,#?V0 + 0
   \   000263   12....       LCALL   ?L_MOV_X
   \   000266   78..         MOV     R0,#?V0 + 8
   \   000268   79..         MOV     R1,#?V0 + 0
   \   00026A   12....       LCALL   ?FLT_MUL
   \   00026D   7409         MOV     A,#0x9
   \   00026F   12....       LCALL   ?XSTACK_DISP0_8
   \   000272   78..         MOV     R0,#?V0 + 0
   \   000274   12....       LCALL   ?L_MOV_X
   \   000277   78..         MOV     R0,#?V0 + 4
   \   000279   79..         MOV     R1,#?V0 + 0
   \   00027B   12....       LCALL   ?FLT_MUL
   \   00027E   78..         MOV     R0,#?V0 + 8
   \   000280   79..         MOV     R1,#?V0 + 4
   \   000282   12....       LCALL   ?FLT_ADD
   \   000285   AA..         MOV     R2,?V0 + 8
   \   000287   AB..         MOV     R3,?V0 + 9
   \   000289   AC..         MOV     R4,?V0 + 10
   \   00028B   AD..         MOV     R5,?V0 + 11
   \   00028D   12....       LCALL   ??atan2?relay
   \   000290   7404         MOV     A,#0x4
   \   000292   12....       LCALL   ?DEALLOC_XSTACK8
   \   000295   8A..         MOV     ?V0 + 0,R2
   \   000297   8B..         MOV     ?V0 + 1,R3
   \   000299   8C..         MOV     ?V0 + 2,R4
   \   00029B   8D..         MOV     ?V0 + 3,R5
   \   00029D   90....       MOV     DPTR,#__Constant_42653333
   \   0002A0   78..         MOV     R0,#?V0 + 4
   \   0002A2   12....       LCALL   ?L_MOV_X
   \   0002A5   78..         MOV     R0,#?V0 + 0
   \   0002A7   79..         MOV     R1,#?V0 + 4
   \   0002A9   12....       LCALL   ?FLT_MUL
   \   0002AC   7413         MOV     A,#0x13
   \   0002AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B1   E0           MOVX    A,@DPTR
   \   0002B2   F8           MOV     R0,A
   \   0002B3   A3           INC     DPTR
   \   0002B4   E0           MOVX    A,@DPTR
   \   0002B5   F583         MOV     DPH,A
   \   0002B7   8882         MOV     DPL,R0
   \   0002B9   78..         MOV     R0,#?V0 + 0
   \   0002BB   12....       LCALL   ?L_MOV_TO_X
   3007          		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
   \   0002BE                ; Setup parameters for call to function atan2
   \   0002BE   740F         MOV     A,#0xf
   \   0002C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C3   78..         MOV     R0,#?V0 + 0
   \   0002C5   12....       LCALL   ?L_MOV_X
   \   0002C8   740F         MOV     A,#0xf
   \   0002CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CD   78..         MOV     R0,#?V0 + 4
   \   0002CF   12....       LCALL   ?L_MOV_X
   \   0002D2   78..         MOV     R0,#?V0 + 0
   \   0002D4   79..         MOV     R1,#?V0 + 4
   \   0002D6   12....       LCALL   ?FLT_MUL
   \   0002D9   7405         MOV     A,#0x5
   \   0002DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002DE   78..         MOV     R0,#?V0 + 4
   \   0002E0   12....       LCALL   ?L_MOV_X
   \   0002E3   7405         MOV     A,#0x5
   \   0002E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E8   78..         MOV     R0,#?V0 + 8
   \   0002EA   12....       LCALL   ?L_MOV_X
   \   0002ED   78..         MOV     R0,#?V0 + 4
   \   0002EF   79..         MOV     R1,#?V0 + 8
   \   0002F1   12....       LCALL   ?FLT_MUL
   \   0002F4   78..         MOV     R0,#?V0 + 0
   \   0002F6   79..         MOV     R1,#?V0 + 4
   \   0002F8   12....       LCALL   ?FLT_ADD
   \   0002FB   7401         MOV     A,#0x1
   \   0002FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000300   78..         MOV     R0,#?V0 + 4
   \   000302   12....       LCALL   ?L_MOV_X
   \   000305   7401         MOV     A,#0x1
   \   000307   12....       LCALL   ?XSTACK_DISP0_8
   \   00030A   78..         MOV     R0,#?V0 + 8
   \   00030C   12....       LCALL   ?L_MOV_X
   \   00030F   78..         MOV     R0,#?V0 + 4
   \   000311   79..         MOV     R1,#?V0 + 8
   \   000313   12....       LCALL   ?FLT_MUL
   \   000316   78..         MOV     R0,#?V0 + 0
   \   000318   79..         MOV     R1,#?V0 + 4
   \   00031A   12....       LCALL   ?FLT_SUB
   \   00031D   7409         MOV     A,#0x9
   \   00031F   12....       LCALL   ?XSTACK_DISP0_8
   \   000322   78..         MOV     R0,#?V0 + 4
   \   000324   12....       LCALL   ?L_MOV_X
   \   000327   7409         MOV     A,#0x9
   \   000329   12....       LCALL   ?XSTACK_DISP0_8
   \   00032C   78..         MOV     R0,#?V0 + 8
   \   00032E   12....       LCALL   ?L_MOV_X
   \   000331   78..         MOV     R0,#?V0 + 4
   \   000333   79..         MOV     R1,#?V0 + 8
   \   000335   12....       LCALL   ?FLT_MUL
   \   000338   78..         MOV     R0,#?V0 + 0
   \   00033A   79..         MOV     R1,#?V0 + 4
   \   00033C   12....       LCALL   ?FLT_SUB
   \   00033F   78..         MOV     R0,#?V0 + 0
   \   000341   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000344   7409         MOV     A,#0x9
   \   000346   12....       LCALL   ?XSTACK_DISP0_8
   \   000349   78..         MOV     R0,#?V0 + 0
   \   00034B   12....       LCALL   ?L_MOV_X
   \   00034E   7405         MOV     A,#0x5
   \   000350   12....       LCALL   ?XSTACK_DISP0_8
   \   000353   78..         MOV     R0,#?V0 + 4
   \   000355   12....       LCALL   ?L_MOV_X
   \   000358   78..         MOV     R0,#?V0 + 0
   \   00035A   79..         MOV     R1,#?V0 + 4
   \   00035C   12....       LCALL   ?FLT_MUL
   \   00035F   7413         MOV     A,#0x13
   \   000361   12....       LCALL   ?XSTACK_DISP0_8
   \   000364   78..         MOV     R0,#?V0 + 4
   \   000366   12....       LCALL   ?L_MOV_X
   \   000369   740D         MOV     A,#0xd
   \   00036B   12....       LCALL   ?XSTACK_DISP0_8
   \   00036E   78..         MOV     R0,#?V0 + 8
   \   000370   12....       LCALL   ?L_MOV_X
   \   000373   78..         MOV     R0,#?V0 + 4
   \   000375   79..         MOV     R1,#?V0 + 8
   \   000377   12....       LCALL   ?FLT_MUL
   \   00037A   78..         MOV     R0,#?V0 + 0
   \   00037C   79..         MOV     R1,#?V0 + 4
   \   00037E   12....       LCALL   ?FLT_ADD
   \   000381   90....       MOV     DPTR,#__Constant_40000000
   \   000384   78..         MOV     R0,#?V0 + 4
   \   000386   12....       LCALL   ?L_MOV_X
   \   000389   78..         MOV     R0,#?V0 + 0
   \   00038B   79..         MOV     R1,#?V0 + 4
   \   00038D   12....       LCALL   ?FLT_MUL
   \   000390   AA..         MOV     R2,?V0 + 0
   \   000392   AB..         MOV     R3,?V0 + 1
   \   000394   AC..         MOV     R4,?V0 + 2
   \   000396   AD..         MOV     R5,?V0 + 3
   \   000398   12....       LCALL   ??atan2?relay
   \   00039B   7404         MOV     A,#0x4
   \   00039D   12....       LCALL   ?DEALLOC_XSTACK8
   \   0003A0   8A..         MOV     ?V0 + 0,R2
   \   0003A2   8B..         MOV     ?V0 + 1,R3
   \   0003A4   8C..         MOV     ?V0 + 2,R4
   \   0003A6   8D..         MOV     ?V0 + 3,R5
   \   0003A8   90....       MOV     DPTR,#__Constant_42653333
   \   0003AB   78..         MOV     R0,#?V0 + 4
   \   0003AD   12....       LCALL   ?L_MOV_X
   \   0003B0   78..         MOV     R0,#?V0 + 0
   \   0003B2   79..         MOV     R1,#?V0 + 4
   \   0003B4   12....       LCALL   ?FLT_MUL
   \   0003B7   744F         MOV     A,#0x4f
   \   0003B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BC   E0           MOVX    A,@DPTR
   \   0003BD   F8           MOV     R0,A
   \   0003BE   A3           INC     DPTR
   \   0003BF   E0           MOVX    A,@DPTR
   \   0003C0   F583         MOV     DPH,A
   \   0003C2   8882         MOV     DPL,R0
   \   0003C4   78..         MOV     R0,#?V0 + 0
   \   0003C6   12....       LCALL   ?L_MOV_TO_X
   3008          	}else return 2;
   3009          	return 0;
   \   0003C9   7900         MOV     R1,#0x0
   \   0003CB   8002         SJMP    ??mpu_dmp_get_data_1
   \                     ??mpu_dmp_get_data_2:
   \   0003CD   7902         MOV     R1,#0x2
   \                     ??mpu_dmp_get_data_1:
   \   0003CF   7437         MOV     A,#0x37
   \   0003D1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0003D4   7F10         MOV     R7,#0x10
   \   0003D6   02....       LJMP    ?BANKED_LEAVE_XDATA
   3010          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for st>`:
   \   000000   ....         DW reg
   \   000002   ....         DW hw
   \   000004   00           DB 0
   \   000005   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00000D   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000015   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001D   00000000     DB 0, 0, 0, 0
   \   000021   ....         DW test

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gyro_orientation>`:
   \   000000   01           DB 1
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   01           DB 1
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   01           DB 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??set_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    set_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reg_dump?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reg_dump

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_accel_mode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_accel_mode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_temperature?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_temperature

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_bias?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_bias

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reset_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reset_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_fifo_config?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_fifo_config

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_configure_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_configure_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_power_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_power_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sensors?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sensors

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_int_status?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_int_status

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo_stream?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo_stream

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_bypass?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_bypass

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_level?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_level

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_latched?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_latched

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_accel_prod_shift?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_accel_prod_shift

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??accel_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    accel_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gyro_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gyro_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_st_biases?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_st_biases

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_write_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_write_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_load_firmware?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_load_firmware

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??setup_compass?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    setup_compass

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_motion_interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_motion_interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_orientation_matrix_to_scalar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_orientation_matrix_to_scalar

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_row_2_scale?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_row_2_scale

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mget_ms?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mget_ms

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_dmp_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_dmp_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_dmp_get_data?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_dmp_get_data

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%#5x: %#5x\\r\\n">`:
   \   000000   25233578     DB "%#5x: %#5x\015\012"
   \            3A202523
   \            35780D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Unsupported software ...">`:
   \   000000   556E7375     DB "Unsupported software product rev %d.\012"
   \            70706F72
   \            74656420
   \            736F6674
   \            77617265
   \            2070726F
   \            64756374
   \            20726576
   \            2025642E
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Product ID read as 0 ...">`:
   \   000000   50726F64     DB 50H, 72H, 6FH, 64H, 75H, 63H, 74H, 20H
   \            75637420
   \   000008   49442072     DB 49H, 44H, 20H, 72H, 65H, 61H, 64H, 20H
   \            65616420
   \   000010   61732030     DB 61H, 73H, 20H, 30H, 20H, 69H, 6EH, 64H
   \            20696E64
   \   000018   69636174     DB 69H, 63H, 61H, 74H, 65H, 73H, 20H, 64H
   \            65732064
   \   000020   65766963     DB 65H, 76H, 69H, 63H, 65H, 20H, 69H, 73H
   \            65206973
   \   000028   20656974     DB 20H, 65H, 69H, 74H, 68H, 65H, 72H, 20H
   \            68657220
   \   000030   696E636F     DB 69H, 6EH, 63H, 6FH, 6DH, 70H, 61H, 74H
   \            6D706174
   \   000038   69626C65     DB 69H, 62H, 6CH, 65H, 20H, 6FH, 72H, 20H
   \            206F7220
   \   000040   616E204D     DB 61H, 6EH, 20H, 4DH, 50H, 55H, 33H, 30H
   \            50553330
   \   000048   35302E0A     DB 35H, 30H, 2EH, 0AH, 0
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Half sensitivity part...">`:
   \   000000   48616C66     DB "Half sensitivity part found.\012"
   \            2073656E
   \            73697469
   \            76697479
   \            20706172
   \            7420666F
   \            756E642E
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_64:
   \   000000   64000000     DD 100

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_420c0000:
   \   000000   00000C42     DD 420C0000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_47800000:
   \   000000   00008047     DD 47800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_32:
   \   000000   32000000     DD 50

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_43030000:
   \   000000   00000343     DD 43030000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42830000:
   \   000000   00008342     DD 42830000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42033333:
   \   000000   33330342     DD 42033333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41833333:
   \   000000   33338341     DD 41833333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3:
   \   000000   03000000     DD 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f845a1d:
   \   000000   1D5A843F     DD 3F845A1DH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3eae147b:
   \   000000   7B14AE3E     DD 3EAE147BH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e99999a:
   \   000000   9A99993E     DD 3E99999AH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f733334:
   \   000000   3433733F     DD 3F733334H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_37800000:
   \   000000   00008037     DD 37800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_bf800000:
   \   000000   000080BF     DD 0BF800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e0f5c2a:
   \   000000   2A5C0F3E     DD 3E0F5C2AH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41200000:
   \   000000   00002041     DD 41200000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42d20001:
   \   000000   0100D242     DD 42D20001H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41c80000:
   \   000000   0000C841     DD 41C80000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f85e354:
   \   000000   54E3853F     DD 3F85E354H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_c8:
   \   000000   C8000000     DD 200

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_f:
   \   000000   0F000000     DD 15

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_83:
   \   000000   83000000     DD 131

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffff0000:
   \   000000   0000FFFF     DD -65536

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_10000:
   \   000000   00000100     DD 65536

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_5:
   \   000000   05000000     DD 5

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_30800000:
   \   000000   00008030     DD 30800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_40000000:
   \   000000   00000040     DD 40000000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_c0000000:
   \   000000   000000C0     DD 0C0000000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42653333:
   \   000000   33336542     DD 42653333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f800000:
   \   000000   0000803F     DD 3F800000H
   3011          
   3012          
   3013          
   3014          
   3015          
   3016          
   3017          
   3018          
   3019          
   3020          
   3021          
   3022          
   3023          
   3024          
   3025          
   3026          
   3027          
   3028          
   3029          
   3030          
   3031          
   3032          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     accel_self_test                    0      0     86
       -> get_accel_prod_shift          0      0     76
       -> labs                          0      0     76
     get_accel_prod_shift               1      0     67
       -> MPU_Read_Len                  0      0     58
     get_st_biases                      2      0    103
       -> MPU_Write_Len                 0      0    110
       -> delay_ms                      0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> delay_ms                      0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> delay_ms                      0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Write_Len                 0      0    110
       -> delay_ms                      0      0    110
       -> MPU_Write_Len                 0      0    110
       -> MPU_Read_Len                  0      0    110
       -> MPU_Read_Len                  0      0    110
     gyro_self_test                     0      0     77
       -> MPU_Read_Len                  0      0     58
       -> labs                          0      0     58
     inv_orientation_matrix_to_scalar
                                        0      0     22
       -> inv_row_2_scale               0      0     24
       -> inv_row_2_scale               0      0     24
       -> inv_row_2_scale               0      0     24
     inv_row_2_scale                    2      0     12
     mget_ms                            0      0     36
     mpu_configure_fifo                 0      0     60
       -> set_int_enable                0      0     24
       -> set_int_enable                0      0     24
       -> mpu_reset_fifo                0      0     24
     mpu_dmp_get_data                   4      0     89
       -> dmp_read_fifo                 0      0    174
       -> asin                          0      0    158
       -> atan2                         0      0    166
       -> atan2                         0      0    166
     mpu_dmp_init                       0      0     10
       -> MPU_IIC_Init                  0      0     20
       -> mpu_init                      0      0     20
       -> mpu_set_sensors               0      0     20
       -> mpu_configure_fifo            0      0     20
       -> mpu_set_sample_rate           0      0     20
       -> dmp_load_motion_driver_firmware
                                        0      0     20
       -> inv_orientation_matrix_to_scalar
                                        0      0     20
       -> dmp_set_orientation           0      0     20
       -> dmp_enable_feature            0      0     20
       -> dmp_set_fifo_rate             0      0     20
       -> mpu_set_dmp_state             0      0     20
     mpu_get_accel_fsr                  3      0     48
     mpu_get_accel_reg                  0      0     16
       -> MPU_Read_Len                  0      0     32
       -> mget_ms                       0      0     32
     mpu_get_accel_sens                 2      0     46
     mpu_get_compass_fsr                0      0      0
     mpu_get_compass_reg                0      0      0
     mpu_get_compass_sample_rate        2      0      0
     mpu_get_dmp_state                  3      0      0
     mpu_get_fifo_config                3      0     48
     mpu_get_gyro_fsr                   2      0     48
     mpu_get_gyro_reg                   0      0     16
       -> MPU_Read_Len                  0      0     32
       -> mget_ms                       0      0     32
     mpu_get_gyro_sens                  0      0     55
     mpu_get_int_status                 0      0     11
       -> MPU_Read_Len                  0      0     22
     mpu_get_lpf                        2      0     48
     mpu_get_power_state                2      0      0
     mpu_get_sample_rate                2      0     48
     mpu_get_temperature                0      0     22
       -> MPU_Read_Len                  0      0     44
       -> mget_ms                       0      0     44
     mpu_init                           0      0     28
       -> MPU_Write_Len                 0      0     32
       -> delay_ms                      0      0     32
       -> MPU_Write_Len                 0      0     32
       -> MPU_Read_Len                  0      0     32
       -> printf                        0      0     36
       -> MPU_Read_Len                  0      0     32
       -> printf                        0      0     32
       -> printf                        0      0     32
       -> memset                        0      0     36
       -> mpu_set_gyro_fsr              0      0     32
       -> mpu_set_accel_fsr             0      0     32
       -> mpu_set_lpf                   0      0     32
       -> mpu_set_sample_rate           0      0     32
       -> mpu_configure_fifo            0      0     32
       -> mpu_set_bypass                0      0     32
       -> mpu_set_sensors               0      0     32
     mpu_load_firmware                  1      0     46
       -> mpu_write_mem                 0      0     84
       -> mpu_read_mem                  0      0     84
       -> memcmp                        0      0     84
       -> MPU_Write_Len                 0      0     80
     mpu_lp_accel_mode                  1      0     24
       -> mpu_set_int_latched           0      0     22
       -> MPU_Write_Len                 0      0     22
       -> mpu_set_int_latched           0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> MPU_Write_Len                 0      0     22
       -> mpu_configure_fifo            0      0     22
     mpu_lp_motion_interrupt            1      0     13
       -> mpu_set_dmp_state             0      0     26
       -> mpu_get_gyro_fsr              0      0     26
       -> mpu_get_accel_fsr             0      0     26
       -> mpu_get_lpf                   0      0     26
       -> mpu_get_sample_rate           0      0     26
       -> mpu_get_fifo_config           0      0     26
       -> set_int_enable                0      0     26
       -> mpu_lp_accel_mode             0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> delay_ms                      0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> mpu_set_sensors               0      0     26
       -> mpu_set_gyro_fsr              0      0     26
       -> mpu_set_accel_fsr             0      0     26
       -> mpu_set_lpf                   0      0     26
       -> mpu_set_sample_rate           0      0     26
       -> mpu_configure_fifo            0      0     26
       -> mpu_set_dmp_state             0      0     26
     mpu_read_fifo                      1      0     42
       -> MPU_Read_Len                  0      0     72
       -> MPU_Read_Len                  0      0     72
       -> mpu_reset_fifo                0      0     72
       -> mget_ms                       0      0     72
       -> MPU_Read_Len                  0      0     72
     mpu_read_fifo_stream               1      0     20
       -> MPU_Read_Len                  0      0     36
       -> MPU_Read_Len                  0      0     36
       -> mpu_reset_fifo                0      0     36
       -> MPU_Read_Len                  0      0     36
     mpu_read_mem                       2      0     56
       -> MPU_Write_Len                 0      0     28
       -> MPU_Read_Len                  0      0     28
     mpu_read_reg                       0      0      9
       -> MPU_Read_Len                  0      0     18
     mpu_reg_dump                       0      0     15
       -> printf                        0      0     30
       -> MPU_Read_Len                  0      0     22
     mpu_reset_fifo                     2      0     37
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> delay_ms                      4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> delay_ms                      4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
     mpu_run_self_test                  0      0     94
       -> mpu_set_dmp_state             0      0     96
       -> mpu_get_gyro_fsr              0      0     96
       -> mpu_get_accel_fsr             0      0     96
       -> mpu_get_lpf                   0      0     96
       -> mpu_get_sample_rate           0      0     96
       -> mpu_get_fifo_config           0      0     96
       -> get_st_biases                 0      0     96
       -> get_st_biases                 0      0     96
       -> accel_self_test               0      0     96
       -> gyro_self_test                0      0     96
       -> mpu_set_gyro_fsr              0      0     96
       -> mpu_set_accel_fsr             0      0     96
       -> mpu_set_lpf                   0      0     96
       -> mpu_set_sample_rate           0      0     96
       -> mpu_set_sensors               0      0     96
       -> mpu_configure_fifo            0      0     96
       -> mpu_set_dmp_state             0      0     96
     mpu_set_accel_bias                 1      0     40
       -> MPU_Read_Len                  0      0     80
       -> MPU_Read_Len                  0      0     80
       -> MPU_Write_Len                 0      0     80
     mpu_set_accel_fsr                  0      0     58
       -> MPU_Write_Len                 0      0     20
     mpu_set_bypass                     0      0     26
       -> MPU_Read_Len                  0      0     20
       -> MPU_Write_Len                 0      0     20
       -> delay_ms                      0      0     20
       -> MPU_Write_Len                 0      0     20
       -> MPU_Read_Len                  0      0     20
       -> MPU_Write_Len                 0      0     20
       -> delay_ms                      0      0     20
       -> MPU_Write_Len                 0      0     20
     mpu_set_compass_sample_rate        0      0      0
     mpu_set_dmp_state                  1      0     58
       -> set_int_enable                0      0     20
       -> mpu_set_bypass                0      0     20
       -> mpu_set_sample_rate           0      0     20
       -> MPU_Write_Len                 0      0     20
       -> set_int_enable                0      0     20
       -> mpu_reset_fifo                0      0     20
       -> set_int_enable                0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_reset_fifo                0      0     20
     mpu_set_gyro_fsr                   0      0     59
       -> MPU_Write_Len                 0      0     22
     mpu_set_int_latched                0      0     21
       -> MPU_Write_Len                 0      0     20
     mpu_set_int_level                  2      0      0
     mpu_set_lpf                        2      0     49
       -> MPU_Write_Len                 4      0      2
     mpu_set_sample_rate                1      0     58
       -> mpu_lp_accel_mode             0      0     20
       -> mpu_lp_accel_mode             0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_set_lpf                   0      0     20
     mpu_set_sensors                    0      0     58
       -> MPU_Write_Len                 0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_set_int_latched           0      0     20
       -> delay_ms                      0      0     20
     mpu_write_mem                      2      0     56
       -> MPU_Write_Len                 0      0     28
       -> MPU_Write_Len                 0      0     28
     run_self_test                      0      0     46
       -> mpu_run_self_test             0      0     92
       -> mpu_get_gyro_sens             0      0     92
       -> dmp_set_gyro_bias             0      0     92
       -> mpu_get_accel_sens            0      0     92
       -> dmp_set_accel_bias            0      0     92
     set_int_enable                     0      0     23
       -> MPU_Write_Len                 0      0     20
       -> MPU_Write_Len                 0      0     20
     setup_compass                      0      0      0


   Segment part sizes:

     Function/Label                           Bytes
     --------------                           -----
     reg                                        27
     hw                                         10
     test                                       39
     st                                         35
     set_int_enable                            182
     mpu_reg_dump                              159
     mpu_read_reg                              103
     mpu_init                                  553
     mpu_lp_accel_mode                         287
     mpu_get_gyro_reg                          179
     mpu_get_accel_reg                         179
     mpu_get_temperature                       264
     mpu_set_accel_bias                        696
     mpu_reset_fifo                            704
     mpu_get_gyro_fsr                           87
     mpu_set_gyro_fsr                          189
     mpu_get_accel_fsr                          83
     mpu_set_accel_fsr                         180
     mpu_get_lpf                                98
     mpu_set_lpf                               205
     mpu_get_sample_rate                        44
     mpu_set_sample_rate                       214
     mpu_get_compass_sample_rate                23
     mpu_set_compass_sample_rate                 7
     mpu_get_gyro_sens                          69
     mpu_get_accel_sens                        109
     mpu_get_fifo_config                        24
     mpu_configure_fifo                        111
     mpu_get_power_state                        31
     mpu_set_sensors                           242
     mpu_get_int_status                        111
     mpu_read_fifo                             730
     mpu_read_fifo_stream                      315
     mpu_set_bypass                            446
     mpu_set_int_level                          20
     mpu_set_int_latched                       140
     get_accel_prod_shift                      306
     accel_self_test                           374
     gyro_self_test                            406
     get_st_biases                            2042
     mpu_run_self_test                         399
     mpu_write_mem                             214
     mpu_read_mem                              214
     mpu_load_firmware                         334
     mpu_set_dmp_state                         161
     mpu_get_dmp_state                          24
     setup_compass                               7
     mpu_get_compass_reg                         7
     mpu_get_compass_fsr                         7
     mpu_lp_motion_interrupt                   704
     gyro_orientation                            9
     run_self_test                             303
     inv_orientation_matrix_to_scalar
                                                90
     inv_row_2_scale                           120
     mget_ms                                     3
     mpu_dmp_init                              134
     mpu_dmp_get_data                          985
     ?<Initializer for st>                      35
     ?<Initializer for gyro_orientation>         9
     ??set_int_enable?relay                      6
     ??mpu_reg_dump?relay                        6
     ??mpu_read_reg?relay                        6
     ??mpu_init?relay                            6
     ??mpu_lp_accel_mode?relay                   6
     ??mpu_get_gyro_reg?relay                    6
     ??mpu_get_accel_reg?relay                   6
     ??mpu_get_temperature?relay                 6
     ??mpu_set_accel_bias?relay                  6
     ??mpu_reset_fifo?relay                      6
     ??mpu_get_gyro_fsr?relay                    6
     ??mpu_set_gyro_fsr?relay                    6
     ??mpu_get_accel_fsr?relay                   6
     ??mpu_set_accel_fsr?relay                   6
     ??mpu_get_lpf?relay                         6
     ??mpu_set_lpf?relay                         6
     ??mpu_get_sample_rate?relay                 6
     ??mpu_set_sample_rate?relay                 6
     ??mpu_get_compass_sample_rate?relay         6
     ??mpu_set_compass_sample_rate?relay         6
     ??mpu_get_gyro_sens?relay                   6
     ??mpu_get_accel_sens?relay                  6
     ??mpu_get_fifo_config?relay                 6
     ??mpu_configure_fifo?relay                  6
     ??mpu_get_power_state?relay                 6
     ??mpu_set_sensors?relay                     6
     ??mpu_get_int_status?relay                  6
     ??mpu_read_fifo?relay                       6
     ??mpu_read_fifo_stream?relay                6
     ??mpu_set_bypass?relay                      6
     ??mpu_set_int_level?relay                   6
     ??mpu_set_int_latched?relay                 6
     ??get_accel_prod_shift?relay                6
     ??accel_self_test?relay                     6
     ??gyro_self_test?relay                      6
     ??get_st_biases?relay                       6
     ??mpu_run_self_test?relay                   6
     ??mpu_write_mem?relay                       6
     ??mpu_read_mem?relay                        6
     ??mpu_load_firmware?relay                   6
     ??mpu_set_dmp_state?relay                   6
     ??mpu_get_dmp_state?relay                   6
     ??setup_compass?relay                       6
     ??mpu_get_compass_reg?relay                 6
     ??mpu_get_compass_fsr?relay                 6
     ??mpu_lp_motion_interrupt?relay             6
     ??run_self_test?relay                       6
     ??inv_orientation_matrix_to_scalar?relay    6
     ??inv_row_2_scale?relay                     6
     ??mget_ms?relay                             6
     ??mpu_dmp_init?relay                        6
     ??mpu_dmp_get_data?relay                    6
     ?<Constant "%#5x: %#5x\r\n">               13
     ?<Constant "Unsupported software ...">     38
     ?<Constant "Product ID read as 0 ...">     77
     ?<Constant "Half sensitivity part...">     30
     __Constant_64                               4
     __Constant_420c0000                         4
     __Constant_47800000                         4
     __Constant_32                               4
     __Constant_43030000                         4
     __Constant_42830000                         4
     __Constant_42033333                         4
     __Constant_41833333                         4
     __Constant_3                                4
     __Constant_3f845a1d                         4
     __Constant_0                                4
     __Constant_3eae147b                         4
     __Constant_3e99999a                         4
     __Constant_3f733334                         4
     __Constant_37800000                         4
     __Constant_bf800000                         4
     __Constant_3e0f5c2a                         4
     __Constant_41200000                         4
     __Constant_42d20001                         4
     __Constant_41c80000                         4
     __Constant_3f85e354                         4
     __Constant_c8                               4
     __Constant_f                                4
     __Constant_83                               4
     __Constant_1                                4
     __Constant_ffff0000                         4
     __Constant_10000                            4
     __Constant_5                                4
     __Constant_30800000                         4
     __Constant_40000000                         4
     __Constant_c0000000                         4
     __Constant_42653333                         4
     __Constant_3f800000                         4

 
 13 618 bytes in segment BANKED_CODE
    312 bytes in segment BANK_RELAYS
     44 bytes in segment XDATA_I
     44 bytes in segment XDATA_ID
    366 bytes in segment XDATA_ROM_C
 
 13 974 bytes of CODE  memory
    234 bytes of CONST memory (+ 132 bytes shared)
     44 bytes of XDATA memory

Errors: none
Warnings: none
