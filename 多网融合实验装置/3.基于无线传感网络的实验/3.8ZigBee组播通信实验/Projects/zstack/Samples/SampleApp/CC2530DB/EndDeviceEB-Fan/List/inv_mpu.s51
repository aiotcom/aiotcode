///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.3.10338/W32 for 8051        01/Mar/2019  15:06:15 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Components\HARDWARE\MPU6050\eMPL\inv_mpu.c        /
//    Command line       =  -f D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-gro /
//                          up\Projects\zstack\Samples\SampleApp\CC2530DB\..\ /
//                          ..\..\Tools\CC2530DB\f8wEndev.cfg (-DCPU32MHZ     /
//                          -DROOT=__near_func -DBLINK_LEDS) -f               /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\Tools\CC2530DB\f8wConfig.cfg (-DSECURE=0       /
//                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                 /
//                          -DDEFAULT_CHANLIST=0x00000800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFF11                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          "-DCONST=const __code" -DGENERIC=__generic        /
//                          -DRFD_RCVC_ALWAYS_ON=TRUE -DPOLL_RATE=1000        /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)  /
//                          -DREJOIN_POLL_RATE=440 D:\ZigBee\KJXY-ZigBee\KJXY /
//                          -ZigBeeV2.0\exp9-group\Components\HARDWARE\MPU605 /
//                          0\eMPL\inv_mpu.c -D NWK_AUTO_POLL -D ZTOOL_P1 -D  /
//                          MT_SYS_FUNC -D MT_ZDO_FUNC -D                     /
//                          LCD_SUPPORTED=DEBUG -lC                           /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\EndDev /
//                          iceEB-Fan\List\ -lA D:\ZigBee\KJXY-ZigBee\KJXY-Zi /
//                          gBeeV2.0\exp9-group\Projects\zstack\Samples\Sampl /
//                          eApp\CC2530DB\EndDeviceEB-Fan\List\               /
//                          --diag_suppress Pe001,Pa010 -o                    /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\EndDev /
//                          iceEB-Fan\Obj\ -e --no_unroll --no_inline         /
//                          --no_tbaa --debug --core=plain --dptr=16,1        /
//                          --data_model=large --code_model=banked            /
//                          --calling_convention=xdata_reentrant              /
//                          --place_constants=data_rom --nr_virtual_regs 16   /
//                          -I D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-gro /
//                          up\Projects\zstack\Samples\SampleApp\CC2530DB\    /
//                          -I D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-gro /
//                          up\Projects\zstack\Samples\SampleApp\CC2530DB\..\ /
//                          SOURCE\ -I D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\ /
//                          exp9-group\Projects\zstack\Samples\SampleApp\CC25 /
//                          30DB\..\..\..\ZMAIN\TI2530DB\ -I                  /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\MT\ -I                        /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\HAL\INCLUDE\ -I               /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\ -I       /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\OSAL\MCU\CCSOC\ -I            /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\OSAL\INCLUDE\ -I              /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\STACK\AF\ -I                  /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\STACK\NWK\ -I                 /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\STACK\SEC\ -I                 /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\STACK\SAPI\ -I                /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\STACK\SYS\ -I                 /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\STACK\ZDO\ -I                 /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\ZMAC\F8W\ -I                  /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\ZMAC\ -I                      /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\SERVICES\SADDR\ -I            /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\SERVICES\SDATA\ -I            /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\MAC\INCLUDE\ -I               /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\MAC\HIGH_LEVEL\ -I            /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\ -I       /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CH /
//                          IP\ -I D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9 /
//                          -group\Projects\zstack\Samples\SampleApp\CC2530DB /
//                          \..\..\..\..\..\COMPONENTS\HARDWARE\ -I           /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\HARDWARE\MPU6050\ -I          /
//                          D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ /
//                          ..\..\..\COMPONENTS\HARDWARE\MPU6050\eMPL\ -Om    /
//    List file          =  D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\ /
//                          Projects\zstack\Samples\SampleApp\CC2530DB\EndDev /
//                          iceEB-Fan\List\inv_mpu.s51                        /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME inv_mpu

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FLT_ADD
        EXTERN ?FLT_DIV
        EXTERN ?FLT_EQ
        EXTERN ?FLT_GE
        EXTERN ?FLT_LT
        EXTERN ?FLT_MUL
        EXTERN ?FLT_SUB
        EXTERN ?FLT_TO_L
        EXTERN ?L_ADD_TO_X
        EXTERN ?L_DIV_MOD
        EXTERN ?L_MOV_TO_X
        EXTERN ?L_MOV_X
        EXTERN ?L_SHL
        EXTERN ?L_SUB_X
        EXTERN ?L_TO_FLT
        EXTERN ?PUSH_XSTACK_I_FOUR
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?SL_GT_X
        EXTERN ?SS_SHR
        EXTERN ?S_DIV_MOD
        EXTERN ?S_SHL
        EXTERN ?UL_DIV_MOD
        EXTERN ?UL_SHR
        EXTERN ?UL_TO_FLT
        EXTERN ?US_DIV_MOD
        EXTERN ?US_SHR
        EXTERN ?US_SWITCH_SPARSE
        EXTERN ?V0
        EXTERN ?XLOAD_R2345
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTORE_R2345
        EXTERN __INIT_XDATA_I

        FUNCTION ??accel_self_test?relay,0203H
        FUNCTION ??get_accel_prod_shift?relay,0203H
        FUNCTION ??get_st_biases?relay,0203H
        FUNCTION ??gyro_self_test?relay,0203H
        PUBLIC ??inv_orientation_matrix_to_scalar?relay
        FUNCTION ??inv_orientation_matrix_to_scalar?relay,0203H
        PUBLIC ??inv_row_2_scale?relay
        FUNCTION ??inv_row_2_scale?relay,0203H
        PUBLIC ??mget_ms?relay
        FUNCTION ??mget_ms?relay,0203H
        PUBLIC ??mpu_configure_fifo?relay
        FUNCTION ??mpu_configure_fifo?relay,0203H
        PUBLIC ??mpu_dmp_get_data?relay
        FUNCTION ??mpu_dmp_get_data?relay,0203H
        PUBLIC ??mpu_dmp_init?relay
        FUNCTION ??mpu_dmp_init?relay,0203H
        PUBLIC ??mpu_get_accel_fsr?relay
        FUNCTION ??mpu_get_accel_fsr?relay,0203H
        PUBLIC ??mpu_get_accel_reg?relay
        FUNCTION ??mpu_get_accel_reg?relay,0203H
        PUBLIC ??mpu_get_accel_sens?relay
        FUNCTION ??mpu_get_accel_sens?relay,0203H
        PUBLIC ??mpu_get_compass_fsr?relay
        FUNCTION ??mpu_get_compass_fsr?relay,0203H
        PUBLIC ??mpu_get_compass_reg?relay
        FUNCTION ??mpu_get_compass_reg?relay,0203H
        PUBLIC ??mpu_get_compass_sample_rate?relay
        FUNCTION ??mpu_get_compass_sample_rate?relay,0203H
        PUBLIC ??mpu_get_dmp_state?relay
        FUNCTION ??mpu_get_dmp_state?relay,0203H
        PUBLIC ??mpu_get_fifo_config?relay
        FUNCTION ??mpu_get_fifo_config?relay,0203H
        PUBLIC ??mpu_get_gyro_fsr?relay
        FUNCTION ??mpu_get_gyro_fsr?relay,0203H
        PUBLIC ??mpu_get_gyro_reg?relay
        FUNCTION ??mpu_get_gyro_reg?relay,0203H
        PUBLIC ??mpu_get_gyro_sens?relay
        FUNCTION ??mpu_get_gyro_sens?relay,0203H
        PUBLIC ??mpu_get_int_status?relay
        FUNCTION ??mpu_get_int_status?relay,0203H
        PUBLIC ??mpu_get_lpf?relay
        FUNCTION ??mpu_get_lpf?relay,0203H
        PUBLIC ??mpu_get_power_state?relay
        FUNCTION ??mpu_get_power_state?relay,0203H
        PUBLIC ??mpu_get_sample_rate?relay
        FUNCTION ??mpu_get_sample_rate?relay,0203H
        PUBLIC ??mpu_get_temperature?relay
        FUNCTION ??mpu_get_temperature?relay,0203H
        PUBLIC ??mpu_init?relay
        FUNCTION ??mpu_init?relay,0203H
        PUBLIC ??mpu_load_firmware?relay
        FUNCTION ??mpu_load_firmware?relay,0203H
        PUBLIC ??mpu_lp_accel_mode?relay
        FUNCTION ??mpu_lp_accel_mode?relay,0203H
        PUBLIC ??mpu_lp_motion_interrupt?relay
        FUNCTION ??mpu_lp_motion_interrupt?relay,0203H
        PUBLIC ??mpu_read_fifo?relay
        FUNCTION ??mpu_read_fifo?relay,0203H
        PUBLIC ??mpu_read_fifo_stream?relay
        FUNCTION ??mpu_read_fifo_stream?relay,0203H
        PUBLIC ??mpu_read_mem?relay
        FUNCTION ??mpu_read_mem?relay,0203H
        PUBLIC ??mpu_read_reg?relay
        FUNCTION ??mpu_read_reg?relay,0203H
        PUBLIC ??mpu_reg_dump?relay
        FUNCTION ??mpu_reg_dump?relay,0203H
        PUBLIC ??mpu_reset_fifo?relay
        FUNCTION ??mpu_reset_fifo?relay,0203H
        PUBLIC ??mpu_run_self_test?relay
        FUNCTION ??mpu_run_self_test?relay,0203H
        PUBLIC ??mpu_set_accel_bias?relay
        FUNCTION ??mpu_set_accel_bias?relay,0203H
        PUBLIC ??mpu_set_accel_fsr?relay
        FUNCTION ??mpu_set_accel_fsr?relay,0203H
        PUBLIC ??mpu_set_bypass?relay
        FUNCTION ??mpu_set_bypass?relay,0203H
        PUBLIC ??mpu_set_compass_sample_rate?relay
        FUNCTION ??mpu_set_compass_sample_rate?relay,0203H
        PUBLIC ??mpu_set_dmp_state?relay
        FUNCTION ??mpu_set_dmp_state?relay,0203H
        PUBLIC ??mpu_set_gyro_fsr?relay
        FUNCTION ??mpu_set_gyro_fsr?relay,0203H
        PUBLIC ??mpu_set_int_latched?relay
        FUNCTION ??mpu_set_int_latched?relay,0203H
        PUBLIC ??mpu_set_int_level?relay
        FUNCTION ??mpu_set_int_level?relay,0203H
        PUBLIC ??mpu_set_lpf?relay
        FUNCTION ??mpu_set_lpf?relay,0203H
        PUBLIC ??mpu_set_sample_rate?relay
        FUNCTION ??mpu_set_sample_rate?relay,0203H
        PUBLIC ??mpu_set_sensors?relay
        FUNCTION ??mpu_set_sensors?relay,0203H
        PUBLIC ??mpu_write_mem?relay
        FUNCTION ??mpu_write_mem?relay,0203H
        PUBLIC ??run_self_test?relay
        FUNCTION ??run_self_test?relay,0203H
        FUNCTION ??set_int_enable?relay,0203H
        PUBLIC ??setup_compass?relay
        FUNCTION ??setup_compass?relay,0203H
        PUBWEAK __Constant_0
        PUBWEAK __Constant_1
        PUBWEAK __Constant_10000
        PUBWEAK __Constant_3
        PUBWEAK __Constant_30800000
        PUBWEAK __Constant_32
        PUBWEAK __Constant_37800000
        PUBWEAK __Constant_3e0f5c2a
        PUBWEAK __Constant_3e99999a
        PUBWEAK __Constant_3eae147b
        PUBWEAK __Constant_3f733334
        PUBWEAK __Constant_3f800000
        PUBWEAK __Constant_3f845a1d
        PUBWEAK __Constant_3f85e354
        PUBWEAK __Constant_40000000
        PUBWEAK __Constant_41200000
        PUBWEAK __Constant_41833333
        PUBWEAK __Constant_41c80000
        PUBWEAK __Constant_42033333
        PUBWEAK __Constant_420c0000
        PUBWEAK __Constant_42653333
        PUBWEAK __Constant_42830000
        PUBWEAK __Constant_42d20001
        PUBWEAK __Constant_43030000
        PUBWEAK __Constant_47800000
        PUBWEAK __Constant_5
        PUBWEAK __Constant_64
        PUBWEAK __Constant_83
        PUBWEAK __Constant_bf800000
        PUBWEAK __Constant_c0000000
        PUBWEAK __Constant_c8
        PUBWEAK __Constant_f
        PUBWEAK __Constant_ffff0000
        FUNCTION accel_self_test,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 38, STACK
        FUNCTION get_accel_prod_shift,021203H
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 29, STACK
        FUNCTION get_st_biases,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 55, STACK
        FUNCTION gyro_self_test,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 29, STACK
        PUBLIC hw
        PUBLIC inv_orientation_matrix_to_scalar
        FUNCTION inv_orientation_matrix_to_scalar,021203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBLIC inv_row_2_scale
        FUNCTION inv_row_2_scale,0203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mget_ms
        FUNCTION mget_ms,0203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUBLIC mpu_configure_fifo
        FUNCTION mpu_configure_fifo,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBLIC mpu_dmp_get_data
        FUNCTION mpu_dmp_get_data,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME ISTACK, 4, STACK
        LOCFRAME XSTACK, 87, STACK
        PUBLIC mpu_dmp_init
        FUNCTION mpu_dmp_init,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_get_accel_fsr
        FUNCTION mpu_get_accel_fsr,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        PUBLIC mpu_get_accel_reg
        FUNCTION mpu_get_accel_reg,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC mpu_get_accel_sens
        FUNCTION mpu_get_accel_sens,0203H
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_compass_fsr
        FUNCTION mpu_get_compass_fsr,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC mpu_get_compass_reg
        FUNCTION mpu_get_compass_reg,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC mpu_get_compass_sample_rate
        FUNCTION mpu_get_compass_sample_rate,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_dmp_state
        FUNCTION mpu_get_dmp_state,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 3, STACK
        PUBLIC mpu_get_fifo_config
        FUNCTION mpu_get_fifo_config,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        PUBLIC mpu_get_gyro_fsr
        FUNCTION mpu_get_gyro_fsr,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_gyro_reg
        FUNCTION mpu_get_gyro_reg,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC mpu_get_gyro_sens
        FUNCTION mpu_get_gyro_sens,0203H
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        PUBLIC mpu_get_int_status
        FUNCTION mpu_get_int_status,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC mpu_get_lpf
        FUNCTION mpu_get_lpf,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_power_state
        FUNCTION mpu_get_power_state,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_sample_rate
        FUNCTION mpu_get_sample_rate,0203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_get_temperature
        FUNCTION mpu_get_temperature,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        PUBLIC mpu_init
        FUNCTION mpu_init,021203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 18, STACK
        PUBLIC mpu_load_firmware
        FUNCTION mpu_load_firmware,021203H
        ARGFRAME XSTACK, 4, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 42, STACK
        PUBLIC mpu_lp_accel_mode
        FUNCTION mpu_lp_accel_mode,021203H
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC mpu_lp_motion_interrupt
        FUNCTION mpu_lp_motion_interrupt,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 13, STACK
        PUBLIC mpu_read_fifo
        FUNCTION mpu_read_fifo,021203H
        ARGFRAME XSTACK, 6, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 36, STACK
        PUBLIC mpu_read_fifo_stream
        FUNCTION mpu_read_fifo_stream,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 18, STACK
        PUBLIC mpu_read_mem
        FUNCTION mpu_read_mem,021203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC mpu_read_reg
        FUNCTION mpu_read_reg,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC mpu_reg_dump
        FUNCTION mpu_reg_dump,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        PUBLIC mpu_reset_fifo
        FUNCTION mpu_reset_fifo,021203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 1, STACK
        PUBLIC mpu_run_self_test
        FUNCTION mpu_run_self_test,021203H
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 48, STACK
        PUBLIC mpu_set_accel_bias
        FUNCTION mpu_set_accel_bias,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 40, STACK
        PUBLIC mpu_set_accel_fsr
        FUNCTION mpu_set_accel_fsr,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_bypass
        FUNCTION mpu_set_bypass,021203H
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_compass_sample_rate
        FUNCTION mpu_set_compass_sample_rate,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC mpu_set_dmp_state
        FUNCTION mpu_set_dmp_state,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_gyro_fsr
        FUNCTION mpu_set_gyro_fsr,0a1203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 11, STACK
        PUBLIC mpu_set_int_latched
        FUNCTION mpu_set_int_latched,021203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_int_level
        FUNCTION mpu_set_int_level,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC mpu_set_lpf
        FUNCTION mpu_set_lpf,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 1, STACK
        PUBLIC mpu_set_sample_rate
        FUNCTION mpu_set_sample_rate,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_set_sensors
        FUNCTION mpu_set_sensors,021203H
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC mpu_write_mem
        FUNCTION mpu_write_mem,021203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC reg
        PUBLIC run_self_test
        FUNCTION run_self_test,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        FUNCTION set_int_enable,021203H
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC setup_compass
        FUNCTION setup_compass,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC test
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
MPU_Write_Len       SYMBOL "MPU_Write_Len"
printf              SYMBOL "printf"
MPU_Read_Len        SYMBOL "MPU_Read_Len"
delay_ms            SYMBOL "delay_ms"
memset              SYMBOL "memset"
labs                SYMBOL "labs"
memcmp              SYMBOL "memcmp"
dmp_set_gyro_bias   SYMBOL "dmp_set_gyro_bias"
dmp_set_accel_bias  SYMBOL "dmp_set_accel_bias"
MPU_IIC_Init        SYMBOL "MPU_IIC_Init"
dmp_load_motion_driver_firmware SYMBOL "dmp_load_motion_driver_firmware"
dmp_set_orientation SYMBOL "dmp_set_orientation"
dmp_enable_feature  SYMBOL "dmp_enable_feature"
dmp_set_fifo_rate   SYMBOL "dmp_set_fifo_rate"
dmp_read_fifo       SYMBOL "dmp_read_fifo"
asin                SYMBOL "asin"
atan2               SYMBOL "atan2"
??MPU_IIC_Init?relay SYMBOL "?relay", MPU_IIC_Init
??MPU_Read_Len?relay SYMBOL "?relay", MPU_Read_Len
??MPU_Write_Len?relay SYMBOL "?relay", MPU_Write_Len
??asin?relay        SYMBOL "?relay", asin
??atan2?relay       SYMBOL "?relay", atan2
??delay_ms?relay    SYMBOL "?relay", delay_ms
??dmp_enable_feature?relay SYMBOL "?relay", dmp_enable_feature
??dmp_load_motion_driver_firmware?relay SYMBOL "?relay", dmp_load_motion_driver_firmware
??dmp_read_fifo?relay SYMBOL "?relay", dmp_read_fifo
??dmp_set_accel_bias?relay SYMBOL "?relay", dmp_set_accel_bias
??dmp_set_fifo_rate?relay SYMBOL "?relay", dmp_set_fifo_rate
??dmp_set_gyro_bias?relay SYMBOL "?relay", dmp_set_gyro_bias
??dmp_set_orientation?relay SYMBOL "?relay", dmp_set_orientation
??labs?relay        SYMBOL "?relay", labs
??memcmp?relay      SYMBOL "?relay", memcmp
??memset?relay      SYMBOL "?relay", memset
??printf?relay      SYMBOL "?relay", printf
inv_orientation_matrix_to_scalar SYMBOL "inv_orientation_matrix_to_scalar"
??inv_orientation_matrix_to_scalar?relay SYMBOL "?relay", inv_orientation_matrix_to_scalar
inv_row_2_scale     SYMBOL "inv_row_2_scale"
??inv_row_2_scale?relay SYMBOL "?relay", inv_row_2_scale
mget_ms             SYMBOL "mget_ms"
??mget_ms?relay     SYMBOL "?relay", mget_ms
mpu_configure_fifo  SYMBOL "mpu_configure_fifo"
??mpu_configure_fifo?relay SYMBOL "?relay", mpu_configure_fifo
mpu_dmp_get_data    SYMBOL "mpu_dmp_get_data"
??mpu_dmp_get_data?relay SYMBOL "?relay", mpu_dmp_get_data
mpu_dmp_init        SYMBOL "mpu_dmp_init"
??mpu_dmp_init?relay SYMBOL "?relay", mpu_dmp_init
mpu_get_accel_fsr   SYMBOL "mpu_get_accel_fsr"
??mpu_get_accel_fsr?relay SYMBOL "?relay", mpu_get_accel_fsr
mpu_get_accel_reg   SYMBOL "mpu_get_accel_reg"
??mpu_get_accel_reg?relay SYMBOL "?relay", mpu_get_accel_reg
mpu_get_accel_sens  SYMBOL "mpu_get_accel_sens"
??mpu_get_accel_sens?relay SYMBOL "?relay", mpu_get_accel_sens
mpu_get_compass_fsr SYMBOL "mpu_get_compass_fsr"
??mpu_get_compass_fsr?relay SYMBOL "?relay", mpu_get_compass_fsr
mpu_get_compass_reg SYMBOL "mpu_get_compass_reg"
??mpu_get_compass_reg?relay SYMBOL "?relay", mpu_get_compass_reg
mpu_get_compass_sample_rate SYMBOL "mpu_get_compass_sample_rate"
??mpu_get_compass_sample_rate?relay SYMBOL "?relay", mpu_get_compass_sample_rate
mpu_get_dmp_state   SYMBOL "mpu_get_dmp_state"
??mpu_get_dmp_state?relay SYMBOL "?relay", mpu_get_dmp_state
mpu_get_fifo_config SYMBOL "mpu_get_fifo_config"
??mpu_get_fifo_config?relay SYMBOL "?relay", mpu_get_fifo_config
mpu_get_gyro_fsr    SYMBOL "mpu_get_gyro_fsr"
??mpu_get_gyro_fsr?relay SYMBOL "?relay", mpu_get_gyro_fsr
mpu_get_gyro_reg    SYMBOL "mpu_get_gyro_reg"
??mpu_get_gyro_reg?relay SYMBOL "?relay", mpu_get_gyro_reg
mpu_get_gyro_sens   SYMBOL "mpu_get_gyro_sens"
??mpu_get_gyro_sens?relay SYMBOL "?relay", mpu_get_gyro_sens
mpu_get_int_status  SYMBOL "mpu_get_int_status"
??mpu_get_int_status?relay SYMBOL "?relay", mpu_get_int_status
mpu_get_lpf         SYMBOL "mpu_get_lpf"
??mpu_get_lpf?relay SYMBOL "?relay", mpu_get_lpf
mpu_get_power_state SYMBOL "mpu_get_power_state"
??mpu_get_power_state?relay SYMBOL "?relay", mpu_get_power_state
mpu_get_sample_rate SYMBOL "mpu_get_sample_rate"
??mpu_get_sample_rate?relay SYMBOL "?relay", mpu_get_sample_rate
mpu_get_temperature SYMBOL "mpu_get_temperature"
??mpu_get_temperature?relay SYMBOL "?relay", mpu_get_temperature
mpu_init            SYMBOL "mpu_init"
??mpu_init?relay    SYMBOL "?relay", mpu_init
mpu_load_firmware   SYMBOL "mpu_load_firmware"
??mpu_load_firmware?relay SYMBOL "?relay", mpu_load_firmware
mpu_lp_accel_mode   SYMBOL "mpu_lp_accel_mode"
??mpu_lp_accel_mode?relay SYMBOL "?relay", mpu_lp_accel_mode
mpu_lp_motion_interrupt SYMBOL "mpu_lp_motion_interrupt"
??mpu_lp_motion_interrupt?relay SYMBOL "?relay", mpu_lp_motion_interrupt
mpu_read_fifo       SYMBOL "mpu_read_fifo"
??mpu_read_fifo?relay SYMBOL "?relay", mpu_read_fifo
mpu_read_fifo_stream SYMBOL "mpu_read_fifo_stream"
??mpu_read_fifo_stream?relay SYMBOL "?relay", mpu_read_fifo_stream
mpu_read_mem        SYMBOL "mpu_read_mem"
??mpu_read_mem?relay SYMBOL "?relay", mpu_read_mem
mpu_read_reg        SYMBOL "mpu_read_reg"
??mpu_read_reg?relay SYMBOL "?relay", mpu_read_reg
mpu_reg_dump        SYMBOL "mpu_reg_dump"
??mpu_reg_dump?relay SYMBOL "?relay", mpu_reg_dump
mpu_reset_fifo      SYMBOL "mpu_reset_fifo"
??mpu_reset_fifo?relay SYMBOL "?relay", mpu_reset_fifo
mpu_run_self_test   SYMBOL "mpu_run_self_test"
??mpu_run_self_test?relay SYMBOL "?relay", mpu_run_self_test
mpu_set_accel_bias  SYMBOL "mpu_set_accel_bias"
??mpu_set_accel_bias?relay SYMBOL "?relay", mpu_set_accel_bias
mpu_set_accel_fsr   SYMBOL "mpu_set_accel_fsr"
??mpu_set_accel_fsr?relay SYMBOL "?relay", mpu_set_accel_fsr
mpu_set_bypass      SYMBOL "mpu_set_bypass"
??mpu_set_bypass?relay SYMBOL "?relay", mpu_set_bypass
mpu_set_compass_sample_rate SYMBOL "mpu_set_compass_sample_rate"
??mpu_set_compass_sample_rate?relay SYMBOL "?relay", mpu_set_compass_sample_rate
mpu_set_dmp_state   SYMBOL "mpu_set_dmp_state"
??mpu_set_dmp_state?relay SYMBOL "?relay", mpu_set_dmp_state
mpu_set_gyro_fsr    SYMBOL "mpu_set_gyro_fsr"
??mpu_set_gyro_fsr?relay SYMBOL "?relay", mpu_set_gyro_fsr
mpu_set_int_latched SYMBOL "mpu_set_int_latched"
??mpu_set_int_latched?relay SYMBOL "?relay", mpu_set_int_latched
mpu_set_int_level   SYMBOL "mpu_set_int_level"
??mpu_set_int_level?relay SYMBOL "?relay", mpu_set_int_level
mpu_set_lpf         SYMBOL "mpu_set_lpf"
??mpu_set_lpf?relay SYMBOL "?relay", mpu_set_lpf
mpu_set_sample_rate SYMBOL "mpu_set_sample_rate"
??mpu_set_sample_rate?relay SYMBOL "?relay", mpu_set_sample_rate
mpu_set_sensors     SYMBOL "mpu_set_sensors"
??mpu_set_sensors?relay SYMBOL "?relay", mpu_set_sensors
mpu_write_mem       SYMBOL "mpu_write_mem"
??mpu_write_mem?relay SYMBOL "?relay", mpu_write_mem
run_self_test       SYMBOL "run_self_test"
??run_self_test?relay SYMBOL "?relay", run_self_test
setup_compass       SYMBOL "setup_compass"
??setup_compass?relay SYMBOL "?relay", setup_compass

        EXTERN MPU_Write_Len
        FUNCTION MPU_Write_Len,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN printf
        FUNCTION printf,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN MPU_Read_Len
        FUNCTION MPU_Read_Len,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN delay_ms
        FUNCTION delay_ms,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memset
        FUNCTION memset,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN labs
        FUNCTION labs,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcmp
        FUNCTION memcmp,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_set_gyro_bias
        FUNCTION dmp_set_gyro_bias,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_set_accel_bias
        FUNCTION dmp_set_accel_bias,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN MPU_IIC_Init
        FUNCTION MPU_IIC_Init,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_load_motion_driver_firmware
        FUNCTION dmp_load_motion_driver_firmware,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_set_orientation
        FUNCTION dmp_set_orientation,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_enable_feature
        FUNCTION dmp_enable_feature,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_set_fifo_rate
        FUNCTION dmp_set_fifo_rate,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN dmp_read_fifo
        FUNCTION dmp_read_fifo,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 87, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN asin
        FUNCTION asin,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 79, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN atan2
        FUNCTION atan2,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 83, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??MPU_IIC_Init?relay
        FUNCTION ??MPU_IIC_Init?relay,00H
        EXTERN ??MPU_Read_Len?relay
        FUNCTION ??MPU_Read_Len?relay,00H
        EXTERN ??MPU_Write_Len?relay
        FUNCTION ??MPU_Write_Len?relay,00H
        EXTERN ??asin?relay
        FUNCTION ??asin?relay,00H
        EXTERN ??atan2?relay
        FUNCTION ??atan2?relay,00H
        EXTERN ??delay_ms?relay
        FUNCTION ??delay_ms?relay,00H
        EXTERN ??dmp_enable_feature?relay
        FUNCTION ??dmp_enable_feature?relay,00H
        EXTERN ??dmp_load_motion_driver_firmware?relay
        FUNCTION ??dmp_load_motion_driver_firmware?relay,00H
        EXTERN ??dmp_read_fifo?relay
        FUNCTION ??dmp_read_fifo?relay,00H
        EXTERN ??dmp_set_accel_bias?relay
        FUNCTION ??dmp_set_accel_bias?relay,00H
        EXTERN ??dmp_set_fifo_rate?relay
        FUNCTION ??dmp_set_fifo_rate?relay,00H
        EXTERN ??dmp_set_gyro_bias?relay
        FUNCTION ??dmp_set_gyro_bias?relay,00H
        EXTERN ??dmp_set_orientation?relay
        FUNCTION ??dmp_set_orientation?relay,00H
        EXTERN ??labs?relay
        FUNCTION ??labs?relay,00H
        EXTERN ??memcmp?relay
        FUNCTION ??memcmp?relay,00H
        EXTERN ??memset?relay
        FUNCTION ??memset?relay,00H
        EXTERN ??printf?relay
        FUNCTION ??printf?relay,00H

// D:\ZigBee\KJXY-ZigBee\KJXY-ZigBeeV2.0\exp9-group\Components\HARDWARE\MPU6050\eMPL\inv_mpu.c
//    1 /*
//    2  $License:
//    3     Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
//    4     See included License.txt for License information.
//    5  $
//    6  */
//    7 /**
//    8  *  @addtogroup  DRIVERS Sensor Driver Layer
//    9  *  @brief       Hardware drivers to communicate with sensors via I2C.
//   10  *
//   11  *  @{
//   12  *      @file       inv_mpu.c
//   13  *      @brief      An I2C-based driver for Invensense gyroscopes.
//   14  *      @details    This driver currently works for the following devices:
//   15  *                  MPU6050
//   16  *                  MPU6500
//   17  *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
//   18  *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
//   19  */
//   20 #include <stdio.h>
//   21 //#include <stdint.h>
//   22 #include <stdlib.h>
//   23 #include <string.h>
//   24 #include <math.h>
//   25 #include "inv_mpu.h"
//   26 #include "inv_mpu_dmp_motion_driver.h"
//   27 #include "mpu6050.h"
//   28 #include "delay.h"
//   29 
//   30 #define MPU6050					//定义我们使用的传感器为MPU6050
//   31 #define MOTION_DRIVER_TARGET_MSP430		//定义驱动部分,采用MSP430的驱动(移植到STM32F1)
//   32 
//   33 /* The following functions must be defined for this platform:
//   34  * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
//   35  *      unsigned char length, unsigned char const *data)
//   36  * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
//   37  *      unsigned char length, unsigned char *data)
//   38  * delay_ms(unsigned long num_ms)
//   39  * get_ms(unsigned long *count)
//   40  * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
//   41  * labs(long x)
//   42  * fabsf(float x)
//   43  * min(int a, int b)
//   44  */
//   45 #if defined MOTION_DRIVER_TARGET_MSP430
//   46 //#include "msp430.h"
//   47 //#include "msp430_i2c.h"
//   48 //#include "msp430_clock.h"
//   49 //#include "msp430_interrupt.h"
//   50 
//   51 #define i2c_write   MPU_Write_Len
//   52 #define i2c_read    MPU_Read_Len
//   53 #define delay_ms    delay_ms
//   54 #define get_ms      mget_ms
//   55 //static inline int reg_int_cb(struct int_param_s *int_param)
//   56 //{
//   57 //    return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
//   58 //        int_param->active_low);
//   59 //}
//   60 #define log_i 	printf	//打印信息
//   61 #define log_e  	printf	//打印信息
//   62 /* labs is already defined by TI's toolchain. */
//   63 /* fabs is for doubles. fabsf is for floats. */
//   64 //#define fabs  fabsf
//   65 #define min(a,b) ((a<b)?a:b)
//   66 #elif defined EMPL_TARGET_MSP430
//   67 #include "msp430.h"
//   68 #include "msp430_i2c.h"
//   69 #include "msp430_clock.h"
//   70 #include "msp430_interrupt.h"
//   71 #include "log.h"
//   72 #define i2c_write   msp430_i2c_write
//   73 #define i2c_read    msp430_i2c_read
//   74 #define delay_ms    msp430_delay_ms
//   75 #define get_ms      msp430_get_clock_ms
//   76 static inline int reg_int_cb(struct int_param_s *int_param)
//   77 {
//   78     return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
//   79         int_param->active_low);
//   80 }
//   81 #define log_i       MPL_LOGI
//   82 #define log_e       MPL_LOGE
//   83 /* labs is already defined by TI's toolchain. */
//   84 /* fabs is for doubles. fabsf is for floats. */
//   85 #define fabs   fabsf
//   86 #define min(a,b) ((a<b)?a:b)
//   87 #elif defined EMPL_TARGET_UC3L0
//   88 /* Instead of using the standard TWI driver from the ASF library, we're using
//   89  * a TWI driver that follows the slave address + register address convention.
//   90  */
//   91 #include "twi.h"
//   92 #include "delay.h"
//   93 #include "sysclk.h"
//   94 #include "log.h"
//   95 #include "sensors_xplained.h"
//   96 #include "uc3l0_clock.h"
//   97 #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
//   98 #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
//   99 /* delay_ms is a function already defined in ASF. */
//  100 #define get_ms  uc3l0_get_clock_ms
//  101 static inline int reg_int_cb(struct int_param_s *int_param)
//  102 {
//  103     sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
//  104     return 0;
//  105 }
//  106 #define log_i       MPL_LOGI
//  107 #define log_e       MPL_LOGE
//  108 /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
//  109 #define labs        abs
//  110 #define fabs(x)     (((x)>0)?(x):-(x))
//  111 #else
//  112 #error  Gyro driver is missing the system layer implementations.
//  113 #endif
//  114 
//  115 #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
//  116 #error  Which gyro are you using? Define MPUxxxx in your compiler options.
//  117 #endif
//  118 
//  119 /* Time for some messy macro work. =]
//  120  * #define MPU9150
//  121  * is equivalent to..
//  122  * #define MPU6050
//  123  * #define AK8975_SECONDARY
//  124  *
//  125  * #define MPU9250
//  126  * is equivalent to..
//  127  * #define MPU6500
//  128  * #define AK8963_SECONDARY
//  129  */
//  130 #if defined MPU9150
//  131 #ifndef MPU6050
//  132 #define MPU6050
//  133 #endif                          /* #ifndef MPU6050 */
//  134 #if defined AK8963_SECONDARY
//  135 #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
//  136 #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
//  137 #define AK8975_SECONDARY
//  138 #endif                          /* #if defined AK8963_SECONDARY */
//  139 #elif defined MPU9250           /* #if defined MPU9150 */
//  140 #ifndef MPU6500
//  141 #define MPU6500
//  142 #endif                          /* #ifndef MPU6500 */
//  143 #if defined AK8975_SECONDARY
//  144 #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
//  145 #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
//  146 #define AK8963_SECONDARY
//  147 #endif                          /* #if defined AK8975_SECONDARY */
//  148 #endif                          /* #if defined MPU9150 */
//  149 
//  150 #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
//  151 #define AK89xx_SECONDARY
//  152 #else
//  153 /* #warning "No compass = less profit for Invensense. Lame." */
//  154 #endif
//  155 
//  156 static int set_int_enable(unsigned char enable);
//  157 
//  158 /* Hardware registers needed by driver. */
//  159 struct gyro_reg_s {
//  160     unsigned char who_am_i;
//  161     unsigned char rate_div;
//  162     unsigned char lpf;
//  163     unsigned char prod_id;
//  164     unsigned char user_ctrl;
//  165     unsigned char fifo_en;
//  166     unsigned char gyro_cfg;
//  167     unsigned char accel_cfg;
//  168 //    unsigned char accel_cfg2;
//  169 //    unsigned char lp_accel_odr;
//  170     unsigned char motion_thr;
//  171     unsigned char motion_dur;
//  172     unsigned char fifo_count_h;
//  173     unsigned char fifo_r_w;
//  174     unsigned char raw_gyro;
//  175     unsigned char raw_accel;
//  176     unsigned char temp;
//  177     unsigned char int_enable;
//  178     unsigned char dmp_int_status;
//  179     unsigned char int_status;
//  180 //    unsigned char accel_intel;
//  181     unsigned char pwr_mgmt_1;
//  182     unsigned char pwr_mgmt_2;
//  183     unsigned char int_pin_cfg;
//  184     unsigned char mem_r_w;
//  185     unsigned char accel_offs;
//  186     unsigned char i2c_mst;
//  187     unsigned char bank_sel;
//  188     unsigned char mem_start_addr;
//  189     unsigned char prgm_start_h;
//  190 #if defined AK89xx_SECONDARY
//  191     unsigned char s0_addr;
//  192     unsigned char s0_reg;
//  193     unsigned char s0_ctrl;
//  194     unsigned char s1_addr;
//  195     unsigned char s1_reg;
//  196     unsigned char s1_ctrl;
//  197     unsigned char s4_ctrl;
//  198     unsigned char s0_do;
//  199     unsigned char s1_do;
//  200     unsigned char i2c_delay_ctrl;
//  201     unsigned char raw_compass;
//  202     /* The I2C_MST_VDDIO bit is in this register. */
//  203     unsigned char yg_offs_tc;
//  204 #endif
//  205 };
//  206 
//  207 /* Information specific to a particular device. */
//  208 struct hw_s {
//  209     unsigned char addr;
//  210     unsigned short max_fifo;
//  211     unsigned char num_reg;
//  212     unsigned short temp_sens;
//  213     short temp_offset;
//  214     unsigned short bank_size;
//  215 #if defined AK89xx_SECONDARY
//  216     unsigned short compass_fsr;
//  217 #endif
//  218 };
//  219 
//  220 /* When entering motion interrupt mode, the driver keeps track of the
//  221  * previous state so that it can be restored at a later time.
//  222  * TODO: This is tacky. Fix it.
//  223  */
//  224 struct motion_int_cache_s {
//  225     unsigned short gyro_fsr;
//  226     unsigned char accel_fsr;
//  227     unsigned short lpf;
//  228     unsigned short sample_rate;
//  229     unsigned char sensors_on;
//  230     unsigned char fifo_sensors;
//  231     unsigned char dmp_on;
//  232 };
//  233 
//  234 /* Cached chip configuration data.
//  235  * TODO: A lot of these can be handled with a bitmask.
//  236  */
//  237 struct chip_cfg_s {
//  238     /* Matches gyro_cfg >> 3 & 0x03 */
//  239     unsigned char gyro_fsr;
//  240     /* Matches accel_cfg >> 3 & 0x03 */
//  241     unsigned char accel_fsr;
//  242     /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
//  243     unsigned char sensors;
//  244     /* Matches config register. */
//  245     unsigned char lpf;
//  246     unsigned char clk_src;
//  247     /* Sample rate, NOT rate divider. */
//  248     unsigned short sample_rate;
//  249     /* Matches fifo_en register. */
//  250     unsigned char fifo_enable;
//  251     /* Matches int enable register. */
//  252     unsigned char int_enable;
//  253     /* 1 if devices on auxiliary I2C bus appear on the primary. */
//  254     unsigned char bypass_mode;
//  255     /* 1 if half-sensitivity.
//  256      * NOTE: This doesn't belong here, but everything else in hw_s is const,
//  257      * and this allows us to save some precious RAM.
//  258      */
//  259     unsigned char accel_half;
//  260     /* 1 if device in low-power accel-only mode. */
//  261     unsigned char lp_accel_mode;
//  262     /* 1 if interrupts are only triggered on motion events. */
//  263     unsigned char int_motion_only;
//  264     struct motion_int_cache_s cache;
//  265     /* 1 for active low interrupts. */
//  266     unsigned char active_low_int;
//  267     /* 1 for latched interrupts. */
//  268     unsigned char latched_int;
//  269     /* 1 if DMP is enabled. */
//  270     unsigned char dmp_on;
//  271     /* Ensures that DMP will only be loaded once. */
//  272     unsigned char dmp_loaded;
//  273     /* Sampling rate used when DMP is enabled. */
//  274     unsigned short dmp_sample_rate;
//  275 #ifdef AK89xx_SECONDARY
//  276     /* Compass sample rate. */
//  277     unsigned short compass_sample_rate;
//  278     unsigned char compass_addr;
//  279     short mag_sens_adj[3];
//  280 #endif
//  281 };
//  282 
//  283 /* Information for self-test. */
//  284 struct test_s {
//  285     unsigned long gyro_sens;
//  286     unsigned long accel_sens;
//  287     unsigned char reg_rate_div;
//  288     unsigned char reg_lpf;
//  289     unsigned char reg_gyro_fsr;
//  290     unsigned char reg_accel_fsr;
//  291     unsigned short wait_ms;
//  292     unsigned char packet_thresh;
//  293     float min_dps;
//  294     float max_dps;
//  295     float max_gyro_var;
//  296     float min_g;
//  297     float max_g;
//  298     float max_accel_var;
//  299 };
//  300 
//  301 /* Gyro driver state variables. */
//  302 struct gyro_state_s {
//  303     const struct gyro_reg_s *reg;
//  304     const struct hw_s *hw;
//  305     struct chip_cfg_s chip_cfg;
//  306     const struct test_s *test;
//  307 };
//  308 
//  309 /* Filter configurations. */
//  310 enum lpf_e {
//  311     INV_FILTER_256HZ_NOLPF2 = 0,
//  312     INV_FILTER_188HZ,
//  313     INV_FILTER_98HZ,
//  314     INV_FILTER_42HZ,
//  315     INV_FILTER_20HZ,
//  316     INV_FILTER_10HZ,
//  317     INV_FILTER_5HZ,
//  318     INV_FILTER_2100HZ_NOLPF,
//  319     NUM_FILTER
//  320 };
//  321 
//  322 /* Full scale ranges. */
//  323 enum gyro_fsr_e {
//  324     INV_FSR_250DPS = 0,
//  325     INV_FSR_500DPS,
//  326     INV_FSR_1000DPS,
//  327     INV_FSR_2000DPS,
//  328     NUM_GYRO_FSR
//  329 };
//  330 
//  331 /* Full scale ranges. */
//  332 enum accel_fsr_e {
//  333     INV_FSR_2G = 0,
//  334     INV_FSR_4G,
//  335     INV_FSR_8G,
//  336     INV_FSR_16G,
//  337     NUM_ACCEL_FSR
//  338 };
//  339 
//  340 /* Clock sources. */
//  341 enum clock_sel_e {
//  342     INV_CLK_INTERNAL = 0,
//  343     INV_CLK_PLL,
//  344     NUM_CLK
//  345 };
//  346 
//  347 /* Low-power accel wakeup rates. */
//  348 enum lp_accel_rate_e {
//  349 #if defined MPU6050
//  350     INV_LPA_1_25HZ,
//  351     INV_LPA_5HZ,
//  352     INV_LPA_20HZ,
//  353     INV_LPA_40HZ
//  354 #elif defined MPU6500
//  355     INV_LPA_0_3125HZ,
//  356     INV_LPA_0_625HZ,
//  357     INV_LPA_1_25HZ,
//  358     INV_LPA_2_5HZ,
//  359     INV_LPA_5HZ,
//  360     INV_LPA_10HZ,
//  361     INV_LPA_20HZ,
//  362     INV_LPA_40HZ,
//  363     INV_LPA_80HZ,
//  364     INV_LPA_160HZ,
//  365     INV_LPA_320HZ,
//  366     INV_LPA_640HZ
//  367 #endif
//  368 };
//  369 
//  370 #define BIT_I2C_MST_VDDIO   (0x80)
//  371 #define BIT_FIFO_EN         (0x40)
//  372 #define BIT_DMP_EN          (0x80)
//  373 #define BIT_FIFO_RST        (0x04)
//  374 #define BIT_DMP_RST         (0x08)
//  375 #define BIT_FIFO_OVERFLOW   (0x10)
//  376 #define BIT_DATA_RDY_EN     (0x01)
//  377 #define BIT_DMP_INT_EN      (0x02)
//  378 #define BIT_MOT_INT_EN      (0x40)
//  379 #define BITS_FSR            (0x18)
//  380 #define BITS_LPF            (0x07)
//  381 #define BITS_HPF            (0x07)
//  382 #define BITS_CLK            (0x07)
//  383 #define BIT_FIFO_SIZE_1024  (0x40)
//  384 #define BIT_FIFO_SIZE_2048  (0x80)
//  385 #define BIT_FIFO_SIZE_4096  (0xC0)
//  386 #define BIT_RESET           (0x80)
//  387 #define BIT_SLEEP           (0x40)
//  388 #define BIT_S0_DELAY_EN     (0x01)
//  389 #define BIT_S2_DELAY_EN     (0x04)
//  390 #define BITS_SLAVE_LENGTH   (0x0F)
//  391 #define BIT_SLAVE_BYTE_SW   (0x40)
//  392 #define BIT_SLAVE_GROUP     (0x10)
//  393 #define BIT_SLAVE_EN        (0x80)
//  394 #define BIT_I2C_READ        (0x80)
//  395 #define BITS_I2C_MASTER_DLY (0x1F)
//  396 #define BIT_AUX_IF_EN       (0x20)
//  397 #define BIT_ACTL            (0x80)
//  398 #define BIT_LATCH_EN        (0x20)
//  399 #define BIT_ANY_RD_CLR      (0x10)
//  400 #define BIT_BYPASS_EN       (0x02)
//  401 #define BITS_WOM_EN         (0xC0)
//  402 #define BIT_LPA_CYCLE       (0x20)
//  403 #define BIT_STBY_XA         (0x20)
//  404 #define BIT_STBY_YA         (0x10)
//  405 #define BIT_STBY_ZA         (0x08)
//  406 #define BIT_STBY_XG         (0x04)
//  407 #define BIT_STBY_YG         (0x02)
//  408 #define BIT_STBY_ZG         (0x01)
//  409 #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
//  410 #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
//  411 
//  412 #if defined AK8975_SECONDARY
//  413 #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
//  414 #define AK89xx_FSR                  (9830)
//  415 #elif defined AK8963_SECONDARY
//  416 #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
//  417 #define AK89xx_FSR                  (4915)
//  418 #endif
//  419 
//  420 #ifdef AK89xx_SECONDARY
//  421 #define AKM_REG_WHOAMI      (0x00)
//  422 
//  423 #define AKM_REG_ST1         (0x02)
//  424 #define AKM_REG_HXL         (0x03)
//  425 #define AKM_REG_ST2         (0x09)
//  426 
//  427 #define AKM_REG_CNTL        (0x0A)
//  428 #define AKM_REG_ASTC        (0x0C)
//  429 #define AKM_REG_ASAX        (0x10)
//  430 #define AKM_REG_ASAY        (0x11)
//  431 #define AKM_REG_ASAZ        (0x12)
//  432 
//  433 #define AKM_DATA_READY      (0x01)
//  434 #define AKM_DATA_OVERRUN    (0x02)
//  435 #define AKM_OVERFLOW        (0x80)
//  436 #define AKM_DATA_ERROR      (0x40)
//  437 
//  438 #define AKM_BIT_SELF_TEST   (0x40)
//  439 
//  440 #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
//  441 #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
//  442 #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
//  443 #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
//  444 
//  445 #define AKM_WHOAMI      (0x48)
//  446 #endif
//  447 
//  448 #if defined MPU6050
//  449 //const struct gyro_reg_s reg = {
//  450 //    .who_am_i       = 0x75,
//  451 //    .rate_div       = 0x19,
//  452 //    .lpf            = 0x1A,
//  453 //    .prod_id        = 0x0C,
//  454 //    .user_ctrl      = 0x6A,
//  455 //    .fifo_en        = 0x23,
//  456 //    .gyro_cfg       = 0x1B,
//  457 //    .accel_cfg      = 0x1C,
//  458 //    .motion_thr     = 0x1F,
//  459 //    .motion_dur     = 0x20,
//  460 //    .fifo_count_h   = 0x72,
//  461 //    .fifo_r_w       = 0x74,
//  462 //    .raw_gyro       = 0x43,
//  463 //    .raw_accel      = 0x3B,
//  464 //    .temp           = 0x41,
//  465 //    .int_enable     = 0x38,
//  466 //    .dmp_int_status = 0x39,
//  467 //    .int_status     = 0x3A,
//  468 //    .pwr_mgmt_1     = 0x6B,
//  469 //    .pwr_mgmt_2     = 0x6C,
//  470 //    .int_pin_cfg    = 0x37,
//  471 //    .mem_r_w        = 0x6F,
//  472 //    .accel_offs     = 0x06,
//  473 //    .i2c_mst        = 0x24,
//  474 //    .bank_sel       = 0x6D,
//  475 //    .mem_start_addr = 0x6E,
//  476 //    .prgm_start_h   = 0x70
//  477 //#ifdef AK89xx_SECONDARY
//  478 //    ,.raw_compass   = 0x49,
//  479 //    .yg_offs_tc     = 0x01,
//  480 //    .s0_addr        = 0x25,
//  481 //    .s0_reg         = 0x26,
//  482 //    .s0_ctrl        = 0x27,
//  483 //    .s1_addr        = 0x28,
//  484 //    .s1_reg         = 0x29,
//  485 //    .s1_ctrl        = 0x2A,
//  486 //    .s4_ctrl        = 0x34,
//  487 //    .s0_do          = 0x63,
//  488 //    .s1_do          = 0x64,
//  489 //    .i2c_delay_ctrl = 0x67
//  490 //#endif
//  491 //};

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  492 const struct gyro_reg_s reg = {
reg:
        DB 117
        DB 25
        DB 26
        DB 12
        DB 106
        DB 35
        DB 27
        DB 28
        DB 31
        DB 32
        DB 114
        DB 116
        DB 67
        DB 59
        DB 65
        DB 56
        DB 57
        DB 58
        DB 107
        DB 108
        DB 55
        DB 111
        DB 6
        DB 36
        DB 109
        DB 110
        DB 112
//  493 0x75,  //who_am_i
//  494 0x19,  //rate_div
//  495 0x1A,  //lpf
//  496 0x0C,  //prod_id
//  497 0x6A,  //user_ctrl
//  498 0x23,  //fifo_en
//  499 0x1B,  //gyro_cfg
//  500 0x1C,  //accel_cfg
//  501 0x1F,  // motion_thr
//  502 0x20,  // motion_dur
//  503 0x72,  // fifo_count_h
//  504 0x74,  // fifo_r_w
//  505 0x43,  // raw_gyro
//  506 0x3B,  // raw_accel
//  507 0x41,  // temp
//  508 0x38,  // int_enable
//  509 0x39,  //  dmp_int_status
//  510 0x3A,  //  int_status
//  511 0x6B,  // pwr_mgmt_1
//  512 0x6C,  // pwr_mgmt_2
//  513 0x37,  // int_pin_cfg
//  514 0x6F,  // mem_r_w
//  515 0x06,  // accel_offs
//  516 0x24,  // i2c_mst
//  517 0x6D,  // bank_sel
//  518 0x6E,  // mem_start_addr
//  519 0x70   // prgm_start_h
//  520 };
//  521 
//  522 //const struct hw_s hw = {
//  523 //    .addr           = 0x68,
//  524 //    .max_fifo       = 1024,
//  525 //    .num_reg        = 118,
//  526 //    .temp_sens      = 340,
//  527 //    .temp_offset    = -521,
//  528 //    .bank_size      = 256
//  529 //#if defined AK89xx_SECONDARY
//  530 //    ,.compass_fsr    = AK89xx_FSR
//  531 //#endif
//  532 //};

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  533 const struct hw_s hw={
hw:
        DB 104
        DATA16
        DW 1024
        DATA8
        DB 118
        DATA16
        DW 340
        DW -521
        DW 256
//  534   0x68,	 //addr
//  535   1024,	 //max_fifo
//  536   118,	 //num_reg
//  537   340,	 //temp_sens
//  538   -521,	 //temp_offset
//  539   256	 //bank_size
//  540 };
//  541 
//  542 //const struct test_s test = {
//  543 //    .gyro_sens      = 32768/250,
//  544 //    .accel_sens     = 32768/16,
//  545 //    .reg_rate_div   = 0,    /* 1kHz. */
//  546 //    .reg_lpf        = 1,    /* 188Hz. */
//  547 //    .reg_gyro_fsr   = 0,    /* 250dps. */
//  548 //    .reg_accel_fsr  = 0x18, /* 16g. */
//  549 //    .wait_ms        = 50,
//  550 //    .packet_thresh  = 5,    /* 5% */
//  551 //    .min_dps        = 10.f,
//  552 //    .max_dps        = 105.f,
//  553 //    .max_gyro_var   = 0.14f,
//  554 //    .min_g          = 0.3f,
//  555 //    .max_g          = 0.95f,
//  556 //    .max_accel_var  = 0.14f
//  557 //};

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  558 const struct test_s test={
test:
        DATA32
        DD 131
        DD 2048
        DATA8
        DB 0
        DB 1
        DB 0
        DB 24
        DATA16
        DW 50
        DATA8
        DB 5
        DATA32
        DD 41200000H
        DD 42D20000H
        DD 3E0F5C29H
        DD 3E99999AH
        DD 3F733333H
        DD 3E0F5C29H
//  559 32768/250,		 //gyro_sens
//  560 32768/16,		 //	accel_sens
//  561 0,				 //	reg_rate_div
//  562 1,				//	reg_lpf
//  563 0,				 //	reg_gyro_fsr
//  564 0x18,			//	reg_accel_fsr
//  565 50,				//	wait_ms
//  566 5,				//	packet_thresh
//  567 10.0f,			 //	min_dps
//  568 105.0f,			 //	max_dps
//  569 0.14f,			//	max_gyro_var
//  570 0.3f,		   //	min_g
//  571 0.95f,		   //	max_g
//  572 0.14f		   //	max_accel_var
//  573 };
//  574 
//  575 //static struct gyro_state_s st = {
//  576 //    .reg = &reg,
//  577 //    .hw = &hw,
//  578 //    .test = &test
//  579 //};

        RSEG XDATA_I:XDATA:NOROOT(0)
//  580 static struct gyro_state_s st={
st:
        DATA8
        DS 35
        REQUIRE `?<Initializer for st>`
        REQUIRE __INIT_XDATA_I
//  581   &reg,
//  582   &hw,
//  583   {0},
//  584   &test
//  585 };
//  586 
//  587 
//  588 #elif defined MPU6500
//  589 const struct gyro_reg_s reg = {
//  590     .who_am_i       = 0x75,
//  591     .rate_div       = 0x19,
//  592     .lpf            = 0x1A,
//  593     .prod_id        = 0x0C,
//  594     .user_ctrl      = 0x6A,
//  595     .fifo_en        = 0x23,
//  596     .gyro_cfg       = 0x1B,
//  597     .accel_cfg      = 0x1C,
//  598     .accel_cfg2     = 0x1D,
//  599     .lp_accel_odr   = 0x1E,
//  600     .motion_thr     = 0x1F,
//  601     .motion_dur     = 0x20,
//  602     .fifo_count_h   = 0x72,
//  603     .fifo_r_w       = 0x74,
//  604     .raw_gyro       = 0x43,
//  605     .raw_accel      = 0x3B,
//  606     .temp           = 0x41,
//  607     .int_enable     = 0x38,
//  608     .dmp_int_status = 0x39,
//  609     .int_status     = 0x3A,
//  610     .accel_intel    = 0x69,
//  611     .pwr_mgmt_1     = 0x6B,
//  612     .pwr_mgmt_2     = 0x6C,
//  613     .int_pin_cfg    = 0x37,
//  614     .mem_r_w        = 0x6F,
//  615     .accel_offs     = 0x77,
//  616     .i2c_mst        = 0x24,
//  617     .bank_sel       = 0x6D,
//  618     .mem_start_addr = 0x6E,
//  619     .prgm_start_h   = 0x70
//  620 #ifdef AK89xx_SECONDARY
//  621     ,.raw_compass   = 0x49,
//  622     .s0_addr        = 0x25,
//  623     .s0_reg         = 0x26,
//  624     .s0_ctrl        = 0x27,
//  625     .s1_addr        = 0x28,
//  626     .s1_reg         = 0x29,
//  627     .s1_ctrl        = 0x2A,
//  628     .s4_ctrl        = 0x34,
//  629     .s0_do          = 0x63,
//  630     .s1_do          = 0x64,
//  631     .i2c_delay_ctrl = 0x67
//  632 #endif
//  633 };
//  634 const struct hw_s hw = {
//  635     .addr           = 0x68,
//  636     .max_fifo       = 1024,
//  637     .num_reg        = 128,
//  638     .temp_sens      = 321,
//  639     .temp_offset    = 0,
//  640     .bank_size      = 256
//  641 #if defined AK89xx_SECONDARY
//  642     ,.compass_fsr    = AK89xx_FSR
//  643 #endif
//  644 };
//  645 
//  646 const struct test_s test = {
//  647     .gyro_sens      = 32768/250,
//  648     .accel_sens     = 32768/16,
//  649     .reg_rate_div   = 0,    /* 1kHz. */
//  650     .reg_lpf        = 1,    /* 188Hz. */
//  651     .reg_gyro_fsr   = 0,    /* 250dps. */
//  652     .reg_accel_fsr  = 0x18, /* 16g. */
//  653     .wait_ms        = 50,
//  654     .packet_thresh  = 5,    /* 5% */
//  655     .min_dps        = 10.f,
//  656     .max_dps        = 105.f,
//  657     .max_gyro_var   = 0.14f,
//  658     .min_g          = 0.3f,
//  659     .max_g          = 0.95f,
//  660     .max_accel_var  = 0.14f
//  661 };
//  662 
//  663 static struct gyro_state_s st = {
//  664     .reg = &reg,
//  665     .hw = &hw,
//  666     .test = &test
//  667 };
//  668 #endif
//  669 
//  670 #define MAX_PACKET_LENGTH (12)
//  671 
//  672 #ifdef AK89xx_SECONDARY
//  673 static int setup_compass(void);
//  674 #define MAX_COMPASS_SAMPLE_RATE (100)
//  675 #endif
//  676 
//  677 /**
//  678  *  @brief      Enable/disable data ready interrupt.
//  679  *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
//  680  *  interrupt is used.
//  681  *  @param[in]  enable      1 to enable interrupt.
//  682  *  @return     0 if successful.
//  683  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  684 static int set_int_enable(unsigned char enable)
set_int_enable:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function set_int_enable
        CODE
//  685 {
        FUNCALL set_int_enable, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL set_int_enable, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
//  686     unsigned char tmp;
//  687 
//  688     if (st.chip_cfg.dmp_on) {
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??set_int_enable_0
//  689         if (enable)
        MOV     A,R6
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??set_int_enable_1
//  690             tmp = BIT_DMP_INT_EN;
        MOV     A,#0x2
        SJMP    ??set_int_enable_2
//  691         else
//  692             tmp = 0x00;
??set_int_enable_1:
        CLR     A
??set_int_enable_2:
        MOVX    @DPTR,A
//  693         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??set_int_enable_3
//  694             return -1;
??set_int_enable_4:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
??set_int_enable_5:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI CFA_XSP16 add(XSP16, 10)
//  695         st.chip_cfg.int_enable = tmp;
//  696     } else {
//  697         if (!st.chip_cfg.sensors)
??set_int_enable_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??set_int_enable_4
//  698             return -1;
//  699         if (enable && st.chip_cfg.int_enable)
        MOV     A,R6
        JZ      ??set_int_enable_6
        MOV     DPTR,#st + 12
        MOVX    A,@DPTR
        JZ      ??set_int_enable_6
//  700             return 0;
??set_int_enable_7:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??set_int_enable_5
//  701         if (enable)
??set_int_enable_6:
        MOV     A,R6
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??set_int_enable_8
//  702             tmp = BIT_DATA_RDY_EN;
        MOV     A,#0x1
        SJMP    ??set_int_enable_9
//  703         else
//  704             tmp = 0x00;
??set_int_enable_8:
        CLR     A
??set_int_enable_9:
        MOVX    @DPTR,A
//  705         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??set_int_enable_4
//  706             return -1;
//  707         st.chip_cfg.int_enable = tmp;
//  708     }
??set_int_enable_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     DPTR,#st + 12
        MOVX    @DPTR,A
        SJMP    ??set_int_enable_7
        CFI EndBlock cfiBlock0
//  709     return 0;
//  710 }
//  711 
//  712 /**
//  713  *  @brief      Register dump for testing.
//  714  *  @return     0 if successful.
//  715  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  716 int mpu_reg_dump(void)
mpu_reg_dump:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function mpu_reg_dump
        CODE
//  717 {
        FUNCALL mpu_reg_dump, printf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reg_dump, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
//  718     unsigned char ii;
//  719     unsigned char data;
//  720 
//  721     for (ii = 0; ii < st.hw->num_reg; ii++) {
        MOV     R6,#0x0
        SJMP    ??mpu_reg_dump_0
//  722         if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
//  723             continue;
//  724         if (i2c_read(st.hw->addr, ii, 1, &data))
//  725             return -1;
//  726         log_i("%#5x: %#5x\r\n", ii, data);
??mpu_reg_dump_1:
        ; Setup parameters for call to function printf
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 13)
        MOV     ?V0 + 0,R6
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 15)
        MOV     R2,#`?<Constant "%#5x: %#5x\\r\\n">` & 0xff
        MOV     R3,#(`?<Constant "%#5x: %#5x\\r\\n">` >> 8) & 0xff
        LCALL   ??printf?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
??mpu_reg_dump_2:
        INC     R6
??mpu_reg_dump_0:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R6
        CLR     C
        SUBB    A,R2
        JNC     ??mpu_reg_dump_3
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        XRL     A,R6
        JZ      ??mpu_reg_dump_2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        XRL     A,R6
        JZ      ??mpu_reg_dump_2
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     A,R6
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      ??mpu_reg_dump_1
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_reg_dump_4
//  727     }
//  728     return 0;
??mpu_reg_dump_3:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_reg_dump_4:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1
//  729 }
//  730 
//  731 /**
//  732  *  @brief      Read from a single register.
//  733  *  NOTE: The memory and FIFO read/write registers cannot be accessed.
//  734  *  @param[in]  reg     Register address.
//  735  *  @param[out] data    Register data.
//  736  *  @return     0 if successful.
//  737  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  738 int mpu_read_reg(unsigned char reg, unsigned char *data)
mpu_read_reg:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function mpu_read_reg
        CODE
//  739 {
        FUNCALL mpu_read_reg, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
//  740     if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        XRL     A,R6
        JZ      ??mpu_read_reg_0
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??mpu_read_reg_1
//  741         return -1;
??mpu_read_reg_0:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_read_reg_2
//  742     if (reg >= st.hw->num_reg)
??mpu_read_reg_1:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R6
        CLR     C
        SUBB    A,R2
        JNC     ??mpu_read_reg_0
//  743         return -1;
//  744     return i2c_read(st.hw->addr, reg, 1, data);
        ; Setup parameters for call to function MPU_Read_Len
        MOV     R3,#0x1
        MOV     A,R6
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     ?V0 + 0,R1
        MOV     R2,?V0 + 0
        MOV     R3,#0x0
??mpu_read_reg_2:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock2
//  745 }
//  746 
//  747 /**
//  748  *  @brief      Initialize hardware.
//  749  *  Initial configuration:\n
//  750  *  Gyro FSR: +/- 2000DPS\n
//  751  *  Accel FSR +/- 2G\n
//  752  *  DLPF: 42Hz\n
//  753  *  FIFO rate: 50Hz\n
//  754  *  Clock source: Gyro PLL\n
//  755  *  FIFO: Disabled.\n
//  756  *  Data ready interrupt: Disabled, active low, unlatched.
//  757  *  @param[in]  int_param   Platform-specific parameters to interrupt API.
//  758  *  @return     0 if successful.
//  759  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  760 int mpu_init(void)
mpu_init:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function mpu_init
        CODE
//  761 {
        FUNCALL mpu_init, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, printf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, printf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, printf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_bypass
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_init, mpu_set_sensors
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 6
        MOV     A,#-0x6
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
//  762     unsigned char data[6], rev;
//  763 
//  764     /* Reset device. */
//  765     data[0] = BIT_RESET;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x80
        MOVX    @DPTR,A
//  766     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??mpu_init_0
//  767         return -1;
??mpu_init_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_init_2 & 0xFFFF
//  768     delay_ms(100);
??mpu_init_0:
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_64
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
//  769 
//  770     /* Wake up chip. */
//  771     data[0] = 0x00;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
//  772     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_init_1
//  773         return -1;
//  774 
//  775 #if defined MPU6050
//  776     /* Check product revision. */
//  777     if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x16
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_init_1
//  778         return -1;
//  779     rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
//  780         (data[1] & 0x01);
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        RLC     A
        MOV     R0,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        CLR     A
        RLC     A
        RLC     A
        RLC     A
        ORL     A,R0
        ORL     A,R1
        MOV     ?V0 + 0,A
//  781 
//  782     if (rev) {
        JZ      ??mpu_init_3
//  783         /* Congrats, these parts are better. */
//  784         if (rev == 1)
        MOV     A,#0x1
        XRL     A,?V0 + 0
        JZ      ??mpu_init_4
//  785             st.chip_cfg.accel_half = 1;
//  786         else if (rev == 2)
        MOV     A,#0x2
        XRL     A,?V0 + 0
        JNZ     ??mpu_init_5
//  787             st.chip_cfg.accel_half = 0;
??mpu_init_6:
        MOV     DPTR,#st + 14
        CLR     A
        SJMP    ??mpu_init_7
//  788         else {
//  789             log_e("Unsupported software product rev %d.\n", rev);
??mpu_init_5:
        ; Setup parameters for call to function printf
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     R2,#`?<Constant "Unsupported software ...">` & 0xff
        MOV     R3,#(`?<Constant "Unsupported software ...">` >> 8) & 0xff
        LCALL   ??printf?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
//  790             return -1;
        LJMP    ??mpu_init_1 & 0xFFFF
//  791         }
//  792     } else {
//  793         if (i2c_read(st.hw->addr, st.reg->prod_id, 1, data))
??mpu_init_3:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  794             return -1;
//  795         rev = data[0] & 0x0F;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0xf
        MOV     ?V0 + 0,A
//  796         if (!rev) {
        JNZ     ??mpu_init_8
//  797             log_e("Product ID read as 0 indicates device is either "
//  798                 "incompatible or an MPU3050.\n");
        ; Setup parameters for call to function printf
        MOV     R2,#`?<Constant "Product ID read as 0 ...">` & 0xff
        MOV     R3,#(`?<Constant "Product ID read as 0 ...">` >> 8) & 0xff
        LCALL   ??printf?relay
//  799             return -1;
        LJMP    ??mpu_init_1 & 0xFFFF
//  800         } else if (rev == 4) {
??mpu_init_8:
        MOV     A,#0x4
        XRL     A,?V0 + 0
        JNZ     ??mpu_init_6
//  801             log_i("Half sensitivity part found.\n");
        ; Setup parameters for call to function printf
        MOV     R2,#`?<Constant "Half sensitivity part...">` & 0xff
        MOV     R3,#(`?<Constant "Half sensitivity part...">` >> 8) & 0xff
        LCALL   ??printf?relay
//  802             st.chip_cfg.accel_half = 1;
??mpu_init_4:
        MOV     DPTR,#st + 14
        MOV     A,#0x1
??mpu_init_7:
        MOVX    @DPTR,A
//  803         } else
//  804             st.chip_cfg.accel_half = 0;
//  805     }
//  806 #elif defined MPU6500
//  807 #define MPU6500_MEM_REV_ADDR    (0x17)
//  808     if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
//  809         return -1;
//  810     if (rev == 0x1)
//  811         st.chip_cfg.accel_half = 0;
//  812     else {
//  813         log_e("Unsupported software product rev %d.\n", rev);
//  814         return -1;
//  815     }
//  816 
//  817     /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
//  818      * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
//  819      */
//  820     data[0] = BIT_FIFO_SIZE_1024 | 0x8;
//  821     if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
//  822         return -1;
//  823 #endif
//  824 
//  825     /* Set to invalid values to ensure no I2C writes are skipped. */
//  826     st.chip_cfg.sensors = 0xFF;
        MOV     DPTR,#st + 6
        MOV     A,#-0x1
        MOVX    @DPTR,A
//  827     st.chip_cfg.gyro_fsr = 0xFF;
        MOV     DPTR,#st + 4
        MOVX    @DPTR,A
//  828     st.chip_cfg.accel_fsr = 0xFF;
        INC     DPTR
        MOVX    @DPTR,A
//  829     st.chip_cfg.lpf = 0xFF;
        MOV     DPTR,#st + 7
        MOVX    @DPTR,A
//  830     st.chip_cfg.sample_rate = 0xFFFF;
        MOV     DPTR,#st + 9
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  831     st.chip_cfg.fifo_enable = 0xFF;
        INC     DPTR
        MOVX    @DPTR,A
//  832     st.chip_cfg.bypass_mode = 0xFF;
        MOV     DPTR,#st + 13
        MOVX    @DPTR,A
//  833 #ifdef AK89xx_SECONDARY
//  834     st.chip_cfg.compass_sample_rate = 0xFFFF;
//  835 #endif
//  836     /* mpu_set_sensors always preserves this setting. */
//  837     st.chip_cfg.clk_src = INV_CLK_PLL;
        MOV     DPTR,#st + 8
        MOV     A,#0x1
        MOVX    @DPTR,A
//  838     /* Handled in next call to mpu_set_bypass. */
//  839     st.chip_cfg.active_low_int = 1;
        MOV     DPTR,#st + 27
        MOVX    @DPTR,A
//  840     st.chip_cfg.latched_int = 0;
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//  841     st.chip_cfg.int_motion_only = 0;
        MOV     DPTR,#st + 16
        MOVX    @DPTR,A
//  842     st.chip_cfg.lp_accel_mode = 0;
        MOV     DPTR,#st + 15
        MOVX    @DPTR,A
//  843     memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
        ; Setup parameters for call to function memset
        MOV     ?V0 + 0,#0xa
        MOV     ?V0 + 1,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R2,#(st + 17) & 0xff
        MOV     R3,#((st + 17) >> 8) & 0xff
        LCALL   ??memset?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
//  844     st.chip_cfg.dmp_on = 0;
        MOV     DPTR,#st + 29
        CLR     A
        MOVX    @DPTR,A
//  845     st.chip_cfg.dmp_loaded = 0;
        INC     DPTR
        MOVX    @DPTR,A
//  846     st.chip_cfg.dmp_sample_rate = 0;
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  847 
//  848     if (mpu_set_gyro_fsr(2000))
        ; Setup parameters for call to function mpu_set_gyro_fsr
        MOV     R2,#-0x30
        MOV     R3,#0x7
        LCALL   ??mpu_set_gyro_fsr?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  849         return -1;
//  850     if (mpu_set_accel_fsr(2))
        ; Setup parameters for call to function mpu_set_accel_fsr
        MOV     R1,#0x2
        LCALL   ??mpu_set_accel_fsr?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  851         return -1;
//  852     if (mpu_set_lpf(42))
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0x2a
        MOV     R3,#0x0
        LCALL   ??mpu_set_lpf?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  853         return -1;
//  854     if (mpu_set_sample_rate(50))
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     R2,#0x32
        MOV     R3,#0x0
        LCALL   ??mpu_set_sample_rate?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  855         return -1;
//  856     if (mpu_configure_fifo(0))
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     R1,#0x0
        LCALL   ??mpu_configure_fifo?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  857         return -1;
//  858 
//  859 //    if (int_param)
//  860 //        reg_int_cb(int_param);
//  861 
//  862 #ifdef AK89xx_SECONDARY
//  863     setup_compass();
//  864     if (mpu_set_compass_sample_rate(10))
//  865         return -1;
//  866 #else
//  867     /* Already disabled by setup_compass. */
//  868     if (mpu_set_bypass(0))
        ; Setup parameters for call to function mpu_set_bypass
        MOV     R1,#0x0
        LCALL   ??mpu_set_bypass?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??mpu_init_1 & 0xFFFF
//  869         return -1;
//  870 #endif
//  871 
//  872     mpu_set_sensors(0);
        ; Setup parameters for call to function mpu_set_sensors
        MOV     R1,#0x0
        LCALL   ??mpu_set_sensors?relay
//  873     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_init_2:
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock3
//  874 }
//  875 
//  876 /**
//  877  *  @brief      Enter low-power accel-only mode.
//  878  *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
//  879  *  the accelerometer at one of the following frequencies:
//  880  *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
//  881  *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
//  882  *  \n If the requested rate is not one listed above, the device will be set to
//  883  *  the next highest rate. Requesting a rate above the maximum supported
//  884  *  frequency will result in an error.
//  885  *  \n To select a fractional wake-up frequency, round down the value passed to
//  886  *  @e rate.
//  887  *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
//  888  *                          accel mode.
//  889  *  @return     0 if successful.
//  890  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  891 int mpu_lp_accel_mode(unsigned char rate)
mpu_lp_accel_mode:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function mpu_lp_accel_mode
        CODE
//  892 {
        FUNCALL mpu_lp_accel_mode, mpu_set_int_latched
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_int_latched
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_accel_mode, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
        MOV     A,R1
        MOV     R6,A
//  893     unsigned char tmp[2];
//  894 
//  895     if (rate > 40)
        CLR     C
        SUBB    A,#0x29
        JC      ??mpu_lp_accel_mode_0
//  896         return -1;
??mpu_lp_accel_mode_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
//  897 
//  898     if (!rate) {
??mpu_lp_accel_mode_0:
        MOV     A,R6
        JNZ     ??mpu_lp_accel_mode_3
//  899         mpu_set_int_latched(0);
        ; Setup parameters for call to function mpu_set_int_latched
        MOV     R1,#0x0
        LCALL   ??mpu_set_int_latched?relay
//  900         tmp[0] = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
//  901         tmp[1] = BIT_STBY_XYZG;
        INC     A
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x7
        MOVX    @DPTR,A
//  902         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_lp_accel_mode_1
//  903             return -1;
//  904         st.chip_cfg.lp_accel_mode = 0;
        MOV     DPTR,#st + 15
        CLR     A
        MOVX    @DPTR,A
//  905         return 0;
        MOV     R2,A
        MOV     R3,A
        LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
//  906     }
//  907     /* For LP accel, we automatically configure the hardware to produce latched
//  908      * interrupts. In LP accel mode, the hardware cycles into sleep mode before
//  909      * it gets a chance to deassert the interrupt pin; therefore, we shift this
//  910      * responsibility over to the MCU.
//  911      *
//  912      * Any register read will clear the interrupt.
//  913      */
//  914     mpu_set_int_latched(1);
??mpu_lp_accel_mode_3:
        ; Setup parameters for call to function mpu_set_int_latched
        MOV     R1,#0x1
        LCALL   ??mpu_set_int_latched?relay
//  915 #if defined MPU6050
//  916     tmp[0] = BIT_LPA_CYCLE;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x20
        MOVX    @DPTR,A
//  917     if (rate == 1) {
        MOV     A,#0x1
        XRL     A,R6
        JNZ     ??mpu_lp_accel_mode_4
//  918         tmp[1] = INV_LPA_1_25HZ;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
//  919         mpu_set_lpf(5);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0x5
        MOV     R3,A
        SJMP    ??mpu_lp_accel_mode_5
//  920     } else if (rate <= 5) {
??mpu_lp_accel_mode_4:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x6
        JNC     ??mpu_lp_accel_mode_6
//  921         tmp[1] = INV_LPA_5HZ;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
//  922         mpu_set_lpf(5);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0x5
        SJMP    ??mpu_lp_accel_mode_7
//  923     } else if (rate <= 20) {
??mpu_lp_accel_mode_6:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x15
        MOV     A,#0x1
        JNC     ??mpu_lp_accel_mode_8
//  924         tmp[1] = INV_LPA_20HZ;
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x2
        MOVX    @DPTR,A
//  925         mpu_set_lpf(10);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0xa
        SJMP    ??mpu_lp_accel_mode_7
//  926     } else {
//  927         tmp[1] = INV_LPA_40HZ;
??mpu_lp_accel_mode_8:
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x3
        MOVX    @DPTR,A
//  928         mpu_set_lpf(20);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     R2,#0x14
??mpu_lp_accel_mode_7:
        MOV     R3,#0x0
??mpu_lp_accel_mode_5:
        LCALL   ??mpu_set_lpf?relay
//  929     }
//  930     tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        SWAP    A
        RLC     A
        RLC     A
        ANL     A,#0xc0
        ORL     A,#0x7
        MOVX    @DPTR,A
//  931     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_accel_mode_1 & 0xFFFF
//  932         return -1;
//  933 #elif defined MPU6500
//  934     /* Set wake frequency. */
//  935     if (rate == 1)
//  936         tmp[0] = INV_LPA_1_25HZ;
//  937     else if (rate == 2)
//  938         tmp[0] = INV_LPA_2_5HZ;
//  939     else if (rate <= 5)
//  940         tmp[0] = INV_LPA_5HZ;
//  941     else if (rate <= 10)
//  942         tmp[0] = INV_LPA_10HZ;
//  943     else if (rate <= 20)
//  944         tmp[0] = INV_LPA_20HZ;
//  945     else if (rate <= 40)
//  946         tmp[0] = INV_LPA_40HZ;
//  947     else if (rate <= 80)
//  948         tmp[0] = INV_LPA_80HZ;
//  949     else if (rate <= 160)
//  950         tmp[0] = INV_LPA_160HZ;
//  951     else if (rate <= 320)
//  952         tmp[0] = INV_LPA_320HZ;
//  953     else
//  954         tmp[0] = INV_LPA_640HZ;
//  955     if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
//  956         return -1;
//  957     tmp[0] = BIT_LPA_CYCLE;
//  958     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
//  959         return -1;
//  960 #endif
//  961     st.chip_cfg.sensors = INV_XYZ_ACCEL;
        MOV     DPTR,#st + 6
        MOV     A,#0x8
        MOVX    @DPTR,A
//  962     st.chip_cfg.clk_src = 0;
        MOV     DPTR,#st + 8
        CLR     A
        MOVX    @DPTR,A
//  963     st.chip_cfg.lp_accel_mode = 1;
        MOV     DPTR,#st + 15
        INC     A
        MOVX    @DPTR,A
//  964     mpu_configure_fifo(0);
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     R1,#0x0
        LCALL   ??mpu_configure_fifo?relay
//  965 
//  966     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_lp_accel_mode_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock4
//  967 }
//  968 
//  969 /**
//  970  *  @brief      Read raw gyro data directly from the registers.
//  971  *  @param[out] data        Raw data in hardware units.
//  972  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
//  973  *  @return     0 if successful.
//  974  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  975 int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
mpu_get_gyro_reg:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function mpu_get_gyro_reg
        CODE
//  976 {
        FUNCALL mpu_get_gyro_reg, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_get_gyro_reg, mget_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 6
        MOV     A,#-0x6
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
//  977     unsigned char tmp[6];
//  978 
//  979     if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        ANL     A,#0x70
        JNZ     ??mpu_get_gyro_reg_0
//  980         return -1;
??mpu_get_gyro_reg_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_get_gyro_reg_2 & 0xFFFF
//  981 
//  982     if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
??mpu_get_gyro_reg_0:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xc
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_get_gyro_reg_1
//  983         return -1;
//  984     data[0] = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  985     data[1] = (tmp[2] << 8) | tmp[3];
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  986     data[2] = (tmp[4] << 8) | tmp[5];
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  987     if (timestamp)
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??mpu_get_gyro_reg_3
//  988         get_ms(timestamp);
        ; Setup parameters for call to function mget_ms
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??mget_ms?relay
//  989     return 0;
??mpu_get_gyro_reg_3:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_gyro_reg_2:
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock5
//  990 }
//  991 
//  992 /**
//  993  *  @brief      Read raw accel data directly from the registers.
//  994  *  @param[out] data        Raw data in hardware units.
//  995  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
//  996  *  @return     0 if successful.
//  997  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  998 int mpu_get_accel_reg(short *data, unsigned long *timestamp)
mpu_get_accel_reg:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function mpu_get_accel_reg
        CODE
//  999 {
        FUNCALL mpu_get_accel_reg, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_get_accel_reg, mget_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 6
        MOV     A,#-0x6
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
// 1000     unsigned char tmp[6];
// 1001 
// 1002     if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JC      ??mpu_get_accel_reg_0
// 1003         return -1;
??mpu_get_accel_reg_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_get_accel_reg_2 & 0xFFFF
// 1004 
// 1005     if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
??mpu_get_accel_reg_0:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xd
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_get_accel_reg_1
// 1006         return -1;
// 1007     data[0] = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1008     data[1] = (tmp[2] << 8) | tmp[3];
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1009     data[2] = (tmp[4] << 8) | tmp[5];
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1010     if (timestamp)
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??mpu_get_accel_reg_3
// 1011         get_ms(timestamp);
        ; Setup parameters for call to function mget_ms
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??mget_ms?relay
// 1012     return 0;
??mpu_get_accel_reg_3:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_accel_reg_2:
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock6
// 1013 }
// 1014 
// 1015 /**
// 1016  *  @brief      Read temperature data directly from the registers.
// 1017  *  @param[out] data        Data in q16 format.
// 1018  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
// 1019  *  @return     0 if successful.
// 1020  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1021 int mpu_get_temperature(long *data, unsigned long *timestamp)
mpu_get_temperature:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function mpu_get_temperature
        CODE
// 1022 {
        FUNCALL mpu_get_temperature, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_get_temperature, mget_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
// 1023     unsigned char tmp[2];
// 1024     short raw;
// 1025 
// 1026     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_get_temperature_0
// 1027         return -1;
??mpu_get_temperature_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_get_temperature_2 & 0xFFFF
// 1028 
// 1029     if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
??mpu_get_temperature_0:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xe
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_get_temperature_1
// 1030         return -1;
// 1031     raw = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        MOV     A,R1
        MOV     ?V0 + 5,A
// 1032     if (timestamp)
        MOV     A,R6
        ORL     A,R7
        JZ      ??mpu_get_temperature_3
// 1033         get_ms(timestamp);
        ; Setup parameters for call to function mget_ms
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??mget_ms?relay
// 1034 
// 1035     data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
??mpu_get_temperature_3:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,?V0 + 5
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 4
        LCALL   ?L_TO_FLT
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 10,A
        MOV     ?V0 + 11,A
        MOV     R0,#?V0 + 8
        LCALL   ?L_TO_FLT
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_SUB
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        CLR     A
        MOV     ?V0 + 10,A
        MOV     ?V0 + 11,A
        MOV     R0,#?V0 + 8
        LCALL   ?UL_TO_FLT
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_DIV
        MOV     DPTR,#__Constant_420c0000
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_ADD
        MOV     DPTR,#__Constant_47800000
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 4
        LCALL   ?FLT_TO_L
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_TO_X
// 1036     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_temperature_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock7
// 1037 }
// 1038 
// 1039 /**
// 1040  *  @brief      Push biases to the accel bias registers.
// 1041  *  This function expects biases relative to the current sensor output, and
// 1042  *  these biases will be added to the factory-supplied values.
// 1043  *  @param[in]  accel_bias  New biases.
// 1044  *  @return     0 if successful.
// 1045  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1046 int mpu_set_accel_bias(const long *accel_bias)
mpu_set_accel_bias:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function mpu_set_accel_bias
        CODE
// 1047 {
        FUNCALL mpu_set_accel_bias, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_accel_bias, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_accel_bias, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 24
        MOV     A,#-0x18
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1048     unsigned char data[6];
// 1049     short accel_hw[3];
// 1050     short got_accel[3];
// 1051     short fg[3];
// 1052 
// 1053     if (!accel_bias)
        MOV     A,R6
        ORL     A,R7
        JNZ     ??mpu_set_accel_bias_0
// 1054         return -1;
??mpu_set_accel_bias_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
??mpu_set_accel_bias_2:
        MOV     A,#0x18
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI CFA_XSP16 add(XSP16, 40)
// 1055     if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
??mpu_set_accel_bias_0:
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        ORL     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??mpu_set_accel_bias_3
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        ORL     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??mpu_set_accel_bias_3
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        ORL     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??mpu_set_accel_bias_3
// 1056         return 0;
??mpu_set_accel_bias_4:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??mpu_set_accel_bias_2
// 1057 
// 1058     if (i2c_read(st.hw->addr, 3, 3, data))
??mpu_set_accel_bias_3:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x3
        MOV     R2,#0x3
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_set_accel_bias_1
// 1059         return -1;
// 1060     fg[0] = ((data[0] >> 4) + 8) & 0xf;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        ADD     A,#0x8
        ANL     A,#0xf
        MOV     R0,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
// 1061     fg[1] = ((data[1] >> 4) + 8) & 0xf;
        INC     A
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        ADD     A,#0x8
        ANL     A,#0xf
        MOV     R4,A
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
// 1062     fg[2] = ((data[2] >> 4) + 8) & 0xf;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        ADD     A,#0x8
        ANL     A,#0xf
        MOV     R2,A
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
// 1063 
// 1064     accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x1
        MOV     R0,#?V0 + 4
        LCALL   ?L_SHL
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x40
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?L_DIV_MOD
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 5
        MOVX    @DPTR,A
// 1065     accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     A,R4
        ADD     A,#0x40
        MOV     ?V0 + 4,A
        CLR     A
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?L_DIV_MOD
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 1066     accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     A,R2
        ADD     A,#0x40
        MOV     ?V0 + 4,A
        CLR     A
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?L_DIV_MOD
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 1067 
// 1068     if (i2c_read(st.hw->addr, 0x06, 6, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     R2,#0x6
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
// 1069         return -1;
// 1070 
// 1071     got_accel[0] = ((short)data[0] << 8) | data[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1072     got_accel[1] = ((short)data[2] << 8) | data[3];
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1073     got_accel[2] = ((short)data[4] << 8) | data[5];
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1074 
// 1075     accel_hw[0] += got_accel[0];
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R5
        MOVX    @DPTR,A
// 1076     accel_hw[1] += got_accel[1];
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOVX    @DPTR,A
// 1077     accel_hw[2] += got_accel[2];
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOVX    @DPTR,A
// 1078 
// 1079     data[0] = (accel_hw[0] >> 8) & 0xff;
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?SS_SHR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 1080     data[1] = (accel_hw[0]) & 0xff;
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1081     data[2] = (accel_hw[1] >> 8) & 0xff;
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?SS_SHR
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 1082     data[3] = (accel_hw[1]) & 0xff;
        MOV     A,R2
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1083     data[4] = (accel_hw[2] >> 8) & 0xff;
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?SS_SHR
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 1084     data[5] = (accel_hw[2]) & 0xff;
        MOV     A,R2
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1085 
// 1086     if (i2c_write(st.hw->addr, 0x06, 6, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x6
        MOV     R2,#0x6
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
        LJMP    ??mpu_set_accel_bias_4 & 0xFFFF
        CFI EndBlock cfiBlock8
// 1087         return -1;
// 1088     return 0;
// 1089 }
// 1090 
// 1091 /**
// 1092  *  @brief  Reset FIFO read/write pointers.
// 1093  *  @return 0 if successful.
// 1094  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1095 int mpu_reset_fifo(void)
mpu_reset_fifo:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function mpu_reset_fifo
        CODE
// 1096 {
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, delay_ms
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, delay_ms
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_reset_fifo, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 1)
// 1097     unsigned char data;
// 1098 
// 1099     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_reset_fifo_0
// 1100         return -1;
??mpu_reset_fifo_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_reset_fifo_2 & 0xFFFF
// 1101 
// 1102     data = 0;
??mpu_reset_fifo_0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 1103     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_reset_fifo_1
// 1104         return -1;
// 1105     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_reset_fifo_1
// 1106         return -1;
// 1107     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1108         return -1;
// 1109 
// 1110     if (st.chip_cfg.dmp_on) {
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JNZ     $+5
        LJMP    ??mpu_reset_fifo_3 & 0xFFFF
// 1111         data = BIT_FIFO_RST | BIT_DMP_RST;
        MOV     A,#0xc
        MOVX    @DPTR,A
// 1112         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1113             return -1;
// 1114         delay_ms(50);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_32
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1115         data = BIT_DMP_EN | BIT_FIFO_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x40
        MOVX    @DPTR,A
// 1116         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JNC     ??mpu_reset_fifo_4
// 1117             data |= BIT_AUX_IF_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x20
        MOVX    @DPTR,A
// 1118         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
??mpu_reset_fifo_4:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1119             return -1;
// 1120         if (st.chip_cfg.int_enable)
        MOV     DPTR,#st + 12
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_reset_fifo_5
// 1121             data = BIT_DMP_INT_EN;
        MOV     A,#0x2
        SJMP    ??mpu_reset_fifo_6
// 1122         else
// 1123             data = 0;
??mpu_reset_fifo_5:
        CLR     A
??mpu_reset_fifo_6:
        MOVX    @DPTR,A
// 1124         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1125             return -1;
// 1126         data = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 1127         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
        LJMP    ??mpu_reset_fifo_7 & 0xFFFF
// 1128             return -1;
// 1129     } else {
// 1130         data = BIT_FIFO_RST;
??mpu_reset_fifo_3:
        MOV     A,#0x4
        MOVX    @DPTR,A
// 1131         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1132             return -1;
// 1133         if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
        MOV     DPTR,#st + 13
        MOVX    A,@DPTR
        JNZ     ??mpu_reset_fifo_8
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JC      ??mpu_reset_fifo_9
// 1134             data = BIT_FIFO_EN;
??mpu_reset_fifo_8:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x40
        SJMP    ??mpu_reset_fifo_10
// 1135         else
// 1136             data = BIT_FIFO_EN | BIT_AUX_IF_EN;
??mpu_reset_fifo_9:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x60
??mpu_reset_fifo_10:
        MOVX    @DPTR,A
// 1137         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1138             return -1;
// 1139         delay_ms(50);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_32
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1140         if (st.chip_cfg.int_enable)
        MOV     DPTR,#st + 12
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_reset_fifo_11
// 1141             data = BIT_DATA_RDY_EN;
        MOV     A,#0x1
        SJMP    ??mpu_reset_fifo_12
// 1142         else
// 1143             data = 0;
??mpu_reset_fifo_11:
        CLR     A
??mpu_reset_fifo_12:
        MOVX    @DPTR,A
// 1144         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1145             return -1;
// 1146         if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,#(st + 11) & 0xff
        MOV     R5,#((st + 11) >> 8) & 0xff
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_reset_fifo_1 & 0xFFFF
// 1147             return -1;
// 1148     }
// 1149     return 0;
??mpu_reset_fifo_7:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_reset_fifo_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 XSP16+0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock9
// 1150 }
// 1151 
// 1152 /**
// 1153  *  @brief      Get the gyro full-scale range.
// 1154  *  @param[out] fsr Current full-scale range.
// 1155  *  @return     0 if successful.
// 1156  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1157 int mpu_get_gyro_fsr(unsigned short *fsr)
mpu_get_gyro_fsr:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function mpu_get_gyro_fsr
        CODE
// 1158 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1159     switch (st.chip_cfg.gyro_fsr) {
        MOV     DPTR,#st + 4
        MOVX    A,@DPTR
        JZ      ??mpu_get_gyro_fsr_0
        DEC     A
        JZ      ??mpu_get_gyro_fsr_1
        DEC     A
        JZ      ??mpu_get_gyro_fsr_2
        DEC     A
        JZ      ??mpu_get_gyro_fsr_3
        SJMP    ??mpu_get_gyro_fsr_4
// 1160     case INV_FSR_250DPS:
// 1161         fsr[0] = 250;
??mpu_get_gyro_fsr_0:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x6
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        SJMP    ??mpu_get_gyro_fsr_5
// 1162         break;
// 1163     case INV_FSR_500DPS:
// 1164         fsr[0] = 500;
??mpu_get_gyro_fsr_1:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0xc
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x1
        SJMP    ??mpu_get_gyro_fsr_5
// 1165         break;
// 1166     case INV_FSR_1000DPS:
// 1167         fsr[0] = 1000;
??mpu_get_gyro_fsr_2:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x18
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x3
        SJMP    ??mpu_get_gyro_fsr_5
// 1168         break;
// 1169     case INV_FSR_2000DPS:
// 1170         fsr[0] = 2000;
??mpu_get_gyro_fsr_3:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x30
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x7
        SJMP    ??mpu_get_gyro_fsr_5
// 1171         break;
// 1172     default:
// 1173         fsr[0] = 0;
??mpu_get_gyro_fsr_4:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
??mpu_get_gyro_fsr_5:
        MOVX    @DPTR,A
// 1174         break;
// 1175     }
// 1176     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock10
// 1177 }
// 1178 
// 1179 /**
// 1180  *  @brief      Set the gyro full-scale range.
// 1181  *  @param[in]  fsr Desired full-scale range.
// 1182  *  @return     0 if successful.
// 1183  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1184 int mpu_set_gyro_fsr(unsigned short fsr)
mpu_set_gyro_fsr:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function mpu_set_gyro_fsr
        CODE
// 1185 {
        FUNCALL mpu_set_gyro_fsr, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
// 1186     unsigned char data;
// 1187 
// 1188     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_set_gyro_fsr_0
// 1189         return -1;
??mpu_set_gyro_fsr_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_gyro_fsr_2 & 0xFFFF
// 1190 
// 1191     switch (fsr) {
??mpu_set_gyro_fsr_0:
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R0,#?V0 + 0
        LCALL   ?US_SWITCH_SPARSE
`?<Jumptable for mpu_set_gyro_fsr>_0`:
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        0
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        4
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        250
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_3
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        500
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_4
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        1000
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_5
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        2000
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_6
        DATA
        DATA16
        DATA
        DATA16
        DW        ??mpu_set_gyro_fsr_1
        CODE
// 1192     case 250:
// 1193         data = INV_FSR_250DPS << 3;
??mpu_set_gyro_fsr_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        SJMP    ??mpu_set_gyro_fsr_7
// 1194         break;
// 1195     case 500:
// 1196         data = INV_FSR_500DPS << 3;
??mpu_set_gyro_fsr_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x8
        SJMP    ??mpu_set_gyro_fsr_7
// 1197         break;
// 1198     case 1000:
// 1199         data = INV_FSR_1000DPS << 3;
??mpu_set_gyro_fsr_5:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x10
        SJMP    ??mpu_set_gyro_fsr_7
// 1200         break;
// 1201     case 2000:
// 1202         data = INV_FSR_2000DPS << 3;
??mpu_set_gyro_fsr_6:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x18
??mpu_set_gyro_fsr_7:
        MOVX    @DPTR,A
// 1203         break;
// 1204     default:
// 1205         return -1;
// 1206     }
// 1207 
// 1208     if (st.chip_cfg.gyro_fsr == (data >> 3))
        MOV     DPTR,#st + 4
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        XRL     A,R0
        JZ      ??mpu_set_gyro_fsr_8
// 1209         return 0;
// 1210     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_gyro_fsr_1 & 0xFFFF
// 1211         return -1;
// 1212     st.chip_cfg.gyro_fsr = data >> 3;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     DPTR,#st + 4
        MOVX    @DPTR,A
// 1213     return 0;
??mpu_set_gyro_fsr_8:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_gyro_fsr_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock11
// 1214 }
// 1215 
// 1216 /**
// 1217  *  @brief      Get the accel full-scale range.
// 1218  *  @param[out] fsr Current full-scale range.
// 1219  *  @return     0 if successful.
// 1220  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1221 int mpu_get_accel_fsr(unsigned char *fsr)
mpu_get_accel_fsr:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function mpu_get_accel_fsr
        CODE
// 1222 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1223     switch (st.chip_cfg.accel_fsr) {
        MOV     DPTR,#st + 5
        MOVX    A,@DPTR
        JZ      ??mpu_get_accel_fsr_0
        DEC     A
        JZ      ??mpu_get_accel_fsr_1
        DEC     A
        JZ      ??mpu_get_accel_fsr_2
        DEC     A
        JZ      ??mpu_get_accel_fsr_3
        SJMP    ??mpu_get_accel_fsr_4
// 1224     case INV_FSR_2G:
// 1225         fsr[0] = 2;
??mpu_get_accel_fsr_0:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x2
??mpu_get_accel_fsr_5:
        MOVX    @DPTR,A
// 1226         break;
// 1227     case INV_FSR_4G:
// 1228         fsr[0] = 4;
// 1229         break;
// 1230     case INV_FSR_8G:
// 1231         fsr[0] = 8;
// 1232         break;
// 1233     case INV_FSR_16G:
// 1234         fsr[0] = 16;
// 1235         break;
// 1236     default:
// 1237         return -1;
// 1238     }
// 1239     if (st.chip_cfg.accel_half)
        MOV     DPTR,#st + 14
        MOVX    A,@DPTR
        JZ      ??mpu_get_accel_fsr_6
// 1240         fsr[0] <<= 1;
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        CLR     C
        RLC     A
        MOVX    @DPTR,A
// 1241     return 0;
??mpu_get_accel_fsr_6:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_accel_fsr_7:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
??mpu_get_accel_fsr_1:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x4
        SJMP    ??mpu_get_accel_fsr_5
??mpu_get_accel_fsr_2:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x8
        SJMP    ??mpu_get_accel_fsr_5
??mpu_get_accel_fsr_3:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x10
        SJMP    ??mpu_get_accel_fsr_5
??mpu_get_accel_fsr_4:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_accel_fsr_7
        CFI EndBlock cfiBlock12
// 1242 }
// 1243 
// 1244 /**
// 1245  *  @brief      Set the accel full-scale range.
// 1246  *  @param[in]  fsr Desired full-scale range.
// 1247  *  @return     0 if successful.
// 1248  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1249 int mpu_set_accel_fsr(unsigned char fsr)
mpu_set_accel_fsr:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function mpu_set_accel_fsr
        CODE
// 1250 {
        FUNCALL mpu_set_accel_fsr, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
// 1251     unsigned char data;
// 1252 
// 1253     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_set_accel_fsr_0
// 1254         return -1;
??mpu_set_accel_fsr_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_accel_fsr_2 & 0xFFFF
// 1255 
// 1256     switch (fsr) {
??mpu_set_accel_fsr_0:
        MOV     A,R6
        ADD     A,#-0x2
        JZ      ??mpu_set_accel_fsr_3
        ADD     A,#-0x2
        JZ      ??mpu_set_accel_fsr_4
        ADD     A,#-0x4
        JZ      ??mpu_set_accel_fsr_5
        ADD     A,#-0x8
        JZ      ??mpu_set_accel_fsr_6
        SJMP    ??mpu_set_accel_fsr_1
// 1257     case 2:
// 1258         data = INV_FSR_2G << 3;
??mpu_set_accel_fsr_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        SJMP    ??mpu_set_accel_fsr_7
// 1259         break;
// 1260     case 4:
// 1261         data = INV_FSR_4G << 3;
??mpu_set_accel_fsr_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x8
        SJMP    ??mpu_set_accel_fsr_7
// 1262         break;
// 1263     case 8:
// 1264         data = INV_FSR_8G << 3;
??mpu_set_accel_fsr_5:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x10
        SJMP    ??mpu_set_accel_fsr_7
// 1265         break;
// 1266     case 16:
// 1267         data = INV_FSR_16G << 3;
??mpu_set_accel_fsr_6:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x18
??mpu_set_accel_fsr_7:
        MOVX    @DPTR,A
// 1268         break;
// 1269     default:
// 1270         return -1;
// 1271     }
// 1272 
// 1273     if (st.chip_cfg.accel_fsr == (data >> 3))
        MOV     DPTR,#st + 5
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        XRL     A,R0
        JZ      ??mpu_set_accel_fsr_8
// 1274         return 0;
// 1275     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_accel_fsr_1 & 0xFFFF
// 1276         return -1;
// 1277     st.chip_cfg.accel_fsr = data >> 3;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     DPTR,#st + 5
        MOVX    @DPTR,A
// 1278     return 0;
??mpu_set_accel_fsr_8:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_accel_fsr_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock13
// 1279 }
// 1280 
// 1281 /**
// 1282  *  @brief      Get the current DLPF setting.
// 1283  *  @param[out] lpf Current LPF setting.
// 1284  *  0 if successful.
// 1285  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1286 int mpu_get_lpf(unsigned short *lpf)
mpu_get_lpf:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function mpu_get_lpf
        CODE
// 1287 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1288     switch (st.chip_cfg.lpf) {
        MOV     DPTR,#st + 7
        MOVX    A,@DPTR
        DEC     A
        JZ      ??mpu_get_lpf_0
        DEC     A
        JZ      ??mpu_get_lpf_1
        DEC     A
        JZ      ??mpu_get_lpf_2
        DEC     A
        JZ      ??mpu_get_lpf_3
        DEC     A
        JZ      ??mpu_get_lpf_4
        DEC     A
        JZ      ??mpu_get_lpf_5
        SJMP    ??mpu_get_lpf_6
// 1289     case INV_FILTER_188HZ:
// 1290         lpf[0] = 188;
??mpu_get_lpf_0:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x44
??mpu_get_lpf_7:
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        SJMP    ??mpu_get_lpf_8
// 1291         break;
// 1292     case INV_FILTER_98HZ:
// 1293         lpf[0] = 98;
??mpu_get_lpf_1:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x62
        SJMP    ??mpu_get_lpf_7
// 1294         break;
// 1295     case INV_FILTER_42HZ:
// 1296         lpf[0] = 42;
??mpu_get_lpf_2:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x2a
        SJMP    ??mpu_get_lpf_7
// 1297         break;
// 1298     case INV_FILTER_20HZ:
// 1299         lpf[0] = 20;
??mpu_get_lpf_3:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x14
        SJMP    ??mpu_get_lpf_7
// 1300         break;
// 1301     case INV_FILTER_10HZ:
// 1302         lpf[0] = 10;
??mpu_get_lpf_4:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0xa
        SJMP    ??mpu_get_lpf_7
// 1303         break;
// 1304     case INV_FILTER_5HZ:
// 1305         lpf[0] = 5;
??mpu_get_lpf_5:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#0x5
        SJMP    ??mpu_get_lpf_7
// 1306         break;
// 1307     case INV_FILTER_256HZ_NOLPF2:
// 1308     case INV_FILTER_2100HZ_NOLPF:
// 1309     default:
// 1310         lpf[0] = 0;
??mpu_get_lpf_6:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
??mpu_get_lpf_8:
        MOVX    @DPTR,A
// 1311         break;
// 1312     }
// 1313     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock14
// 1314 }
// 1315 
// 1316 /**
// 1317  *  @brief      Set digital low pass filter.
// 1318  *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
// 1319  *  @param[in]  lpf Desired LPF setting.
// 1320  *  @return     0 if successful.
// 1321  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1322 int mpu_set_lpf(unsigned short lpf)
mpu_set_lpf:
        CFI Block cfiBlock15 Using cfiCommon0
        CFI Function mpu_set_lpf
        CODE
// 1323 {
        FUNCALL mpu_set_lpf, MPU_Write_Len
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 1, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 1, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 1)
// 1324     unsigned char data;
// 1325 
// 1326     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_set_lpf_0
// 1327         return -1;
??mpu_set_lpf_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_lpf_2 & 0xFFFF
// 1328 
// 1329     if (lpf >= 188)
??mpu_set_lpf_0:
        CLR     C
        MOV     A,R2
        SUBB    A,#-0x44
        MOV     A,R3
        SUBB    A,#0x0
        JC      ??mpu_set_lpf_3
// 1330         data = INV_FILTER_188HZ;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        SJMP    ??mpu_set_lpf_4
// 1331     else if (lpf >= 98)
??mpu_set_lpf_3:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x62
        MOV     A,R3
        SUBB    A,#0x0
        JC      ??mpu_set_lpf_5
// 1332         data = INV_FILTER_98HZ;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x2
        SJMP    ??mpu_set_lpf_4
// 1333     else if (lpf >= 42)
??mpu_set_lpf_5:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x2a
        MOV     A,R3
        SUBB    A,#0x0
        JC      ??mpu_set_lpf_6
// 1334         data = INV_FILTER_42HZ;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x3
        SJMP    ??mpu_set_lpf_4
// 1335     else if (lpf >= 20)
??mpu_set_lpf_6:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x14
        MOV     A,R3
        SUBB    A,#0x0
        JC      ??mpu_set_lpf_7
// 1336         data = INV_FILTER_20HZ;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x4
        SJMP    ??mpu_set_lpf_4
// 1337     else if (lpf >= 10)
??mpu_set_lpf_7:
        CLR     C
        MOV     A,R2
        SUBB    A,#0xa
        MOV     A,R3
        SUBB    A,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JC      ??mpu_set_lpf_8
// 1338         data = INV_FILTER_10HZ;
        MOV     A,#0x5
        SJMP    ??mpu_set_lpf_4
// 1339     else
// 1340         data = INV_FILTER_5HZ;
??mpu_set_lpf_8:
        MOV     A,#0x6
??mpu_set_lpf_4:
        MOVX    @DPTR,A
// 1341 
// 1342     if (st.chip_cfg.lpf == data)
        MOV     DPTR,#st + 7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,R0
        JZ      ??mpu_set_lpf_9
// 1343         return 0;
// 1344     if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_lpf_1 & 0xFFFF
// 1345         return -1;
// 1346     st.chip_cfg.lpf = data;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     DPTR,#st + 7
        MOVX    @DPTR,A
// 1347     return 0;
??mpu_set_lpf_9:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_lpf_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 XSP16+0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock15
// 1348 }
// 1349 
// 1350 /**
// 1351  *  @brief      Get sampling rate.
// 1352  *  @param[out] rate    Current sampling rate (Hz).
// 1353  *  @return     0 if successful.
// 1354  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1355 int mpu_get_sample_rate(unsigned short *rate)
mpu_get_sample_rate:
        CFI Block cfiBlock16 Using cfiCommon0
        CFI Function mpu_get_sample_rate
        CODE
// 1356 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1357     if (st.chip_cfg.dmp_on)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_get_sample_rate_0
// 1358         return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_sample_rate_1
// 1359     else
// 1360         rate[0] = st.chip_cfg.sample_rate;
??mpu_get_sample_rate_0:
        MOV     DPTR,#st + 9
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1361     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_sample_rate_1:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock16
// 1362 }
// 1363 
// 1364 /**
// 1365  *  @brief      Set sampling rate.
// 1366  *  Sampling rate must be between 4Hz and 1kHz.
// 1367  *  @param[in]  rate    Desired sampling rate (Hz).
// 1368  *  @return     0 if successful.
// 1369  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1370 int mpu_set_sample_rate(unsigned short rate)
mpu_set_sample_rate:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function mpu_set_sample_rate
        CODE
// 1371 {
        FUNCALL mpu_set_sample_rate, mpu_lp_accel_mode
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sample_rate, mpu_lp_accel_mode
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sample_rate, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sample_rate, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1372     unsigned char data;
// 1373 
// 1374     if (!(st.chip_cfg.sensors))
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_set_sample_rate_0
// 1375         return -1;
??mpu_set_sample_rate_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_sample_rate_2 & 0xFFFF
// 1376 
// 1377     if (st.chip_cfg.dmp_on)
??mpu_set_sample_rate_0:
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JNZ     ??mpu_set_sample_rate_1
// 1378         return -1;
// 1379     else {
// 1380         if (st.chip_cfg.lp_accel_mode) {
        MOV     DPTR,#st + 15
        MOVX    A,@DPTR
        JZ      ??mpu_set_sample_rate_3
// 1381             if (rate && (rate <= 40)) {
        MOV     A,R6
        ORL     A,R7
        JZ      ??mpu_set_sample_rate_4
        CLR     C
        MOV     A,R6
        SUBB    A,#0x29
        MOV     A,R7
        SUBB    A,#0x0
        JNC     ??mpu_set_sample_rate_4
// 1382                 /* Just stay in low-power accel mode. */
// 1383                 mpu_lp_accel_mode(rate);
        ; Setup parameters for call to function mpu_lp_accel_mode
        MOV     A,R6
        MOV     R1,A
        LCALL   ??mpu_lp_accel_mode?relay
// 1384                 return 0;
        LJMP    ??mpu_set_sample_rate_5 & 0xFFFF
// 1385             }
// 1386             /* Requested rate exceeds the allowed frequencies in LP accel mode,
// 1387              * switch back to full-power mode.
// 1388              */
// 1389             mpu_lp_accel_mode(0);
??mpu_set_sample_rate_4:
        ; Setup parameters for call to function mpu_lp_accel_mode
        MOV     R1,#0x0
        LCALL   ??mpu_lp_accel_mode?relay
// 1390         }
// 1391         if (rate < 4)
??mpu_set_sample_rate_3:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x4
        MOV     A,R7
        SUBB    A,#0x0
        JNC     ??mpu_set_sample_rate_6
// 1392             rate = 4;
        MOV     R6,#0x4
        MOV     R7,#0x0
        SJMP    ??mpu_set_sample_rate_7
// 1393         else if (rate > 1000)
??mpu_set_sample_rate_6:
        CLR     C
        MOV     A,R6
        SUBB    A,#-0x17
        MOV     A,R7
        SUBB    A,#0x3
        JC      ??mpu_set_sample_rate_7
// 1394             rate = 1000;
        MOV     R6,#-0x18
        MOV     R7,#0x3
// 1395 
// 1396         data = 1000 / rate - 1;
??mpu_set_sample_rate_7:
        MOV     R0,#-0x18
        MOV     R1,#0x3
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        DEC     A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 1397         if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_sample_rate_1 & 0xFFFF
// 1398             return -1;
// 1399 
// 1400         st.chip_cfg.sample_rate = 1000 / (1 + data);
        MOV     R0,#-0x18
        MOV     R1,#0x3
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        CLR     A
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ?S_DIV_MOD
        MOV     DPTR,#st + 9
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1401 
// 1402 #ifdef AK89xx_SECONDARY
// 1403         mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
// 1404 #endif
// 1405 
// 1406         /* Automatically set LPF to 1/2 sampling rate. */
// 1407         mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     DPTR,#st + 9
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        RRC     A
        MOV     R3,A
        MOV     A,R2
        RRC     A
        MOV     R2,A
        LCALL   ??mpu_set_lpf?relay
// 1408         return 0;
??mpu_set_sample_rate_5:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_sample_rate_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock17
// 1409     }
// 1410 }
// 1411 
// 1412 /**
// 1413  *  @brief      Get compass sampling rate.
// 1414  *  @param[out] rate    Current compass sampling rate (Hz).
// 1415  *  @return     0 if successful.
// 1416  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1417 int mpu_get_compass_sample_rate(unsigned short *rate)
mpu_get_compass_sample_rate:
        CFI Block cfiBlock18 Using cfiCommon0
        CFI Function mpu_get_compass_sample_rate
        CODE
// 1418 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1419 #ifdef AK89xx_SECONDARY
// 1420     rate[0] = st.chip_cfg.compass_sample_rate;
// 1421     return 0;
// 1422 #else
// 1423     rate[0] = 0;
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 1424     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock18
// 1425 #endif
// 1426 }
// 1427 
// 1428 /**
// 1429  *  @brief      Set compass sampling rate.
// 1430  *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
// 1431  *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
// 1432  *  sampling rate.
// 1433  *
// 1434  *  \n WARNING: The new rate may be different than what was requested. Call
// 1435  *  mpu_get_compass_sample_rate to check the actual setting.
// 1436  *  @param[in]  rate    Desired compass sampling rate (Hz).
// 1437  *  @return     0 if successful.
// 1438  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1439 int mpu_set_compass_sample_rate(unsigned short rate)
mpu_set_compass_sample_rate:
        CFI Block cfiBlock19 Using cfiCommon0
        CFI Function mpu_set_compass_sample_rate
        CODE
// 1440 {
        ; Saved register size: 0
        ; Auto size: 0
// 1441 #ifdef AK89xx_SECONDARY
// 1442     unsigned char div;
// 1443     if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
// 1444         return -1;
// 1445 
// 1446     div = st.chip_cfg.sample_rate / rate - 1;
// 1447     if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
// 1448         return -1;
// 1449     st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
// 1450     return 0;
// 1451 #else
// 1452     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ?BRET
        CFI EndBlock cfiBlock19
// 1453 #endif
// 1454 }
// 1455 
// 1456 /**
// 1457  *  @brief      Get gyro sensitivity scale factor.
// 1458  *  @param[out] sens    Conversion from hardware units to dps.
// 1459  *  @return     0 if successful.
// 1460  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1461 int mpu_get_gyro_sens(float *sens)
mpu_get_gyro_sens:
        CFI Block cfiBlock20 Using cfiCommon0
        CFI Function mpu_get_gyro_sens
        CODE
// 1462 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
// 1463     switch (st.chip_cfg.gyro_fsr) {
        MOV     DPTR,#st + 4
        MOVX    A,@DPTR
        JZ      ??mpu_get_gyro_sens_0
        DEC     A
        JZ      ??mpu_get_gyro_sens_1
        DEC     A
        JZ      ??mpu_get_gyro_sens_2
        DEC     A
        JZ      ??mpu_get_gyro_sens_3
        SJMP    ??mpu_get_gyro_sens_4
// 1464     case INV_FSR_250DPS:
// 1465         sens[0] = 131.f;
??mpu_get_gyro_sens_0:
        MOV     DPTR,#__Constant_43030000
??mpu_get_gyro_sens_5:
        LCALL   ?XLOAD_R2345
        MOV     DPL,R0
        MOV     DPH,R1
        LCALL   ?XSTORE_R2345
// 1466         break;
// 1467     case INV_FSR_500DPS:
// 1468         sens[0] = 65.5f;
// 1469         break;
// 1470     case INV_FSR_1000DPS:
// 1471         sens[0] = 32.8f;
// 1472         break;
// 1473     case INV_FSR_2000DPS:
// 1474         sens[0] = 16.4f;
// 1475         break;
// 1476     default:
// 1477         return -1;
// 1478     }
// 1479     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_gyro_sens_6:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
??mpu_get_gyro_sens_1:
        MOV     DPTR,#__Constant_42830000
        SJMP    ??mpu_get_gyro_sens_5
??mpu_get_gyro_sens_2:
        MOV     DPTR,#__Constant_42033333
        SJMP    ??mpu_get_gyro_sens_5
??mpu_get_gyro_sens_3:
        MOV     DPTR,#__Constant_41833333
        SJMP    ??mpu_get_gyro_sens_5
??mpu_get_gyro_sens_4:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_gyro_sens_6
        CFI EndBlock cfiBlock20
// 1480 }
// 1481 
// 1482 /**
// 1483  *  @brief      Get accel sensitivity scale factor.
// 1484  *  @param[out] sens    Conversion from hardware units to g's.
// 1485  *  @return     0 if successful.
// 1486  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1487 int mpu_get_accel_sens(unsigned short *sens)
mpu_get_accel_sens:
        CFI Block cfiBlock21 Using cfiCommon0
        CFI Function mpu_get_accel_sens
        CODE
// 1488 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1489     switch (st.chip_cfg.accel_fsr) {
        MOV     DPTR,#st + 5
        MOVX    A,@DPTR
        JZ      ??mpu_get_accel_sens_0
        DEC     A
        JZ      ??mpu_get_accel_sens_1
        DEC     A
        JZ      ??mpu_get_accel_sens_2
        DEC     A
        JZ      ??mpu_get_accel_sens_3
        SJMP    ??mpu_get_accel_sens_4
// 1490     case INV_FSR_2G:
// 1491         sens[0] = 16384;
??mpu_get_accel_sens_0:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x40
??mpu_get_accel_sens_5:
        MOVX    @DPTR,A
// 1492         break;
// 1493     case INV_FSR_4G:
// 1494         sens[0] = 8092;
// 1495         break;
// 1496     case INV_FSR_8G:
// 1497         sens[0] = 4096;
// 1498         break;
// 1499     case INV_FSR_16G:
// 1500         sens[0] = 2048;
// 1501         break;
// 1502     default:
// 1503         return -1;
// 1504     }
// 1505     if (st.chip_cfg.accel_half)
        MOV     DPTR,#st + 14
        MOVX    A,@DPTR
        JZ      ??mpu_get_accel_sens_6
// 1506         sens[0] >>= 1;
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        RRC     A
        MOV     R1,A
        MOV     A,R0
        RRC     A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1507     return 0;
??mpu_get_accel_sens_6:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_accel_sens_7:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
??mpu_get_accel_sens_1:
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,#-0x64
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x1f
        SJMP    ??mpu_get_accel_sens_5
??mpu_get_accel_sens_2:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x10
        SJMP    ??mpu_get_accel_sens_5
??mpu_get_accel_sens_3:
        MOV     DPL,R2
        MOV     DPH,R3
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x8
        SJMP    ??mpu_get_accel_sens_5
??mpu_get_accel_sens_4:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_accel_sens_7
        CFI EndBlock cfiBlock21
// 1508 }
// 1509 
// 1510 /**
// 1511  *  @brief      Get current FIFO configuration.
// 1512  *  @e sensors can contain a combination of the following flags:
// 1513  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
// 1514  *  \n INV_XYZ_GYRO
// 1515  *  \n INV_XYZ_ACCEL
// 1516  *  @param[out] sensors Mask of sensors in FIFO.
// 1517  *  @return     0 if successful.
// 1518  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1519 int mpu_get_fifo_config(unsigned char *sensors)
mpu_get_fifo_config:
        CFI Block cfiBlock22 Using cfiCommon0
        CFI Function mpu_get_fifo_config
        CODE
// 1520 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1521     sensors[0] = st.chip_cfg.fifo_enable;
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
// 1522     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock22
// 1523 }
// 1524 
// 1525 /**
// 1526  *  @brief      Select which sensors are pushed to FIFO.
// 1527  *  @e sensors can contain a combination of the following flags:
// 1528  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
// 1529  *  \n INV_XYZ_GYRO
// 1530  *  \n INV_XYZ_ACCEL
// 1531  *  @param[in]  sensors Mask of sensors to push to FIFO.
// 1532  *  @return     0 if successful.
// 1533  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1534 int mpu_configure_fifo(unsigned char sensors)
mpu_configure_fifo:
        CFI Block cfiBlock23 Using cfiCommon0
        CFI Function mpu_configure_fifo
        CODE
// 1535 {
        FUNCALL mpu_configure_fifo, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_configure_fifo, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_configure_fifo, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
// 1536     unsigned char prev;
// 1537     int result = 0;
// 1538 
// 1539     /* Compass data isn't going into the FIFO. Stop trying. */
// 1540     sensors &= ~INV_XYZ_COMPASS;
        MOV     A,R1
        CLR     0xE0 /* A   */.0
        MOV     ?V0 + 0,A
// 1541 
// 1542     if (st.chip_cfg.dmp_on)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_configure_fifo_0
// 1543         return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??mpu_configure_fifo_1
// 1544     else {
// 1545         if (!(st.chip_cfg.sensors))
??mpu_configure_fifo_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     R0,A
        JNZ     ??mpu_configure_fifo_2
// 1546             return -1;
??mpu_configure_fifo_3:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_configure_fifo_1
// 1547         prev = st.chip_cfg.fifo_enable;
??mpu_configure_fifo_2:
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 1548         st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
        MOV     A,?V0 + 0
        ANL     A,R0
        MOV     R0,A
        MOVX    @DPTR,A
// 1549         if (st.chip_cfg.fifo_enable != sensors)
        MOV     A,?V0 + 0
        XRL     A,R0
        JZ      ??mpu_configure_fifo_4
// 1550             /* You're not getting what you asked for. Some sensors are
// 1551              * asleep.
// 1552              */
// 1553             result = -1;
        MOV     R6,#-0x1
        MOV     R7,#-0x1
        SJMP    ??mpu_configure_fifo_5
// 1554         else
// 1555             result = 0;
??mpu_configure_fifo_4:
        MOV     R6,#0x0
        MOV     R7,#0x0
// 1556         if (sensors || st.chip_cfg.lp_accel_mode)
??mpu_configure_fifo_5:
        MOV     A,?V0 + 0
        JNZ     ??mpu_configure_fifo_6
        MOV     DPTR,#st + 15
        MOVX    A,@DPTR
        JZ      ??mpu_configure_fifo_7
// 1557             set_int_enable(1);
??mpu_configure_fifo_6:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x1
        SJMP    ??mpu_configure_fifo_8
// 1558         else
// 1559             set_int_enable(0);
??mpu_configure_fifo_7:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x0
??mpu_configure_fifo_8:
        LCALL   ??set_int_enable?relay
// 1560         if (sensors) {
        MOV     A,?V0 + 0
        JZ      ??mpu_configure_fifo_9
// 1561             if (mpu_reset_fifo()) {
        ; Setup parameters for call to function mpu_reset_fifo
        LCALL   ??mpu_reset_fifo?relay
        MOV     ?V0 + 3,R3
        MOV     A,R2
        ORL     A,?V0 + 3
        JZ      ??mpu_configure_fifo_9
// 1562                 st.chip_cfg.fifo_enable = prev;
        MOV     A,?V0 + 1
        MOV     DPTR,#st + 11
        MOVX    @DPTR,A
// 1563                 return -1;
        SJMP    ??mpu_configure_fifo_3
// 1564             }
// 1565         }
// 1566     }
// 1567 
// 1568     return result;
??mpu_configure_fifo_9:
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
??mpu_configure_fifo_1:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock23
// 1569 }
// 1570 
// 1571 /**
// 1572  *  @brief      Get current power state.
// 1573  *  @param[in]  power_on    1 if turned on, 0 if suspended.
// 1574  *  @return     0 if successful.
// 1575  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1576 int mpu_get_power_state(unsigned char *power_on)
mpu_get_power_state:
        CFI Block cfiBlock24 Using cfiCommon0
        CFI Function mpu_get_power_state
        CODE
// 1577 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1578     if (st.chip_cfg.sensors)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     DPL,R2
        MOV     DPH,R3
        JZ      ??mpu_get_power_state_0
// 1579         power_on[0] = 1;
        MOV     A,#0x1
        SJMP    ??mpu_get_power_state_1
// 1580     else
// 1581         power_on[0] = 0;
??mpu_get_power_state_0:
        CLR     A
??mpu_get_power_state_1:
        MOVX    @DPTR,A
// 1582     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock24
// 1583 }
// 1584 
// 1585 /**
// 1586  *  @brief      Turn specific sensors on/off.
// 1587  *  @e sensors can contain a combination of the following flags:
// 1588  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
// 1589  *  \n INV_XYZ_GYRO
// 1590  *  \n INV_XYZ_ACCEL
// 1591  *  \n INV_XYZ_COMPASS
// 1592  *  @param[in]  sensors    Mask of sensors to wake.
// 1593  *  @return     0 if successful.
// 1594  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1595 int mpu_set_sensors(unsigned char sensors)
mpu_set_sensors:
        CFI Block cfiBlock25 Using cfiCommon0
        CFI Function mpu_set_sensors
        CODE
// 1596 {
        FUNCALL mpu_set_sensors, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sensors, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sensors, mpu_set_int_latched
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_sensors, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
// 1597     unsigned char data;
// 1598 #ifdef AK89xx_SECONDARY
// 1599     unsigned char user_ctrl;
// 1600 #endif
// 1601 
// 1602     if (sensors & INV_XYZ_GYRO)
        MOV     A,#0x70
        ANL     A,R6
        JZ      ??mpu_set_sensors_0
// 1603         data = INV_CLK_PLL;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        SJMP    ??mpu_set_sensors_1
// 1604     else if (sensors)
??mpu_set_sensors_0:
        MOV     A,R6
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_set_sensors_2
// 1605         data = 0;
        CLR     A
        SJMP    ??mpu_set_sensors_1
// 1606     else
// 1607         data = BIT_SLEEP;
??mpu_set_sensors_2:
        MOV     A,#0x40
??mpu_set_sensors_1:
        MOVX    @DPTR,A
// 1608     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??mpu_set_sensors_3
// 1609         st.chip_cfg.sensors = 0;
??mpu_set_sensors_4:
        MOV     DPTR,#st + 6
        CLR     A
        MOVX    @DPTR,A
// 1610         return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_sensors_5 & 0xFFFF
// 1611     }
// 1612     st.chip_cfg.clk_src = data & ~BIT_SLEEP;
??mpu_set_sensors_3:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0xbf
        MOV     DPTR,#st + 8
        MOVX    @DPTR,A
// 1613 
// 1614     data = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 1615     if (!(sensors & INV_X_GYRO))
        MOV     A,R6
        MOV     C,0xE0 /* A   */.6
        JC      ??mpu_set_sensors_6
// 1616         data |= BIT_STBY_XG;
        MOV     A,#0x4
        MOVX    @DPTR,A
// 1617     if (!(sensors & INV_Y_GYRO))
??mpu_set_sensors_6:
        MOV     A,R6
        MOV     C,0xE0 /* A   */.5
        JC      ??mpu_set_sensors_7
// 1618         data |= BIT_STBY_YG;
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
// 1619     if (!(sensors & INV_Z_GYRO))
??mpu_set_sensors_7:
        MOV     A,R6
        MOV     C,0xE0 /* A   */.4
        JC      ??mpu_set_sensors_8
// 1620         data |= BIT_STBY_ZG;
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
// 1621     if (!(sensors & INV_XYZ_ACCEL))
??mpu_set_sensors_8:
        MOV     A,R6
        MOV     C,0xE0 /* A   */.3
        JC      ??mpu_set_sensors_9
// 1622         data |= BIT_STBY_XYZA;
        MOVX    A,@DPTR
        ORL     A,#0x38
        MOVX    @DPTR,A
// 1623     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
??mpu_set_sensors_9:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x13
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_set_sensors_4
// 1624         st.chip_cfg.sensors = 0;
// 1625         return -1;
// 1626     }
// 1627 
// 1628     if (sensors && (sensors != INV_XYZ_ACCEL))
        MOV     A,R6
        JZ      ??mpu_set_sensors_10
        MOV     A,#0x8
        XRL     A,R6
        JZ      ??mpu_set_sensors_10
// 1629         /* Latched interrupts only used in LP accel mode. */
// 1630         mpu_set_int_latched(0);
        ; Setup parameters for call to function mpu_set_int_latched
        MOV     R1,#0x0
        LCALL   ??mpu_set_int_latched?relay
// 1631 
// 1632 #ifdef AK89xx_SECONDARY
// 1633 #ifdef AK89xx_BYPASS
// 1634     if (sensors & INV_XYZ_COMPASS)
// 1635         mpu_set_bypass(1);
// 1636     else
// 1637         mpu_set_bypass(0);
// 1638 #else
// 1639     if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
// 1640         return -1;
// 1641     /* Handle AKM power management. */
// 1642     if (sensors & INV_XYZ_COMPASS) {
// 1643         data = AKM_SINGLE_MEASUREMENT;
// 1644         user_ctrl |= BIT_AUX_IF_EN;
// 1645     } else {
// 1646         data = AKM_POWER_DOWN;
// 1647         user_ctrl &= ~BIT_AUX_IF_EN;
// 1648     }
// 1649     if (st.chip_cfg.dmp_on)
// 1650         user_ctrl |= BIT_DMP_EN;
// 1651     else
// 1652         user_ctrl &= ~BIT_DMP_EN;
// 1653     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
// 1654         return -1;
// 1655     /* Enable/disable I2C master mode. */
// 1656     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
// 1657         return -1;
// 1658 #endif
// 1659 #endif
// 1660 
// 1661     st.chip_cfg.sensors = sensors;
??mpu_set_sensors_10:
        MOV     A,R6
        MOV     DPTR,#st + 6
        MOVX    @DPTR,A
// 1662     st.chip_cfg.lp_accel_mode = 0;
        MOV     DPTR,#st + 15
        CLR     A
        MOVX    @DPTR,A
// 1663     delay_ms(50);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_32
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1664     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_sensors_5:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock25
// 1665 }
// 1666 
// 1667 /**
// 1668  *  @brief      Read the MPU interrupt status registers.
// 1669  *  @param[out] status  Mask of interrupt bits.
// 1670  *  @return     0 if successful.
// 1671  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1672 int mpu_get_int_status(short *status)
mpu_get_int_status:
        CFI Block cfiBlock26 Using cfiCommon0
        CFI Function mpu_get_int_status
        CODE
// 1673 {
        FUNCALL mpu_get_int_status, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1674     unsigned char tmp[2];
// 1675     if (!st.chip_cfg.sensors)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JNZ     ??mpu_get_int_status_0
// 1676         return -1;
??mpu_get_int_status_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_get_int_status_2
// 1677     if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
??mpu_get_int_status_0:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x10
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_get_int_status_1
// 1678         return -1;
// 1679     status[0] = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1680     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_get_int_status_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock26
// 1681 }
// 1682 
// 1683 /**
// 1684  *  @brief      Get one packet from the FIFO.
// 1685  *  If @e sensors does not contain a particular sensor, disregard the data
// 1686  *  returned to that pointer.
// 1687  *  \n @e sensors can contain a combination of the following flags:
// 1688  *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
// 1689  *  \n INV_XYZ_GYRO
// 1690  *  \n INV_XYZ_ACCEL
// 1691  *  \n If the FIFO has no new data, @e sensors will be zero.
// 1692  *  \n If the FIFO is disabled, @e sensors will be zero and this function will
// 1693  *  return a non-zero error code.
// 1694  *  @param[out] gyro        Gyro data in hardware units.
// 1695  *  @param[out] accel       Accel data in hardware units.
// 1696  *  @param[out] timestamp   Timestamp in milliseconds.
// 1697  *  @param[out] sensors     Mask of sensors read from FIFO.
// 1698  *  @param[out] more        Number of remaining packets.
// 1699  *  @return     0 if successful.
// 1700  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1701 int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
mpu_read_fifo:
        CFI Block cfiBlock27 Using cfiCommon0
        CFI Function mpu_read_fifo
        CODE
// 1702         unsigned char *sensors, unsigned char *more)
// 1703 {
        FUNCALL mpu_read_fifo, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo, mget_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 12
        MOV     A,#-0xc
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 8,R4
        MOV     ?V0 + 9,R5
        MOV     A,#0x24
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 12,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 13,A
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
// 1704     /* Assumes maximum packet size is gyro (6) + accel (6). */
// 1705     unsigned char data[MAX_PACKET_LENGTH];
// 1706     unsigned char packet_size = 0;
        MOV     ?V0 + 0,#0x0
// 1707     unsigned short fifo_count, index = 0;
        MOV     ?V0 + 2,#0x0
        MOV     ?V0 + 3,#0x0
// 1708 
// 1709     if (st.chip_cfg.dmp_on)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_read_fifo_0
// 1710         return -1;
??mpu_read_fifo_1:
        MOV     R2,#-0x1
??mpu_read_fifo_2:
        MOV     R3,#-0x1
??mpu_read_fifo_3:
        MOV     A,#0xc
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI CFA_XSP16 add(XSP16, 36)
// 1711 
// 1712     sensors[0] = 0;
??mpu_read_fifo_0:
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        CLR     A
        MOVX    @DPTR,A
// 1713     if (!st.chip_cfg.sensors)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??mpu_read_fifo_1
// 1714         return -1;
// 1715     if (!st.chip_cfg.fifo_enable)
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        JZ      ??mpu_read_fifo_1
// 1716         return -1;
// 1717 
// 1718     if (st.chip_cfg.fifo_enable & INV_X_GYRO)
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.6
        JNC     ??mpu_read_fifo_4
// 1719         packet_size += 2;
        MOV     ?V0 + 0,#0x2
// 1720     if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
??mpu_read_fifo_4:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.5
        JNC     ??mpu_read_fifo_5
// 1721         packet_size += 2;
        INC     ?V0 + 0
        INC     ?V0 + 0
// 1722     if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
??mpu_read_fifo_5:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??mpu_read_fifo_6
// 1723         packet_size += 2;
        INC     ?V0 + 0
        INC     ?V0 + 0
// 1724     if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
??mpu_read_fifo_6:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JNC     ??mpu_read_fifo_7
// 1725         packet_size += 6;
        MOV     A,#0x6
        ADD     A,?V0 + 0
        MOV     ?V0 + 0,A
// 1726 
// 1727     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
??mpu_read_fifo_7:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_read_fifo_1
// 1728         return -1;
// 1729     fifo_count = (data[0] << 8) | data[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
// 1730     if (fifo_count < packet_size)
        MOV     DPL,?V0 + 0
        MOV     ?V0 + 4,DPL
        CLR     C
        MOV     A,R6
        SUBB    A,?V0 + 4
        MOV     A,R7
        SUBB    A,#0x0
        JNC     ??mpu_read_fifo_8
// 1731         return 0;
??mpu_read_fifo_9:
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??mpu_read_fifo_3 & 0xFFFF
// 1732 //    log_i("FIFO count: %hd\n", fifo_count);
// 1733     if (fifo_count > (st.hw->max_fifo >> 1)) {
??mpu_read_fifo_8:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        RRC     A
        MOV     R3,A
        MOV     A,R2
        RRC     A
        CLR     C
        SUBB    A,R6
        MOV     A,R3
        SUBB    A,R7
        JNC     ??mpu_read_fifo_10
// 1734         /* FIFO is 50% full, better check overflow bit. */
// 1735         if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x11
        MOV     ?V0 + 14,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     DPL,?V0 + 14
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_fifo_1 & 0xFFFF
// 1736             return -1;
// 1737         if (data[0] & BIT_FIFO_OVERFLOW) {
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??mpu_read_fifo_10
// 1738             mpu_reset_fifo();
        ; Setup parameters for call to function mpu_reset_fifo
        LCALL   ??mpu_reset_fifo?relay
// 1739             return -2;
        MOV     R2,#-0x2
        LJMP    ??mpu_read_fifo_2 & 0xFFFF
// 1740         }
// 1741     }
// 1742     get_ms((unsigned long*)timestamp);
??mpu_read_fifo_10:
        ; Setup parameters for call to function mget_ms
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        LCALL   ??mget_ms?relay
// 1743 
// 1744     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,?V0 + 0
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_fifo_1 & 0xFFFF
// 1745         return -1;
// 1746     more[0] = fifo_count / packet_size - 1;
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     R2,?V0 + 4
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        DEC     A
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1747     sensors[0] = 0;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        CLR     A
        MOVX    @DPTR,A
// 1748 
// 1749     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
        MOV     A,?V0 + 0
        JZ      ??mpu_read_fifo_11
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JNC     ??mpu_read_fifo_11
// 1750         accel[0] = (data[index+0] << 8) | data[index+1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1751         accel[1] = (data[index+2] << 8) | data[index+3];
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1752         accel[2] = (data[index+4] << 8) | data[index+5];
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1753         sensors[0] |= INV_XYZ_ACCEL;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.3
        MOVX    @DPTR,A
// 1754         index += 6;
        MOV     ?V0 + 2,#0x6
// 1755     }
// 1756     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
??mpu_read_fifo_11:
        MOV     A,?V0 + 4
        XRL     A,?V0 + 2
        JNZ     ??mpu_read_fifo_12
        CLR     A
??mpu_read_fifo_12:
        JZ      ??mpu_read_fifo_13
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.6
        JNC     ??mpu_read_fifo_13
// 1757         gyro[0] = (data[index+0] << 8) | data[index+1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 2
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1758         sensors[0] |= INV_X_GYRO;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.6
        MOVX    @DPTR,A
// 1759         index += 2;
        MOV     A,?V0 + 2
        ADD     A,#0x2
        MOV     ?V0 + 2,A
        CLR     A
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 1760     }
// 1761     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
??mpu_read_fifo_13:
        MOV     A,?V0 + 4
        XRL     A,?V0 + 2
        JNZ     ??mpu_read_fifo_14
        MOV     A,?V0 + 3
??mpu_read_fifo_14:
        JZ      ??mpu_read_fifo_15
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.5
        JNC     ??mpu_read_fifo_15
// 1762         gyro[1] = (data[index+0] << 8) | data[index+1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 2
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1763         sensors[0] |= INV_Y_GYRO;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.5
        MOVX    @DPTR,A
// 1764         index += 2;
        MOV     A,?V0 + 2
        ADD     A,#0x2
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 1765     }
// 1766     if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
??mpu_read_fifo_15:
        MOV     A,?V0 + 4
        XRL     A,?V0 + 2
        JNZ     ??mpu_read_fifo_16
        MOV     A,?V0 + 3
??mpu_read_fifo_16:
        JNZ     $+5
        LJMP    ??mpu_read_fifo_9 & 0xFFFF
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JC      $+5
        LJMP    ??mpu_read_fifo_9 & 0xFFFF
// 1767         gyro[2] = (data[index+0] << 8) | data[index+1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 2
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1768         sensors[0] |= INV_Z_GYRO;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.4
        MOVX    @DPTR,A
// 1769         index += 2;
        LJMP    ??mpu_read_fifo_9 & 0xFFFF
        CFI EndBlock cfiBlock27
// 1770     }
// 1771 
// 1772     return 0;
// 1773 }
// 1774 
// 1775 /**
// 1776  *  @brief      Get one unparsed packet from the FIFO.
// 1777  *  This function should be used if the packet is to be parsed elsewhere.
// 1778  *  @param[in]  length  Length of one FIFO packet.
// 1779  *  @param[in]  data    FIFO packet.
// 1780  *  @param[in]  more    Number of remaining packets.
// 1781  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1782 int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
mpu_read_fifo_stream:
        CFI Block cfiBlock28 Using cfiCommon0
        CFI Function mpu_read_fifo_stream
        CODE
// 1783     unsigned char *more)
// 1784 {
        FUNCALL mpu_read_fifo_stream, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo_stream, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo_stream, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_fifo_stream, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
// 1785     unsigned char tmp[2];
// 1786     unsigned short fifo_count;
// 1787     if (!st.chip_cfg.dmp_on)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JNZ     ??mpu_read_fifo_stream_0
// 1788     {
// 1789         //printf("mpu_read_fifo_stream -1\r\n");
// 1790         return -1;
??mpu_read_fifo_stream_1:
        MOV     R2,#-0x1
??mpu_read_fifo_stream_2:
        MOV     R3,#-0x1
        LJMP    ??mpu_read_fifo_stream_3 & 0xFFFF
// 1791     }
// 1792     if (!st.chip_cfg.sensors)
??mpu_read_fifo_stream_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??mpu_read_fifo_stream_1
// 1793     {
// 1794         //printf("mpu_read_fifo_stream -2\r\n");      
// 1795         return -1;
// 1796     }
// 1797     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JNZ     ??mpu_read_fifo_stream_1
// 1798     {
// 1799         //printf("mpu_read_fifo_stream -3\r\n");       
// 1800         return -1;
// 1801     }
// 1802     fifo_count = (tmp[0] << 8) | tmp[1];
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     ?V0 + 0,A
        MOV     A,R1
        MOV     ?V0 + 1,A
// 1803     if (fifo_count < length) 
        CLR     C
        MOV     A,R2
        SUBB    A,R6
        MOV     A,R1
        SUBB    A,R7
        JNC     ??mpu_read_fifo_stream_4
// 1804     {
// 1805         //printf("mpu_read_fifo_stream -4\r\n");       
// 1806         more[0] = 0;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        CLR     A
        MOVX    @DPTR,A
// 1807         return -1;
        SJMP    ??mpu_read_fifo_stream_1
// 1808     }
// 1809     if (fifo_count > (st.hw->max_fifo >> 1)) 
??mpu_read_fifo_stream_4:
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        RRC     A
        MOV     R3,A
        MOV     A,R2
        RRC     A
        CLR     C
        SUBB    A,?V0 + 0
        MOV     A,R3
        SUBB    A,?V0 + 1
        JNC     ??mpu_read_fifo_stream_5
// 1810     {
// 1811         /* FIFO is 50% full, better check overflow bit. */
// 1812         if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x11
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     DPL,?V0 + 6
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_fifo_stream_1 & 0xFFFF
// 1813         {
// 1814             //printf("mpu_read_fifo_stream -5\r\n"); 
// 1815             return -1;
// 1816         }
// 1817         if (tmp[0] & BIT_FIFO_OVERFLOW) 
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??mpu_read_fifo_stream_5
// 1818         {
// 1819             //printf("mpu_read_fifo_stream -6\r\n");           
// 1820             mpu_reset_fifo();
        ; Setup parameters for call to function mpu_reset_fifo
        LCALL   ??mpu_reset_fifo?relay
// 1821             return -2;
        MOV     R2,#-0x2
        LJMP    ??mpu_read_fifo_stream_2 & 0xFFFF
// 1822         }
// 1823     }
// 1824 
// 1825     if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
??mpu_read_fifo_stream_5:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     A,R6
        MOV     R3,A
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_fifo_stream_1 & 0xFFFF
// 1826     {
// 1827         //printf("mpu_read_fifo_stream -7\r\n"); 
// 1828         return -1;
// 1829     }
// 1830     more[0] = fifo_count / length - 1;
        MOV     R0,?V0 + 0
        MOV     R1,?V0 + 1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        DEC     A
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    @DPTR,A
// 1831     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_read_fifo_stream_3:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock28
// 1832 }
// 1833 
// 1834 /**
// 1835  *  @brief      Set device to bypass mode.
// 1836  *  @param[in]  bypass_on   1 to enable bypass mode.
// 1837  *  @return     0 if successful.
// 1838  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1839 int mpu_set_bypass(unsigned char bypass_on)
mpu_set_bypass:
        CFI Block cfiBlock29 Using cfiCommon0
        CFI Function mpu_set_bypass
        CODE
// 1840 {
        FUNCALL mpu_set_bypass, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_bypass, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     ?V0 + 0,R1
// 1841     unsigned char tmp;
// 1842 
// 1843     if (st.chip_cfg.bypass_mode == bypass_on)
        MOV     DPTR,#st + 13
        MOVX    A,@DPTR
        XRL     A,?V0 + 0
        JNZ     $+5
        LJMP    ??mpu_set_bypass_0 & 0xFFFF
// 1844         return 0;
// 1845 
// 1846     if (bypass_on) {
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     A,?V0 + 0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPL,R6
        MOV     DPH,R7
        JNZ     $+5
        LJMP    ??mpu_set_bypass_1 & 0xFFFF
// 1847         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      ??mpu_set_bypass_2
// 1848             return -1;
??mpu_set_bypass_3:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_set_bypass_4 & 0xFFFF
// 1849         tmp &= ~BIT_AUX_IF_EN;
??mpu_set_bypass_2:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.5
        MOVX    @DPTR,A
// 1850         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_set_bypass_3
// 1851             return -1;
// 1852         delay_ms(3);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_3
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1853         tmp = BIT_BYPASS_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x2
        MOVX    @DPTR,A
// 1854         if (st.chip_cfg.active_low_int)
        MOV     DPTR,#st + 27
        MOVX    A,@DPTR
        JZ      ??mpu_set_bypass_5
// 1855             tmp |= BIT_ACTL;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#-0x7e
        MOVX    @DPTR,A
// 1856         if (st.chip_cfg.latched_int)
??mpu_set_bypass_5:
        MOV     DPTR,#st + 28
        MOVX    A,@DPTR
        JZ      ??mpu_set_bypass_6
// 1857             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ORL     A,#0x30
        MOVX    @DPTR,A
// 1858         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
??mpu_set_bypass_6:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x14
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_bypass_3 & 0xFFFF
        LJMP    ??mpu_set_bypass_7 & 0xFFFF
// 1859             return -1;
// 1860     } else {
// 1861         /* Enable I2C master mode if compass is being used. */
// 1862         if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
??mpu_set_bypass_1:
        ; Setup parameters for call to function MPU_Read_Len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_bypass_3 & 0xFFFF
// 1863             return -1;
// 1864         if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JNC     ??mpu_set_bypass_8
// 1865             tmp |= BIT_AUX_IF_EN;
        SETB    0xE0 /* A   */.5
        SJMP    ??mpu_set_bypass_9
// 1866         else
// 1867             tmp &= ~BIT_AUX_IF_EN;
??mpu_set_bypass_8:
        CLR     0xE0 /* A   */.5
??mpu_set_bypass_9:
        MOVX    @DPTR,A
// 1868         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_bypass_3 & 0xFFFF
// 1869             return -1;
// 1870         delay_ms(3);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_3
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 1871         if (st.chip_cfg.active_low_int)
        MOV     DPTR,#st + 27
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_set_bypass_10
// 1872             tmp = BIT_ACTL;
        MOV     A,#-0x80
        SJMP    ??mpu_set_bypass_11
// 1873         else
// 1874             tmp = 0;
??mpu_set_bypass_10:
        CLR     A
??mpu_set_bypass_11:
        MOVX    @DPTR,A
// 1875         if (st.chip_cfg.latched_int)
        MOV     DPTR,#st + 28
        MOVX    A,@DPTR
        JZ      ??mpu_set_bypass_12
// 1876             tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ORL     A,#0x30
        MOVX    @DPTR,A
// 1877         if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
??mpu_set_bypass_12:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x14
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_set_bypass_3 & 0xFFFF
// 1878             return -1;
// 1879     }
// 1880     st.chip_cfg.bypass_mode = bypass_on;
??mpu_set_bypass_7:
        MOV     A,?V0 + 0
        MOV     DPTR,#st + 13
        MOVX    @DPTR,A
// 1881     return 0;
??mpu_set_bypass_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_bypass_4:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock29
// 1882 }
// 1883 
// 1884 /**
// 1885  *  @brief      Set interrupt level.
// 1886  *  @param[in]  active_low  1 for active low, 0 for active high.
// 1887  *  @return     0 if successful.
// 1888  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1889 int mpu_set_int_level(unsigned char active_low)
mpu_set_int_level:
        CFI Block cfiBlock30 Using cfiCommon0
        CFI Function mpu_set_int_level
        CODE
// 1890 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1891     st.chip_cfg.active_low_int = active_low;
        MOV     A,R1
        MOV     DPTR,#st + 27
        MOVX    @DPTR,A
// 1892     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock30
// 1893 }
// 1894 
// 1895 /**
// 1896  *  @brief      Enable latched interrupts.
// 1897  *  Any MPU register will clear the interrupt.
// 1898  *  @param[in]  enable  1 to enable, 0 to disable.
// 1899  *  @return     0 if successful.
// 1900  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1901 int mpu_set_int_latched(unsigned char enable)
mpu_set_int_latched:
        CFI Block cfiBlock31 Using cfiCommon0
        CFI Function mpu_set_int_latched
        CODE
// 1902 {
        FUNCALL mpu_set_int_latched, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
// 1903     unsigned char tmp;
// 1904     if (st.chip_cfg.latched_int == enable)
        MOV     DPTR,#st + 28
        MOVX    A,@DPTR
        XRL     A,R6
        JZ      ??mpu_set_int_latched_0
// 1905         return 0;
// 1906 
// 1907     if (enable)
        MOV     A,R6
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        JZ      ??mpu_set_int_latched_1
// 1908         tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
        MOV     A,#0x30
        SJMP    ??mpu_set_int_latched_2
// 1909     else
// 1910         tmp = 0;
??mpu_set_int_latched_1:
        CLR     A
??mpu_set_int_latched_2:
        MOVX    @DPTR,A
// 1911     if (st.chip_cfg.bypass_mode)
        MOV     DPTR,#st + 13
        MOVX    A,@DPTR
        JZ      ??mpu_set_int_latched_3
// 1912         tmp |= BIT_BYPASS_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
// 1913     if (st.chip_cfg.active_low_int)
??mpu_set_int_latched_3:
        MOV     DPTR,#st + 27
        MOVX    A,@DPTR
        JZ      ??mpu_set_int_latched_4
// 1914         tmp |= BIT_ACTL;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.7
        MOVX    @DPTR,A
// 1915     if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
??mpu_set_int_latched_4:
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x14
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??mpu_set_int_latched_5
// 1916         return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_set_int_latched_6
// 1917     st.chip_cfg.latched_int = enable;
??mpu_set_int_latched_5:
        MOV     A,R6
        MOV     DPTR,#st + 28
        MOVX    @DPTR,A
// 1918     return 0;
??mpu_set_int_latched_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_int_latched_6:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock31
// 1919 }
// 1920 
// 1921 #ifdef MPU6050

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1922 static int get_accel_prod_shift(float *st_shift)
get_accel_prod_shift:
        CFI Block cfiBlock32 Using cfiCommon0
        CFI Function get_accel_prod_shift
        CODE
// 1923 {
        FUNCALL get_accel_prod_shift, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x16
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 22)
        ; Saved register size: 22
        ; Auto size: 7
        MOV     A,#-0x7
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 29)
        MOV     ?V0 + 12,R2
        MOV     ?V0 + 13,R3
// 1924     unsigned char tmp[4], shift_code[3], ii;
// 1925 
// 1926     if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x4
        MOV     R2,#0xd
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      ??get_accel_prod_shift_0
// 1927         return 0x07;
        MOV     R2,#0x7
        LJMP    ??get_accel_prod_shift_1 & 0xFFFF
// 1928 
// 1929     shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
??get_accel_prod_shift_0:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        SWAP    A
        ANL     A,#0xf
        ANL     A,#0x3
        MOV     R0,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        ANL     A,#0x1c
        ORL     A,R0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 1930     shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
        MOV     A,R1
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0x3
        MOV     R0,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        ANL     A,#0x1c
        ORL     A,R0
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1931     shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
        MOV     A,#0x3
        ANL     A,R1
        MOV     R0,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        ANL     A,#0x1c
        ORL     A,R0
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1932     for (ii = 0; ii < 3; ii++) {
        MOV     R6,#0x0
        SJMP    ??get_accel_prod_shift_2
// 1933         if (!shift_code[ii]) {
// 1934             st_shift[ii] = 0.f;
// 1935             continue;
// 1936         }
// 1937         /* Equivalent to..
// 1938          * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
// 1939          */
// 1940         st_shift[ii] = 0.34f;
// 1941         while (--shift_code[ii])
// 1942             st_shift[ii] *= 1.034f;
??get_accel_prod_shift_3:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_3f845a1d
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
??get_accel_prod_shift_4:
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        DEC     A
        MOVX    @DPTR,A
        MOVX    A,@DPTR
        JNZ     ??get_accel_prod_shift_3
??get_accel_prod_shift_5:
        INC     R6
??get_accel_prod_shift_2:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x3
        JNC     ??get_accel_prod_shift_6
        MOV     DPL,R6
        MOV     R2,DPL
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,?V0 + 12
        ADD     A,?V0 + 0
        MOV     ?V0 + 4,A
        MOV     A,?V0 + 13
        ADDC    A,?V0 + 1
        MOV     ?V0 + 5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,R2
        MOV     ?V0 + 6,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     ?V0 + 7,A
        MOV     DPL,?V0 + 6
        MOV     DPH,A
        MOVX    A,@DPTR
        JNZ     ??get_accel_prod_shift_7
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        LCALL   ?XSTORE_R2345
        SJMP    ??get_accel_prod_shift_5
??get_accel_prod_shift_7:
        MOV     DPTR,#__Constant_3eae147b
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        LCALL   ?XSTORE_R2345
        SJMP    ??get_accel_prod_shift_4
// 1943     }
// 1944     return 0;
??get_accel_prod_shift_6:
        MOV     R2,#0x0
??get_accel_prod_shift_1:
        MOV     R3,#0x0
        MOV     A,#0x7
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R7,#0xe
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock32
// 1945 }
// 1946 

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1947 static int accel_self_test(long *bias_regular, long *bias_st)
accel_self_test:
        CFI Block cfiBlock33 Using cfiCommon0
        CFI Function accel_self_test
        CODE
// 1948 {
        FUNCALL accel_self_test, get_accel_prod_shift
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL accel_self_test, labs
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
// 1949     int jj, result = 0;
        MOV     ?V0 + 12,#0x0
        MOV     ?V0 + 13,#0x0
// 1950     float st_shift[3], st_shift_cust, st_shift_var;
// 1951 
// 1952     get_accel_prod_shift(st_shift);
        ; Setup parameters for call to function get_accel_prod_shift
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??get_accel_prod_shift?relay
// 1953     for(jj = 0; jj < 3; jj++) {
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??accel_self_test_0
// 1954         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
// 1955         if (st_shift[jj]) {
// 1956             st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
// 1957             if (fabs(st_shift_var) > test.max_accel_var)
// 1958                 result |= 1 << jj;
// 1959         } else if ((st_shift_cust < test.min_g) ||
// 1960             (st_shift_cust > test.max_g))
??accel_self_test_1:
        MOV     DPTR,#__Constant_3e99999a
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_LT
        JNC     $+5
        LJMP    ??accel_self_test_2 & 0xFFFF
        MOV     DPTR,#__Constant_3f733334
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_GE
        JNC     $+5
        LJMP    ??accel_self_test_2 & 0xFFFF
??accel_self_test_3:
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
??accel_self_test_0:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x3
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      $+5
        LJMP    ??accel_self_test_4 & 0xFFFF
        MOV     ?V0 + 2,R6
        MOV     ?V0 + 3,R7
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     ?V0 + 0,?V0 + 2
        MOV     ?V0 + 1,?V0 + 3
        ; Setup parameters for call to function labs
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOV     DPL,R0
        MOV     DPH,A
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 14
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,?V0 + 15
        ADDC    A,?V0 + 1
        MOV     DPH,A
        MOV     R0,#?V0 + 4
        LCALL   ?L_SUB_X
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     R4,?V0 + 6
        MOV     R5,?V0 + 7
        LCALL   ??labs?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 6,R4
        MOV     ?V0 + 7,R5
        MOV     R0,#?V0 + 4
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_37800000
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,DPL
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 1
        MOV     DPH,A
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_EQ
        JNZ     $+5
        LJMP    ??accel_self_test_1 & 0xFFFF
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,R7
        MOV     A,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,DPL
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 1
        MOV     DPH,A
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_DIV
        MOV     DPTR,#__Constant_bf800000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_ADD
        MOV     A,?V0 + 7
        CLR     0xE0 /* A   */.7
        MOV     ?V0 + 7,A
        MOV     DPTR,#__Constant_3e0f5c2a
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_GE
        JC      $+5
        LJMP    ??accel_self_test_3 & 0xFFFF
??accel_self_test_2:
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     A,R6
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,?V0 + 0
        ORL     A,?V0 + 12
        MOV     ?V0 + 12,A
        MOV     A,?V0 + 1
        ORL     A,?V0 + 13
        MOV     ?V0 + 13,A
        LJMP    ??accel_self_test_3 & 0xFFFF
// 1961             result |= 1 << jj;
// 1962     }
// 1963 
// 1964     return result;
??accel_self_test_4:
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        MOV     A,#0xe
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock33
// 1965 }
// 1966 

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1967 static int gyro_self_test(long *bias_regular, long *bias_st)
gyro_self_test:
        CFI Block cfiBlock34 Using cfiCommon0
        CFI Function gyro_self_test
        CODE
// 1968 {
        FUNCALL gyro_self_test, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL gyro_self_test, labs
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 5
        MOV     A,#-0x5
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 29)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
// 1969     int jj, result = 0;
        MOV     ?V0 + 12,#0x0
        MOV     ?V0 + 13,#0x0
// 1970     unsigned char tmp[3];
// 1971     float st_shift, st_shift_cust, st_shift_var;
// 1972 
// 1973     if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x3
        MOV     R2,#0xd
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      ??gyro_self_test_0
// 1974         return 0x07;
        MOV     R2,#0x7
        MOV     R3,#0x0
        LJMP    ??gyro_self_test_1 & 0xFFFF
// 1975 
// 1976     tmp[0] &= 0x1F;
??gyro_self_test_0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
// 1977     tmp[1] &= 0x1F;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
// 1978     tmp[2] &= 0x1F;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
// 1979 
// 1980     for (jj = 0; jj < 3; jj++) {
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??gyro_self_test_2
// 1981         st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
// 1982         if (tmp[jj]) {
// 1983             st_shift = 3275.f / test.gyro_sens;
// 1984             while (--tmp[jj])
// 1985                 st_shift *= 1.046f;
// 1986             st_shift_var = st_shift_cust / st_shift - 1.f;
// 1987             if (fabs(st_shift_var) > test.max_gyro_var)
// 1988                 result |= 1 << jj;
// 1989         } else if ((st_shift_cust < test.min_dps) ||
// 1990             (st_shift_cust > test.max_dps))
??gyro_self_test_3:
        MOV     DPTR,#__Constant_41200000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_LT
        JNC     $+5
        LJMP    ??gyro_self_test_4 & 0xFFFF
        MOV     DPTR,#__Constant_42d20001
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_GE
        JNC     $+5
        LJMP    ??gyro_self_test_4 & 0xFFFF
??gyro_self_test_5:
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
??gyro_self_test_2:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x3
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      $+5
        LJMP    ??gyro_self_test_6 & 0xFFFF
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,R7
        MOV     A,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        ; Setup parameters for call to function labs
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R0
        MOV     DPH,A
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 14
        ADD     A,R2
        MOV     DPL,A
        MOV     A,?V0 + 15
        ADDC    A,R3
        MOV     DPH,A
        MOV     R0,#?V0 + 0
        LCALL   ?L_SUB_X
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        LCALL   ??labs?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 6,R4
        MOV     ?V0 + 7,R5
        MOV     R0,#?V0 + 4
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_37800000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,R6
        MOV     R2,A
        MOV     A,DPH
        ADDC    A,R7
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        JNZ     $+5
        LJMP    ??gyro_self_test_3 & 0xFFFF
        MOV     DPTR,#__Constant_41c80000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        SJMP    ??gyro_self_test_7
??gyro_self_test_8:
        MOV     DPTR,#__Constant_3f85e354
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
??gyro_self_test_7:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        DEC     A
        MOVX    @DPTR,A
        MOVX    A,@DPTR
        JNZ     ??gyro_self_test_8
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_DIV
        MOV     DPTR,#__Constant_bf800000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_ADD
        MOV     A,?V0 + 7
        CLR     0xE0 /* A   */.7
        MOV     ?V0 + 7,A
        MOV     DPTR,#__Constant_3e0f5c2a
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_GE
        JC      $+5
        LJMP    ??gyro_self_test_5 & 0xFFFF
??gyro_self_test_4:
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     A,R6
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,?V0 + 0
        ORL     A,?V0 + 12
        MOV     ?V0 + 12,A
        MOV     A,?V0 + 1
        ORL     A,?V0 + 13
        MOV     ?V0 + 13,A
        LJMP    ??gyro_self_test_5 & 0xFFFF
// 1991             result |= 1 << jj;
// 1992     }
// 1993     return result;
??gyro_self_test_6:
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
??gyro_self_test_1:
        MOV     A,#0x5
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock34
// 1994 }
// 1995 
// 1996 #ifdef AK89xx_SECONDARY
// 1997 static int compass_self_test(void)
// 1998 {
// 1999     unsigned char tmp[6];
// 2000     unsigned char tries = 10;
// 2001     int result = 0x07;
// 2002     short data;
// 2003 
// 2004     mpu_set_bypass(1);
// 2005 
// 2006     tmp[0] = AKM_POWER_DOWN;
// 2007     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
// 2008         return 0x07;
// 2009     tmp[0] = AKM_BIT_SELF_TEST;
// 2010     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
// 2011         goto AKM_restore;
// 2012     tmp[0] = AKM_MODE_SELF_TEST;
// 2013     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
// 2014         goto AKM_restore;
// 2015 
// 2016     do {
// 2017         delay_ms(10);
// 2018         if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
// 2019             goto AKM_restore;
// 2020         if (tmp[0] & AKM_DATA_READY)
// 2021             break;
// 2022     } while (tries--);
// 2023     if (!(tmp[0] & AKM_DATA_READY))
// 2024         goto AKM_restore;
// 2025 
// 2026     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
// 2027         goto AKM_restore;
// 2028 
// 2029     result = 0;
// 2030     data = (short)(tmp[1] << 8) | tmp[0];
// 2031     if ((data > 100) || (data < -100))
// 2032         result |= 0x01;
// 2033     data = (short)(tmp[3] << 8) | tmp[2];
// 2034     if ((data > 100) || (data < -100))
// 2035         result |= 0x02;
// 2036     data = (short)(tmp[5] << 8) | tmp[4];
// 2037     if ((data > -300) || (data < -1000))
// 2038         result |= 0x04;
// 2039 
// 2040 AKM_restore:
// 2041     tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
// 2042     i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
// 2043     tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
// 2044     i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
// 2045     mpu_set_bypass(0);
// 2046     return result;
// 2047 }
// 2048 #endif
// 2049 #endif
// 2050 

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2051 static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
get_st_biases:
        CFI Block cfiBlock35 Using cfiCommon0
        CFI Function get_st_biases
        CODE
// 2052 {
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL get_st_biases, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 55, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 55, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 31
        MOV     A,#-0x1f
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 55)
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     A,R1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2053     unsigned char data[MAX_PACKET_LENGTH];
// 2054     unsigned char packet_count, ii;
// 2055     unsigned short fifo_count;
// 2056 
// 2057     data[0] = 0x01;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2058     data[1] = 0;
        INC     A
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
// 2059     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
        ; Setup parameters for call to function MPU_Write_Len
        INC     A
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      ??get_st_biases_0
// 2060         return -1;
??get_st_biases_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??get_st_biases_2 & 0xFFFF
// 2061     delay_ms(200);
??get_st_biases_0:
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_c8
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2062     data[0] = 0;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
// 2063     if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??get_st_biases_1
// 2064         return -1;
// 2065     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??get_st_biases_1
// 2066         return -1;
// 2067     if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2068         return -1;
// 2069     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x17
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2070         return -1;
// 2071     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2072         return -1;
// 2073     data[0] = BIT_FIFO_RST | BIT_DMP_RST;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0xc
        MOVX    @DPTR,A
// 2074     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2075         return -1;
// 2076     delay_ms(15);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_f
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2077     data[0] = st.test->reg_lpf;
        MOV     DPTR,#st + 33
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2078     if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2079         return -1;
// 2080     data[0] = st.test->reg_rate_div;
        MOV     DPTR,#st + 33
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2081     if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2082         return -1;
// 2083     if (hw_test)
        MOV     DPTR,#st + 33
        MOVX    A,@DPTR
        ADD     A,#0xa
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     DPL,R0
        MOV     DPH,R1
        JZ      ??get_st_biases_3
// 2084         data[0] = st.test->reg_gyro_fsr | 0xE0;
        MOVX    A,@DPTR
        ORL     A,#0xe0
        SJMP    ??get_st_biases_4
// 2085     else
// 2086         data[0] = st.test->reg_gyro_fsr;
??get_st_biases_3:
        MOVX    A,@DPTR
??get_st_biases_4:
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2087     if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2088         return -1;
// 2089 
// 2090     if (hw_test)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JZ      ??get_st_biases_5
// 2091         data[0] = st.test->reg_accel_fsr | 0xE0;
        MOV     DPTR,#st + 33
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        ORL     A,#0xe0
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        SJMP    ??get_st_biases_6
// 2092     else
// 2093         data[0] = test.reg_accel_fsr;
??get_st_biases_5:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x18
??get_st_biases_6:
        MOVX    @DPTR,A
// 2094     if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2095         return -1;
// 2096     if (hw_test)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        JZ      ??get_st_biases_7
// 2097         delay_ms(200);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_c8
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2098 
// 2099     /* Fill FIFO for test.wait_ms milliseconds. */
// 2100     data[0] = BIT_FIFO_EN;
??get_st_biases_7:
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x40
        MOVX    @DPTR,A
// 2101     if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2102         return -1;
// 2103 
// 2104     data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x78
        MOVX    @DPTR,A
// 2105     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2106         return -1;
// 2107     delay_ms(test.wait_ms);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_32
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2108     data[0] = 0;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
// 2109     if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2110         return -1;
// 2111 
// 2112     if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2113         return -1;
// 2114 
// 2115     fifo_count = (data[0] << 8) | data[1];
// 2116     packet_count = fifo_count / MAX_PACKET_LENGTH;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R2,#0xc
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        MOV     ?V0 + 0,A
// 2117     gyro[0] = gyro[1] = gyro[2] = 0;
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     ?V0 + 14,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 15,A
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        LCALL   ?XSTORE_R2345
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     ?V0 + 12,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 13,A
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        LCALL   ?XSTORE_R2345
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?XSTORE_R2345
// 2118     accel[0] = accel[1] = accel[2] = 0;
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R7,A
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ?XSTORE_R2345
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?XSTORE_R2345
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?XSTORE_R2345
// 2119 
// 2120     for (ii = 0; ii < packet_count; ii++) {
        MOV     ?V0 + 1,#0x0
        LJMP    ??get_st_biases_8 & 0xFFFF
// 2121         short accel_cur[3], gyro_cur[3];
// 2122         if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
??get_st_biases_9:
        ; Setup parameters for call to function MPU_Read_Len
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0xc
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xb
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??get_st_biases_1 & 0xFFFF
// 2123             return -1;
// 2124         accel_cur[0] = ((short)data[0] << 8) | data[1];
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x19
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2125         accel_cur[1] = ((short)data[2] << 8) | data[3];
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2126         accel_cur[2] = ((short)data[4] << 8) | data[5];
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2127         accel[0] += (long)accel_cur[0];
        MOV     A,#0x19
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2128         accel[1] += (long)accel_cur[1];
        MOV     ?V0 + 4,R4
        MOV     A,R5
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2129         accel[2] += (long)accel_cur[2];
        MOV     ?V0 + 4,R2
        MOV     A,R3
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2130         gyro_cur[0] = (((short)data[6] << 8) | data[7]);
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2131         gyro_cur[1] = (((short)data[8] << 8) | data[9]);
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2132         gyro_cur[2] = (((short)data[10] << 8) | data[11]);
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,#0x17
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2133         gyro[0] += (long)gyro_cur[0];
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2134         gyro[1] += (long)gyro_cur[1];
        MOV     ?V0 + 4,R4
        MOV     A,R5
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2135         gyro[2] += (long)gyro_cur[2];
        MOV     ?V0 + 4,R2
        MOV     A,R3
        MOV     ?V0 + 5,A
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_TO_X
// 2136     }
        INC     ?V0 + 1
??get_st_biases_8:
        MOV     A,?V0 + 1
        CLR     C
        SUBB    A,?V0 + 0
        JNC     $+5
        LJMP    ??get_st_biases_9 & 0xFFFF
// 2137 #ifdef EMPL_NO_64BIT
// 2138     gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
// 2139     gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
// 2140     gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
// 2141     if (has_accel) {
// 2142         accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
// 2143             packet_count);
// 2144         accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
// 2145             packet_count);
// 2146         accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
// 2147             packet_count);
// 2148         /* Don't remove gravity! */
// 2149         accel[2] -= 65536L;
// 2150     }
// 2151 #else
// 2152     gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
        MOV     A,?V0 + 0
        MOV     ?V0 + 4,A
        CLR     A
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     DPTR,#__Constant_83
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,?V0 + 5
        MOV     ?V0 + 10,?V0 + 6
        MOV     ?V0 + 11,?V0 + 7
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2153     gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     DPTR,#__Constant_83
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,?V0 + 5
        MOV     ?V0 + 10,?V0 + 6
        MOV     ?V0 + 11,?V0 + 7
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2154     gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     DPTR,#__Constant_83
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,?V0 + 5
        MOV     ?V0 + 10,?V0 + 6
        MOV     ?V0 + 11,?V0 + 7
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?UL_DIV_MOD
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2155     accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
// 2156         packet_count);
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 8
        LCALL   ?L_SHL
        MOV     A,#0xb
        MOV     R0,#?V0 + 8
        LCALL   ?UL_SHR
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?UL_DIV_MOD
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_TO_X
// 2157     accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
// 2158         packet_count);
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 8
        LCALL   ?L_SHL
        MOV     A,#0xb
        MOV     R0,#?V0 + 8
        LCALL   ?UL_SHR
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?UL_DIV_MOD
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_TO_X
// 2159     accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
// 2160         packet_count);
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     A,#0xb
        MOV     R0,#?V0 + 0
        LCALL   ?UL_SHR
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?UL_DIV_MOD
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2161     /* Don't remove gravity! */
// 2162     if (accel[2] > 0L)
        MOV     DPL,R6
        MOV     DPH,R7
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     DPTR,#__Constant_1
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOV     R0,#?V0 + 0
        LCALL   ?SL_GT_X
        JC      ??get_st_biases_10
// 2163         accel[2] -= 65536L;
        MOV     DPTR,#__Constant_ffff0000
        SJMP    ??get_st_biases_11
// 2164     else
// 2165         accel[2] += 65536L;
??get_st_biases_10:
        MOV     DPTR,#__Constant_10000
??get_st_biases_11:
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     R0,#?V0 + 0
        LCALL   ?L_ADD_TO_X
// 2166 #endif
// 2167 
// 2168     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??get_st_biases_2:
        MOV     A,#0x1f
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock35
// 2169 }
// 2170 
// 2171 /**
// 2172  *  @brief      Trigger gyro/accel/compass self-test.
// 2173  *  On success/error, the self-test returns a mask representing the sensor(s)
// 2174  *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
// 2175  *  a zero (0) indicates a failure.
// 2176  *
// 2177  *  \n The mask is defined as follows:
// 2178  *  \n Bit 0:   Gyro.
// 2179  *  \n Bit 1:   Accel.
// 2180  *  \n Bit 2:   Compass.
// 2181  *
// 2182  *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
// 2183  *  this function can still be used to obtain the accel and gyro biases.
// 2184  *
// 2185  *  \n This function must be called with the device either face-up or face-down
// 2186  *  (z-axis is parallel to gravity).
// 2187  *  @param[out] gyro        Gyro biases in q16 format.
// 2188  *  @param[out] accel       Accel biases (if applicable) in q16 format.
// 2189  *  @return     Result mask (see above).
// 2190  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2191 int mpu_run_self_test(long *gyro, long *accel)
mpu_run_self_test:
        CFI Block cfiBlock36 Using cfiCommon0
        CFI Function mpu_run_self_test
        CODE
// 2192 {
        FUNCALL mpu_run_self_test, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_get_fifo_config
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, get_st_biases
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, get_st_biases
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, accel_self_test
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, gyro_self_test
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_sensors
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_run_self_test, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 48, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 48, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 32
        MOV     A,#-0x20
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 48)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
// 2193 #ifdef MPU6050
// 2194     const unsigned char tries = 2;
// 2195     long gyro_st[3], accel_st[3];
// 2196     unsigned char accel_result, gyro_result;
// 2197 #ifdef AK89xx_SECONDARY
// 2198     unsigned char compass_result;
// 2199 #endif
// 2200     int ii;
// 2201 #endif
// 2202     int result;
// 2203     unsigned char accel_fsr, fifo_sensors, sensors_on;
// 2204     unsigned short gyro_fsr, sample_rate, lpf;
// 2205     unsigned char dmp_was_on;
// 2206 
// 2207     if (st.chip_cfg.dmp_on) {
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_run_self_test_0
// 2208         mpu_set_dmp_state(0);
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x0
        LCALL   ??mpu_set_dmp_state?relay
// 2209         dmp_was_on = 1;
        MOV     ?V0 + 0,#0x1
        SJMP    ??mpu_run_self_test_1
// 2210     } else
// 2211         dmp_was_on = 0;
??mpu_run_self_test_0:
        MOV     ?V0 + 0,#0x0
// 2212 
// 2213     /* Get initial settings. */
// 2214     mpu_get_gyro_fsr(&gyro_fsr);
??mpu_run_self_test_1:
        ; Setup parameters for call to function mpu_get_gyro_fsr
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_gyro_fsr?relay
// 2215     mpu_get_accel_fsr(&accel_fsr);
        ; Setup parameters for call to function mpu_get_accel_fsr
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_accel_fsr?relay
// 2216     mpu_get_lpf(&lpf);
        ; Setup parameters for call to function mpu_get_lpf
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_lpf?relay
// 2217     mpu_get_sample_rate(&sample_rate);
        ; Setup parameters for call to function mpu_get_sample_rate
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_sample_rate?relay
// 2218     sensors_on = st.chip_cfg.sensors;
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2219     mpu_get_fifo_config(&fifo_sensors);
        ; Setup parameters for call to function mpu_get_fifo_config
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_fifo_config?relay
// 2220 
// 2221     /* For older chips, the self-test will be different. */
// 2222 #if defined MPU6050
// 2223     for (ii = 0; ii < tries; ii++)
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??mpu_run_self_test_2
??mpu_run_self_test_3:
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
??mpu_run_self_test_2:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x2
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??mpu_run_self_test_4
// 2224         if (!get_st_biases(gyro, accel, 0))
        ; Setup parameters for call to function get_st_biases
        MOV     R1,#0x0
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        LCALL   ??get_st_biases?relay
        MOV     ?V0 + 7,R3
        MOV     A,R2
        ORL     A,?V0 + 7
        JNZ     ??mpu_run_self_test_3
// 2225             break;
// 2226     if (ii == tries) {
??mpu_run_self_test_4:
        MOV     A,#0x2
        XRL     A,R6
        JNZ     ??mpu_run_self_test_5
        MOV     A,R7
??mpu_run_self_test_5:
        JNZ     ??mpu_run_self_test_6
// 2227         /* If we reach this point, we most likely encountered an I2C error.
// 2228          * We'll just report an error for all three sensors.
// 2229          */
// 2230         result = 0;
??mpu_run_self_test_7:
        MOV     R6,#0x0
// 2231         goto restore;
        SJMP    ??mpu_run_self_test_8
// 2232     }
// 2233     for (ii = 0; ii < tries; ii++)
??mpu_run_self_test_6:
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??mpu_run_self_test_9
??mpu_run_self_test_10:
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
??mpu_run_self_test_9:
        CLR     C
        MOV     A,R6
        SUBB    A,#0x2
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??mpu_run_self_test_11
// 2234         if (!get_st_biases(gyro_st, accel_st, 1))
        ; Setup parameters for call to function get_st_biases
        MOV     R1,#0x1
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??get_st_biases?relay
        MOV     ?V0 + 7,R3
        MOV     A,R2
        ORL     A,?V0 + 7
        JNZ     ??mpu_run_self_test_10
// 2235             break;
// 2236     if (ii == tries) {
??mpu_run_self_test_11:
        MOV     A,#0x2
        XRL     A,R6
        JNZ     ??mpu_run_self_test_12
        MOV     A,R7
??mpu_run_self_test_12:
        JZ      ??mpu_run_self_test_7
// 2237         /* Again, probably an I2C error. */
// 2238         result = 0;
// 2239         goto restore;
// 2240     }
// 2241     accel_result = accel_self_test(accel, accel_st);
        ; Setup parameters for call to function accel_self_test
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??accel_self_test?relay
        MOV     A,R2
        MOV     ?V0 + 2,A
// 2242     gyro_result = gyro_self_test(gyro, gyro_st);
        ; Setup parameters for call to function gyro_self_test
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        LCALL   ??gyro_self_test?relay
        MOV     A,R2
// 2243 
// 2244     result = 0;
        MOV     R6,#0x0
// 2245     if (!gyro_result)
        JNZ     ??mpu_run_self_test_13
// 2246         result |= 0x01;
        INC     R6
// 2247     if (!accel_result)
??mpu_run_self_test_13:
        MOV     A,?V0 + 2
        JNZ     ??mpu_run_self_test_8
// 2248         result |= 0x02;
        MOV     A,#0x2
        ORL     A,R6
        MOV     R6,A
// 2249 
// 2250 #ifdef AK89xx_SECONDARY
// 2251     compass_result = compass_self_test();
// 2252     if (!compass_result)
// 2253         result |= 0x04;
// 2254 #endif
// 2255 restore:
// 2256 #elif defined MPU6500
// 2257     /* For now, this function will return a "pass" result for all three sensors
// 2258      * for compatibility with current test applications.
// 2259      */
// 2260     get_st_biases(gyro, accel, 0);
// 2261     result = 0x7;
// 2262 #endif
// 2263     /* Set to invalid values to ensure no I2C writes are skipped. */
// 2264     st.chip_cfg.gyro_fsr = 0xFF;
??mpu_run_self_test_8:
        MOV     DPTR,#st + 4
        MOV     A,#-0x1
        MOVX    @DPTR,A
// 2265     st.chip_cfg.accel_fsr = 0xFF;
        INC     DPTR
        MOVX    @DPTR,A
// 2266     st.chip_cfg.lpf = 0xFF;
        MOV     DPTR,#st + 7
        MOVX    @DPTR,A
// 2267     st.chip_cfg.sample_rate = 0xFFFF;
        MOV     DPTR,#st + 9
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 2268     st.chip_cfg.sensors = 0xFF;
        MOV     DPTR,#st + 6
        MOVX    @DPTR,A
// 2269     st.chip_cfg.fifo_enable = 0xFF;
        MOV     DPTR,#st + 11
        MOVX    @DPTR,A
// 2270     st.chip_cfg.clk_src = INV_CLK_PLL;
        MOV     DPTR,#st + 8
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2271     mpu_set_gyro_fsr(gyro_fsr);
        ; Setup parameters for call to function mpu_set_gyro_fsr
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_gyro_fsr?relay
// 2272     mpu_set_accel_fsr(accel_fsr);
        ; Setup parameters for call to function mpu_set_accel_fsr
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_set_accel_fsr?relay
// 2273     mpu_set_lpf(lpf);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_lpf?relay
// 2274     mpu_set_sample_rate(sample_rate);
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_sample_rate?relay
// 2275     mpu_set_sensors(sensors_on);
        ; Setup parameters for call to function mpu_set_sensors
        MOV     R1,?V0 + 1
        LCALL   ??mpu_set_sensors?relay
// 2276     mpu_configure_fifo(fifo_sensors);
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_configure_fifo?relay
// 2277 
// 2278     if (dmp_was_on)
        MOV     A,?V0 + 0
        JZ      ??mpu_run_self_test_14
// 2279         mpu_set_dmp_state(1);
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x1
        LCALL   ??mpu_set_dmp_state?relay
// 2280 
// 2281     return result;
??mpu_run_self_test_14:
        MOV     A,R6
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,#0x20
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock36
// 2282 }
// 2283 
// 2284 /**
// 2285  *  @brief      Write to the DMP memory.
// 2286  *  This function prevents I2C writes past the bank boundaries. The DMP memory
// 2287  *  is only accessible when the chip is awake.
// 2288  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
// 2289  *  @param[in]  length      Number of bytes to write.
// 2290  *  @param[in]  data        Bytes to write to memory.
// 2291  *  @return     0 if successful.
// 2292  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2293 int mpu_write_mem(unsigned short mem_addr, unsigned short length,
mpu_write_mem:
        CFI Block cfiBlock37 Using cfiCommon0
        CFI Function mpu_write_mem
        CODE
// 2294         unsigned char *data)
// 2295 {
        FUNCALL mpu_write_mem, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_write_mem, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2296     unsigned char tmp[2];
// 2297 
// 2298     if (!data)
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??mpu_write_mem_0
// 2299         return -1;
??mpu_write_mem_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_write_mem_2 & 0xFFFF
// 2300     if (!st.chip_cfg.sensors)
??mpu_write_mem_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??mpu_write_mem_1
// 2301         return -1;
// 2302 
// 2303     tmp[0] = (unsigned char)(mem_addr >> 8);
        MOV     A,R3
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2304     tmp[1] = (unsigned char)(mem_addr & 0xFF);
        MOV     A,R2
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2305 
// 2306     /* Check bank boundaries. */
// 2307     if (tmp[1] + length > st.hw->bank_size)
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R6
        MOV     R2,A
        CLR     A
        ADDC    A,R7
        MOV     R3,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        JC      ??mpu_write_mem_1
// 2308         return -1;
// 2309 
// 2310     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x18
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     DPL,?V0 + 2
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_write_mem_1
// 2311         return -1;
// 2312     if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     A,R6
        MOV     R3,A
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_write_mem_1 & 0xFFFF
// 2313         return -1;
// 2314     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_write_mem_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock37
// 2315 }
// 2316 
// 2317 /**
// 2318  *  @brief      Read from the DMP memory.
// 2319  *  This function prevents I2C reads past the bank boundaries. The DMP memory
// 2320  *  is only accessible when the chip is awake.
// 2321  *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
// 2322  *  @param[in]  length      Number of bytes to read.
// 2323  *  @param[out] data        Bytes read from memory.
// 2324  *  @return     0 if successful.
// 2325  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2326 int mpu_read_mem(unsigned short mem_addr, unsigned short length,
mpu_read_mem:
        CFI Block cfiBlock38 Using cfiCommon0
        CFI Function mpu_read_mem
        CODE
// 2327         unsigned char *data)
// 2328 {
        FUNCALL mpu_read_mem, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_read_mem, MPU_Read_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2329     unsigned char tmp[2];
// 2330 
// 2331     if (!data)
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??mpu_read_mem_0
// 2332         return -1;
??mpu_read_mem_1:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_read_mem_2 & 0xFFFF
// 2333     if (!st.chip_cfg.sensors)
??mpu_read_mem_0:
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        JZ      ??mpu_read_mem_1
// 2334         return -1;
// 2335 
// 2336     tmp[0] = (unsigned char)(mem_addr >> 8);
        MOV     A,R3
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2337     tmp[1] = (unsigned char)(mem_addr & 0xFF);
        MOV     A,R2
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2338 
// 2339     /* Check bank boundaries. */
// 2340     if (tmp[1] + length > st.hw->bank_size)
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R6
        MOV     R2,A
        CLR     A
        ADDC    A,R7
        MOV     R3,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R2
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        JC      ??mpu_read_mem_1
// 2341         return -1;
// 2342 
// 2343     if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x18
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     DPL,?V0 + 2
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_read_mem_1
// 2344         return -1;
// 2345     if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
        ; Setup parameters for call to function MPU_Read_Len
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     A,R6
        MOV     R3,A
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Read_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_read_mem_1 & 0xFFFF
// 2346         return -1;
// 2347     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_read_mem_2:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock38
// 2348 }
// 2349 
// 2350 /**
// 2351  *  @brief      Load and verify DMP image.
// 2352  *  @param[in]  length      Length of DMP image.
// 2353  *  @param[in]  firmware    DMP code.
// 2354  *  @param[in]  start_addr  Starting address of DMP code memory.
// 2355  *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
// 2356  *  @return     0 if successful.
// 2357  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2358 int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
mpu_load_firmware:
        CFI Block cfiBlock39 Using cfiCommon0
        CFI Function mpu_load_firmware
        CODE
// 2359     unsigned short start_addr, unsigned short sample_rate)
// 2360 {
        FUNCALL mpu_load_firmware, mpu_write_mem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_load_firmware, mpu_read_mem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_load_firmware, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_load_firmware, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x16
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 22)
        ; Saved register size: 22
        ; Auto size: 18
        MOV     A,#-0x12
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 4,R4
        MOV     ?V0 + 5,R5
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     A,#0x2a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
// 2361     unsigned short ii;
// 2362     unsigned short this_write;
// 2363     /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
// 2364 #define LOAD_CHUNK  (16)
// 2365     unsigned char cur[LOAD_CHUNK], tmp[2];
// 2366 
// 2367     if (st.chip_cfg.dmp_loaded)
        MOV     DPTR,#st + 30
        MOVX    A,@DPTR
        JZ      ??mpu_load_firmware_0
// 2368         /* DMP should only be loaded once. */
// 2369         return -1;
??mpu_load_firmware_1:
        MOV     R2,#-0x1
??mpu_load_firmware_2:
        MOV     R3,#-0x1
        LJMP    ??mpu_load_firmware_3 & 0xFFFF
// 2370 
// 2371     if (!firmware)
??mpu_load_firmware_0:
        MOV     A,R4
        ORL     A,?V0 + 5
        JZ      ??mpu_load_firmware_1
// 2372         return -1;
// 2373     for (ii = 0; ii < length; ii += this_write) {
        MOV     R6,#0x0
        MOV     R7,#0x0
        SJMP    ??mpu_load_firmware_4
??mpu_load_firmware_5:
        MOV     A,R6
        ADD     A,?V0 + 10
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 11
        MOV     R7,A
??mpu_load_firmware_4:
        CLR     C
        MOV     A,R6
        SUBB    A,?V0 + 2
        MOV     A,R7
        SUBB    A,?V0 + 3
        JC      $+5
        LJMP    ??mpu_load_firmware_6 & 0xFFFF
// 2374         this_write = min(LOAD_CHUNK, length - ii);
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,R6
        MOV     R0,A
        MOV     A,?V0 + 3
        SUBB    A,R7
        MOV     R1,A
        CLR     C
        MOV     A,R0
        SUBB    A,#0x11
        MOV     A,R1
        SUBB    A,#0x0
        JC      ??mpu_load_firmware_7
        MOV     ?V0 + 10,#0x10
        MOV     ?V0 + 11,#0x0
        SJMP    ??mpu_load_firmware_8
??mpu_load_firmware_7:
        MOV     ?V0 + 10,R0
        MOV     ?V0 + 11,R1
// 2375         if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
??mpu_load_firmware_8:
        MOV     A,?V0 + 4
        ADD     A,R6
        MOV     ?V0 + 12,A
        MOV     A,?V0 + 5
        ADDC    A,R7
        MOV     ?V0 + 13,A
        ; Setup parameters for call to function mpu_write_mem
        MOV     R0,#?V0 + 12
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 42)
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??mpu_write_mem?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 9,R3
        MOV     A,R2
        ORL     A,?V0 + 9
        JNZ     ??mpu_load_firmware_1
// 2376             return -1;
// 2377         if (mpu_read_mem(ii, this_write, cur))
        ; Setup parameters for call to function mpu_read_mem
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 8,DPL
        MOV     ?V0 + 9,DPH
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 42)
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??mpu_read_mem?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 9,R3
        MOV     A,R2
        ORL     A,?V0 + 9
        JZ      $+5
        LJMP    ??mpu_load_firmware_1 & 0xFFFF
// 2378             return -1;
// 2379         if (memcmp(firmware+ii, cur, this_write))
        ; Setup parameters for call to function memcmp
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 42)
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        LCALL   ??memcmp?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 9,R3
        MOV     A,R2
        ORL     A,?V0 + 9
        JNZ     $+5
        LJMP    ??mpu_load_firmware_5 & 0xFFFF
// 2380             return -2;
        MOV     R2,#-0x2
        LJMP    ??mpu_load_firmware_2 & 0xFFFF
// 2381     }
// 2382 
// 2383     /* Set program start address. */
// 2384     tmp[0] = start_addr >> 8;
??mpu_load_firmware_6:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 2385     tmp[1] = start_addr & 0xFF;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 2386     if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x1a
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_load_firmware_1 & 0xFFFF
// 2387         return -1;
// 2388 
// 2389     st.chip_cfg.dmp_loaded = 1;
        MOV     DPTR,#st + 30
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2390     st.chip_cfg.dmp_sample_rate = sample_rate;
        INC     DPTR
        MOV     A,?V0 + 6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
// 2391     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_load_firmware_3:
        MOV     A,#0x12
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R7,#0xe
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock39
// 2392 }
// 2393 
// 2394 /**
// 2395  *  @brief      Enable/disable DMP support.
// 2396  *  @param[in]  enable  1 to turn on the DMP.
// 2397  *  @return     0 if successful.
// 2398  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2399 int mpu_set_dmp_state(unsigned char enable)
mpu_set_dmp_state:
        CFI Block cfiBlock40 Using cfiCommon0
        CFI Function mpu_set_dmp_state
        CODE
// 2400 {
        FUNCALL mpu_set_dmp_state, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, mpu_set_bypass
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_set_dmp_state, mpu_reset_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     A,R1
        MOV     R6,A
// 2401     unsigned char tmp;
// 2402     if (st.chip_cfg.dmp_on == enable)
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??mpu_set_dmp_state_0
// 2403         return 0;
??mpu_set_dmp_state_1:
        MOV     R2,#0x0
        MOV     R3,#0x0
??mpu_set_dmp_state_2:
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI CFA_XSP16 add(XSP16, 10)
// 2404 
// 2405     if (enable) {
??mpu_set_dmp_state_0:
        MOV     A,R6
        JZ      ??mpu_set_dmp_state_3
// 2406         if (!st.chip_cfg.dmp_loaded)
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??mpu_set_dmp_state_4
// 2407             return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??mpu_set_dmp_state_2
// 2408         /* Disable data ready interrupt. */
// 2409         set_int_enable(0);
??mpu_set_dmp_state_4:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x0
        LCALL   ??set_int_enable?relay
// 2410         /* Disable bypass mode. */
// 2411         mpu_set_bypass(0);
        ; Setup parameters for call to function mpu_set_bypass
        MOV     R1,#0x0
        LCALL   ??mpu_set_bypass?relay
// 2412         /* Keep constant sample rate, FIFO rate controlled by DMP. */
// 2413         mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     DPTR,#st + 31
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_sample_rate?relay
// 2414         /* Remove FIFO elements. */
// 2415         tmp = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 2416         i2c_write(st.hw->addr, 0x23, 1, &tmp);
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     R2,#0x23
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
// 2417         st.chip_cfg.dmp_on = 1;
        MOV     DPTR,#st + 29
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2418         /* Enable DMP interrupt. */
// 2419         set_int_enable(1);
        ; Setup parameters for call to function set_int_enable
        MOV     R1,A
        LCALL   ??set_int_enable?relay
// 2420         mpu_reset_fifo();
        ; Setup parameters for call to function mpu_reset_fifo
??mpu_set_dmp_state_5:
        LCALL   ??mpu_reset_fifo?relay
        SJMP    ??mpu_set_dmp_state_1
// 2421     } else {
// 2422         /* Disable DMP interrupt. */
// 2423         set_int_enable(0);
??mpu_set_dmp_state_3:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x0
        LCALL   ??set_int_enable?relay
// 2424         /* Restore FIFO settings. */
// 2425         tmp = st.chip_cfg.fifo_enable;
        MOV     DPTR,#st + 11
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2426         i2c_write(st.hw->addr, 0x23, 1, &tmp);
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     R2,#0x23
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
// 2427         st.chip_cfg.dmp_on = 0;
        MOV     DPTR,#st + 29
        CLR     A
        MOVX    @DPTR,A
// 2428         mpu_reset_fifo();
        ; Setup parameters for call to function mpu_reset_fifo
        SJMP    ??mpu_set_dmp_state_5
        CFI EndBlock cfiBlock40
// 2429     }
// 2430     return 0;
// 2431 }
// 2432 
// 2433 /**
// 2434  *  @brief      Get DMP state.
// 2435  *  @param[out] enabled 1 if enabled.
// 2436  *  @return     0 if successful.
// 2437  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2438 int mpu_get_dmp_state(unsigned char *enabled)
mpu_get_dmp_state:
        CFI Block cfiBlock41 Using cfiCommon0
        CFI Function mpu_get_dmp_state
        CODE
// 2439 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 2440     enabled[0] = st.chip_cfg.dmp_on;
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
// 2441     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock41
// 2442 }
// 2443 
// 2444 
// 2445 /* This initialization is similar to the one in ak8975.c. */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2446 int setup_compass(void)
setup_compass:
        CFI Block cfiBlock42 Using cfiCommon0
        CFI Function setup_compass
        CODE
// 2447 {
        ; Saved register size: 0
        ; Auto size: 0
// 2448 #ifdef AK89xx_SECONDARY
// 2449     unsigned char data[4], akm_addr;
// 2450 
// 2451     mpu_set_bypass(1);
// 2452 
// 2453     /* Find compass. Possible addresses range from 0x0C to 0x0F. */
// 2454     for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
// 2455         int result;
// 2456         result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
// 2457         if (!result && (data[0] == AKM_WHOAMI))
// 2458             break;
// 2459     }
// 2460 
// 2461     if (akm_addr > 0x0F) {
// 2462         /* TODO: Handle this case in all compass-related functions. */
// 2463         log_e("Compass not found.\n");
// 2464         return -1;
// 2465     }
// 2466 
// 2467     st.chip_cfg.compass_addr = akm_addr;
// 2468 
// 2469     data[0] = AKM_POWER_DOWN;
// 2470     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
// 2471         return -1;
// 2472     delay_ms(1);
// 2473 
// 2474     data[0] = AKM_FUSE_ROM_ACCESS;
// 2475     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
// 2476         return -1;
// 2477     delay_ms(1);
// 2478 
// 2479     /* Get sensitivity adjustment data from fuse ROM. */
// 2480     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
// 2481         return -1;
// 2482     st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
// 2483     st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
// 2484     st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
// 2485 
// 2486     data[0] = AKM_POWER_DOWN;
// 2487     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
// 2488         return -1;
// 2489     delay_ms(1);
// 2490 
// 2491     mpu_set_bypass(0);
// 2492 
// 2493     /* Set up master mode, master clock, and ES bit. */
// 2494     data[0] = 0x40;
// 2495     if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
// 2496         return -1;
// 2497 
// 2498     /* Slave 0 reads from AKM data registers. */
// 2499     data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
// 2500     if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
// 2501         return -1;
// 2502 
// 2503     /* Compass reads start at this register. */
// 2504     data[0] = AKM_REG_ST1;
// 2505     if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
// 2506         return -1;
// 2507 
// 2508     /* Enable slave 0, 8-byte reads. */
// 2509     data[0] = BIT_SLAVE_EN | 8;
// 2510     if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
// 2511         return -1;
// 2512 
// 2513     /* Slave 1 changes AKM measurement mode. */
// 2514     data[0] = st.chip_cfg.compass_addr;
// 2515     if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
// 2516         return -1;
// 2517 
// 2518     /* AKM measurement mode register. */
// 2519     data[0] = AKM_REG_CNTL;
// 2520     if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
// 2521         return -1;
// 2522 
// 2523     /* Enable slave 1, 1-byte writes. */
// 2524     data[0] = BIT_SLAVE_EN | 1;
// 2525     if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
// 2526         return -1;
// 2527 
// 2528     /* Set slave 1 data. */
// 2529     data[0] = AKM_SINGLE_MEASUREMENT;
// 2530     if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
// 2531         return -1;
// 2532 
// 2533     /* Trigger slave 0 and slave 1 actions at each sample. */
// 2534     data[0] = 0x03;
// 2535     if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
// 2536         return -1;
// 2537 
// 2538 #ifdef MPU9150
// 2539     /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
// 2540     data[0] = BIT_I2C_MST_VDDIO;
// 2541     if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
// 2542         return -1;
// 2543 #endif
// 2544 
// 2545     return 0;
// 2546 #else
// 2547     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ?BRET
        CFI EndBlock cfiBlock42
// 2548 #endif
// 2549 }
// 2550 
// 2551 /**
// 2552  *  @brief      Read raw compass data.
// 2553  *  @param[out] data        Raw data in hardware units.
// 2554  *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
// 2555  *  @return     0 if successful.
// 2556  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2557 int mpu_get_compass_reg(short *data, unsigned long *timestamp)
mpu_get_compass_reg:
        CFI Block cfiBlock43 Using cfiCommon0
        CFI Function mpu_get_compass_reg
        CODE
// 2558 {
        ; Saved register size: 0
        ; Auto size: 0
// 2559 #ifdef AK89xx_SECONDARY
// 2560     unsigned char tmp[9];
// 2561 
// 2562     if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
// 2563         return -1;
// 2564 
// 2565 #ifdef AK89xx_BYPASS
// 2566     if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
// 2567         return -1;
// 2568     tmp[8] = AKM_SINGLE_MEASUREMENT;
// 2569     if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
// 2570         return -1;
// 2571 #else
// 2572     if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
// 2573         return -1;
// 2574 #endif
// 2575 
// 2576 #if defined AK8975_SECONDARY
// 2577     /* AK8975 doesn't have the overrun error bit. */
// 2578     if (!(tmp[0] & AKM_DATA_READY))
// 2579         return -2;
// 2580     if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
// 2581         return -3;
// 2582 #elif defined AK8963_SECONDARY
// 2583     /* AK8963 doesn't have the data read error bit. */
// 2584     if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
// 2585         return -2;
// 2586     if (tmp[7] & AKM_OVERFLOW)
// 2587         return -3;
// 2588 #endif
// 2589     data[0] = (tmp[2] << 8) | tmp[1];
// 2590     data[1] = (tmp[4] << 8) | tmp[3];
// 2591     data[2] = (tmp[6] << 8) | tmp[5];
// 2592 
// 2593     data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
// 2594     data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
// 2595     data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
// 2596 
// 2597     if (timestamp)
// 2598         get_ms(timestamp);
// 2599     return 0;
// 2600 #else
// 2601     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ?BRET
        CFI EndBlock cfiBlock43
// 2602 #endif
// 2603 }
// 2604 
// 2605 /**
// 2606  *  @brief      Get the compass full-scale range.
// 2607  *  @param[out] fsr Current full-scale range.
// 2608  *  @return     0 if successful.
// 2609  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2610 int mpu_get_compass_fsr(unsigned short *fsr)
mpu_get_compass_fsr:
        CFI Block cfiBlock44 Using cfiCommon0
        CFI Function mpu_get_compass_fsr
        CODE
// 2611 {
        ; Saved register size: 0
        ; Auto size: 0
// 2612 #ifdef AK89xx_SECONDARY
// 2613     fsr[0] = st.hw->compass_fsr;
// 2614     return 0;
// 2615 #else
// 2616     return -1;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ?BRET
        CFI EndBlock cfiBlock44
// 2617 #endif
// 2618 }
// 2619 
// 2620 /**
// 2621  *  @brief      Enters LP accel motion interrupt mode.
// 2622  *  The behavior of this feature is very different between the MPU6050 and the
// 2623  *  MPU6500. Each chip's version of this feature is explained below.
// 2624  *
// 2625  *  \n MPU6050:
// 2626  *  \n When this mode is first enabled, the hardware captures a single accel
// 2627  *  sample, and subsequent samples are compared with this one to determine if
// 2628  *  the device is in motion. Therefore, whenever this "locked" sample needs to
// 2629  *  be changed, this function must be called again.
// 2630  *
// 2631  *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
// 2632  *  increments.
// 2633  *
// 2634  *  \n Low-power accel mode supports the following frequencies:
// 2635  *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
// 2636  *
// 2637  *  \n MPU6500:
// 2638  *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
// 2639  *  sample. The hardware monitors the accel data and detects any large change
// 2640  *  over a short period of time.
// 2641  *
// 2642  *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
// 2643  *  increments.
// 2644  *
// 2645  *  \n MPU6500 Low-power accel mode supports the following frequencies:
// 2646  *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
// 2647  *
// 2648  *  \n\n NOTES:
// 2649  *  \n The driver will round down @e thresh to the nearest supported value if
// 2650  *  an unsupported threshold is selected.
// 2651  *  \n To select a fractional wake-up frequency, round down the value passed to
// 2652  *  @e lpa_freq.
// 2653  *  \n The MPU6500 does not support a delay parameter. If this function is used
// 2654  *  for the MPU6500, the value passed to @e time will be ignored.
// 2655  *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
// 2656  *  the previous configuration.
// 2657  *
// 2658  *  @param[in]  thresh      Motion threshold in mg.
// 2659  *  @param[in]  time        Duration in milliseconds that the accel data must
// 2660  *                          exceed @e thresh before motion is reported.
// 2661  *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
// 2662  *  @return     0 if successful.
// 2663  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2664 int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
mpu_lp_motion_interrupt:
        CFI Block cfiBlock45 Using cfiCommon0
        CFI Function mpu_lp_motion_interrupt
        CODE
// 2665     unsigned char lpa_freq)
// 2666 {
        FUNCALL mpu_lp_motion_interrupt, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_get_fifo_config
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, set_int_enable
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_lp_accel_mode
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, delay_ms
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, MPU_Write_Len
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_sensors
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_gyro_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_accel_fsr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_lpf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_lp_motion_interrupt, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 3
        MOV     A,#-0x3
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 13)
        MOV     A,R1
        MOV     R7,A
        MOV     A,R4
        MOV     R6,A
// 2667     unsigned char data[3];
// 2668 
// 2669     if (lpa_freq) {
        JNZ     $+5
        LJMP    ??mpu_lp_motion_interrupt_0 & 0xFFFF
// 2670         unsigned char thresh_hw;
// 2671 
// 2672 #if defined MPU6050
// 2673         /* TODO: Make these const/#defines. */
// 2674         /* 1LSb = 32mg. */
// 2675         if (thresh > 8160)
        CLR     C
        MOV     A,R2
        SUBB    A,#-0x1f
        MOV     A,R3
        SUBB    A,#0x1f
        JC      ??mpu_lp_motion_interrupt_1
// 2676             thresh_hw = 255;
        MOV     ?V0 + 0,#-0x1
        SJMP    ??mpu_lp_motion_interrupt_2
// 2677         else if (thresh < 32)
??mpu_lp_motion_interrupt_1:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x20
        MOV     A,R3
        SUBB    A,#0x0
        JNC     ??mpu_lp_motion_interrupt_3
// 2678             thresh_hw = 1;
        MOV     ?V0 + 0,#0x1
        SJMP    ??mpu_lp_motion_interrupt_2
// 2679         else
// 2680             thresh_hw = thresh >> 5;
??mpu_lp_motion_interrupt_3:
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#0x5
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
// 2681 #elif defined MPU6500
// 2682         /* 1LSb = 4mg. */
// 2683         if (thresh > 1020)
// 2684             thresh_hw = 255;
// 2685         else if (thresh < 4)
// 2686             thresh_hw = 1;
// 2687         else
// 2688             thresh_hw = thresh >> 2;
// 2689 #endif
// 2690 
// 2691         if (!time)
??mpu_lp_motion_interrupt_2:
        MOV     A,R7
        JNZ     ??mpu_lp_motion_interrupt_4
// 2692             /* Minimum duration must be 1ms. */
// 2693             time = 1;
        MOV     R7,#0x1
// 2694 
// 2695 #if defined MPU6050
// 2696         if (lpa_freq > 40)
??mpu_lp_motion_interrupt_4:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x29
        JC      ??mpu_lp_motion_interrupt_5
// 2697 #elif defined MPU6500
// 2698         if (lpa_freq > 640)
// 2699 #endif
// 2700             /* At this point, the chip has not been re-configured, so the
// 2701              * function can safely exit.
// 2702              */
// 2703             return -1;
??mpu_lp_motion_interrupt_6:
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
// 2704 
// 2705         if (!st.chip_cfg.int_motion_only) {
??mpu_lp_motion_interrupt_5:
        MOV     DPTR,#st + 16
        MOVX    A,@DPTR
        JNZ     ??mpu_lp_motion_interrupt_8
// 2706             /* Store current settings for later. */
// 2707             if (st.chip_cfg.dmp_on) {
        MOV     DPTR,#st + 29
        MOVX    A,@DPTR
        JZ      ??mpu_lp_motion_interrupt_9
// 2708                 mpu_set_dmp_state(0);
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x0
        LCALL   ??mpu_set_dmp_state?relay
// 2709                 st.chip_cfg.cache.dmp_on = 1;
        MOV     DPTR,#st + 26
        MOV     A,#0x1
        SJMP    ??mpu_lp_motion_interrupt_10
// 2710             } else
// 2711                 st.chip_cfg.cache.dmp_on = 0;
??mpu_lp_motion_interrupt_9:
        MOV     DPTR,#st + 26
        CLR     A
??mpu_lp_motion_interrupt_10:
        MOVX    @DPTR,A
// 2712             mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
        ; Setup parameters for call to function mpu_get_gyro_fsr
        MOV     R2,#(st + 17) & 0xff
        MOV     R3,#((st + 17) >> 8) & 0xff
        LCALL   ??mpu_get_gyro_fsr?relay
// 2713             mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
        ; Setup parameters for call to function mpu_get_accel_fsr
        MOV     R2,#(st + 19) & 0xff
        MOV     R3,#((st + 19) >> 8) & 0xff
        LCALL   ??mpu_get_accel_fsr?relay
// 2714             mpu_get_lpf(&st.chip_cfg.cache.lpf);
        ; Setup parameters for call to function mpu_get_lpf
        MOV     R2,#(st + 20) & 0xff
        MOV     R3,#((st + 20) >> 8) & 0xff
        LCALL   ??mpu_get_lpf?relay
// 2715             mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
        ; Setup parameters for call to function mpu_get_sample_rate
        MOV     R2,#(st + 22) & 0xff
        MOV     R3,#((st + 22) >> 8) & 0xff
        LCALL   ??mpu_get_sample_rate?relay
// 2716             st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
        MOV     DPTR,#st + 6
        MOVX    A,@DPTR
        MOV     DPTR,#st + 24
        MOVX    @DPTR,A
// 2717             mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
        ; Setup parameters for call to function mpu_get_fifo_config
        MOV     R2,#(st + 25) & 0xff
        MOV     R3,#((st + 25) >> 8) & 0xff
        LCALL   ??mpu_get_fifo_config?relay
// 2718         }
// 2719 
// 2720 #ifdef MPU6050
// 2721         /* Disable hardware interrupts for now. */
// 2722         set_int_enable(0);
??mpu_lp_motion_interrupt_8:
        ; Setup parameters for call to function set_int_enable
        MOV     R1,#0x0
        LCALL   ??set_int_enable?relay
// 2723 
// 2724         /* Enter full-power accel-only mode. */
// 2725         mpu_lp_accel_mode(0);
        ; Setup parameters for call to function mpu_lp_accel_mode
        MOV     R1,#0x0
        LCALL   ??mpu_lp_accel_mode?relay
// 2726 
// 2727         /* Override current LPF (and HPF) settings to obtain a valid accel
// 2728          * reading.
// 2729          */
// 2730         data[0] = INV_FILTER_256HZ_NOLPF2;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
// 2731         if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
// 2732             return -1;
// 2733 
// 2734         /* NOTE: Digital high pass filter should be configured here. Since this
// 2735          * driver doesn't modify those bits anywhere, they should already be
// 2736          * cleared by default.
// 2737          */
// 2738 
// 2739         /* Configure the device to send motion interrupts. */
// 2740         /* Enable motion interrupt. */
// 2741         data[0] = BIT_MOT_INT_EN;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x40
        MOVX    @DPTR,A
// 2742         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
// 2743             goto lp_int_restore;
// 2744 
// 2745         /* Set motion interrupt parameters. */
// 2746         data[0] = thresh_hw;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
// 2747         data[1] = time;
        MOV     A,R7
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 2748         if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
// 2749             goto lp_int_restore;
// 2750 
// 2751         /* Force hardware to "lock" current accel sample. */
// 2752         delay_ms(5);
        ; Setup parameters for call to function delay_ms
        MOV     DPTR,#__Constant_5
        LCALL   ?XLOAD_R2345
        LCALL   ??delay_ms?relay
// 2753         data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
        MOV     DPTR,#st + 5
        MOVX    A,@DPTR
        RLC     A
        RLC     A
        RLC     A
        ANL     A,#0xf8
        ORL     A,#0x7
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 2754         if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x1
        MOV     DPTR,#st
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JZ      $+5
        LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
// 2755             goto lp_int_restore;
// 2756 
// 2757         /* Set up LP accel mode. */
// 2758         data[0] = BIT_LPA_CYCLE;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x20
        MOVX    @DPTR,A
// 2759         if (lpa_freq == 1)
        MOV     A,#0x1
        XRL     A,R6
        JNZ     ??mpu_lp_motion_interrupt_12
// 2760             data[1] = INV_LPA_1_25HZ;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        SJMP    ??mpu_lp_motion_interrupt_13
// 2761         else if (lpa_freq <= 5)
??mpu_lp_motion_interrupt_12:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x6
        JNC     ??mpu_lp_motion_interrupt_14
// 2762             data[1] = INV_LPA_5HZ;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        SJMP    ??mpu_lp_motion_interrupt_13
// 2763         else if (lpa_freq <= 20)
??mpu_lp_motion_interrupt_14:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x15
        MOV     A,#0x1
        JNC     ??mpu_lp_motion_interrupt_15
// 2764             data[1] = INV_LPA_20HZ;
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x2
        SJMP    ??mpu_lp_motion_interrupt_13
// 2765         else
// 2766             data[1] = INV_LPA_40HZ;
??mpu_lp_motion_interrupt_15:
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x3
??mpu_lp_motion_interrupt_13:
        MOVX    @DPTR,A
// 2767         data[1] = (data[1] << 6) | BIT_STBY_XYZG;
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        SWAP    A
        RLC     A
        RLC     A
        ANL     A,#0xc0
        ORL     A,#0x7
        MOVX    @DPTR,A
// 2768         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
        ; Setup parameters for call to function MPU_Write_Len
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R3,#0x2
        MOV     DPTR,#st
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#st + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??MPU_Write_Len?relay
        MOV     A,R1
        JNZ     ??mpu_lp_motion_interrupt_11
// 2769             goto lp_int_restore;
// 2770 
// 2771         st.chip_cfg.int_motion_only = 1;
        MOV     DPTR,#st + 16
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2772         return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
// 2773 #elif defined MPU6500
// 2774         /* Disable hardware interrupts. */
// 2775         set_int_enable(0);
// 2776 
// 2777         /* Enter full-power accel-only mode, no FIFO/DMP. */
// 2778         data[0] = 0;
// 2779         data[1] = 0;
// 2780         data[2] = BIT_STBY_XYZG;
// 2781         if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
// 2782             goto lp_int_restore;
// 2783 
// 2784         /* Set motion threshold. */
// 2785         data[0] = thresh_hw;
// 2786         if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
// 2787             goto lp_int_restore;
// 2788 
// 2789         /* Set wake frequency. */
// 2790         if (lpa_freq == 1)
// 2791             data[0] = INV_LPA_1_25HZ;
// 2792         else if (lpa_freq == 2)
// 2793             data[0] = INV_LPA_2_5HZ;
// 2794         else if (lpa_freq <= 5)
// 2795             data[0] = INV_LPA_5HZ;
// 2796         else if (lpa_freq <= 10)
// 2797             data[0] = INV_LPA_10HZ;
// 2798         else if (lpa_freq <= 20)
// 2799             data[0] = INV_LPA_20HZ;
// 2800         else if (lpa_freq <= 40)
// 2801             data[0] = INV_LPA_40HZ;
// 2802         else if (lpa_freq <= 80)
// 2803             data[0] = INV_LPA_80HZ;
// 2804         else if (lpa_freq <= 160)
// 2805             data[0] = INV_LPA_160HZ;
// 2806         else if (lpa_freq <= 320)
// 2807             data[0] = INV_LPA_320HZ;
// 2808         else
// 2809             data[0] = INV_LPA_640HZ;
// 2810         if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
// 2811             goto lp_int_restore;
// 2812 
// 2813         /* Enable motion interrupt (MPU6500 version). */
// 2814         data[0] = BITS_WOM_EN;
// 2815         if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
// 2816             goto lp_int_restore;
// 2817 
// 2818         /* Enable cycle mode. */
// 2819         data[0] = BIT_LPA_CYCLE;
// 2820         if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
// 2821             goto lp_int_restore;
// 2822 
// 2823         /* Enable interrupt. */
// 2824         data[0] = BIT_MOT_INT_EN;
// 2825         if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
// 2826             goto lp_int_restore;
// 2827 
// 2828         st.chip_cfg.int_motion_only = 1;
// 2829         return 0;
// 2830 #endif
// 2831     } else {
// 2832         /* Don't "restore" the previous state if no state has been saved. */
// 2833         int ii;
// 2834         char *cache_ptr = (char*)&st.chip_cfg.cache;
// 2835         for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
??mpu_lp_motion_interrupt_0:
        MOV     R0,#0x0
        MOV     R1,#0x0
        SJMP    ??mpu_lp_motion_interrupt_16
??mpu_lp_motion_interrupt_17:
        MOV     A,R0
        ADD     A,#0x1
        INC     R0
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
??mpu_lp_motion_interrupt_16:
        CLR     C
        MOV     A,R0
        SUBB    A,#0xa
        MOV     A,R1
        SUBB    A,#0x0
        JC      $+5
        LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
// 2836             if (cache_ptr[ii] != 0)
        MOV     A,#(st + 17) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((st + 17) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      ??mpu_lp_motion_interrupt_17
// 2837                 goto lp_int_restore;
// 2838         }
// 2839         /* If we reach this point, motion interrupt mode hasn't been used yet. */
// 2840         return -1;
// 2841     }
// 2842 lp_int_restore:
// 2843     /* Set to invalid values to ensure no I2C writes are skipped. */
// 2844     st.chip_cfg.gyro_fsr = 0xFF;
??mpu_lp_motion_interrupt_11:
        MOV     DPTR,#st + 4
        MOV     A,#-0x1
        MOVX    @DPTR,A
// 2845     st.chip_cfg.accel_fsr = 0xFF;
        INC     DPTR
        MOVX    @DPTR,A
// 2846     st.chip_cfg.lpf = 0xFF;
        MOV     DPTR,#st + 7
        MOVX    @DPTR,A
// 2847     st.chip_cfg.sample_rate = 0xFFFF;
        MOV     DPTR,#st + 9
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 2848     st.chip_cfg.sensors = 0xFF;
        MOV     DPTR,#st + 6
        MOVX    @DPTR,A
// 2849     st.chip_cfg.fifo_enable = 0xFF;
        MOV     DPTR,#st + 11
        MOVX    @DPTR,A
// 2850     st.chip_cfg.clk_src = INV_CLK_PLL;
        MOV     DPTR,#st + 8
        MOV     A,#0x1
        MOVX    @DPTR,A
// 2851     mpu_set_sensors(st.chip_cfg.cache.sensors_on);
        ; Setup parameters for call to function mpu_set_sensors
        MOV     DPTR,#st + 24
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_set_sensors?relay
// 2852     mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
        ; Setup parameters for call to function mpu_set_gyro_fsr
        MOV     DPTR,#st + 17
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_gyro_fsr?relay
// 2853     mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
        ; Setup parameters for call to function mpu_set_accel_fsr
        MOV     DPTR,#st + 19
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_set_accel_fsr?relay
// 2854     mpu_set_lpf(st.chip_cfg.cache.lpf);
        ; Setup parameters for call to function mpu_set_lpf
        MOV     DPTR,#st + 20
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_lpf?relay
// 2855     mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     DPTR,#st + 22
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??mpu_set_sample_rate?relay
// 2856     mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     DPTR,#st + 25
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??mpu_configure_fifo?relay
// 2857 
// 2858     if (st.chip_cfg.cache.dmp_on)
        MOV     DPTR,#st + 26
        MOVX    A,@DPTR
        JZ      ??mpu_lp_motion_interrupt_18
// 2859         mpu_set_dmp_state(1);
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x1
        LCALL   ??mpu_set_dmp_state?relay
// 2860 
// 2861 #ifdef MPU6500
// 2862     /* Disable motion interrupt (MPU6500 version). */
// 2863     data[0] = 0;
// 2864     if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
// 2865         goto lp_int_restore;
// 2866 #endif
// 2867 
// 2868     st.chip_cfg.int_motion_only = 0;
??mpu_lp_motion_interrupt_18:
        MOV     DPTR,#st + 16
        CLR     A
        MOVX    @DPTR,A
// 2869     return 0;
        MOV     R2,A
        MOV     R3,A
??mpu_lp_motion_interrupt_7:
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock45
// 2870 }
// 2871 
// 2872 //q30格式,long转float时的除数.
// 2873 #define q30  1073741824.0f
// 2874 
// 2875 //陀螺仪方向设置

        RSEG XDATA_I:XDATA:NOROOT(0)
// 2876 static signed char gyro_orientation[9] = { 1, 0, 0,
gyro_orientation:
        DATA8
        DS 9
        REQUIRE `?<Initializer for gyro_orientation>`
        REQUIRE __INIT_XDATA_I
// 2877                                            0, 1, 0,
// 2878                                            0, 0, 1};
// 2879 //MPU6050自测试
// 2880 //返回值:0,正常
// 2881 //    其他,失败

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2882 u8 run_self_test(void)
run_self_test:
        CFI Block cfiBlock46 Using cfiCommon0
        CFI Function run_self_test
        CODE
// 2883 {
        FUNCALL run_self_test, mpu_run_self_test
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL run_self_test, mpu_get_gyro_sens
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL run_self_test, dmp_set_gyro_bias
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL run_self_test, mpu_get_accel_sens
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL run_self_test, dmp_set_accel_bias
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 30
        MOV     A,#-0x1e
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 46)
// 2884   int result;
// 2885   //char test_packet[4] = {0};
// 2886   long gyro[3], accel[3]; 
// 2887   result = mpu_run_self_test(gyro, accel);
// 2888   if (result == 0x3) 
        ; Setup parameters for call to function mpu_run_self_test
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_run_self_test?relay
        MOV     ?V0 + 0,R2
        MOV     A,#0x3
        XRL     A,?V0 + 0
        JNZ     ??run_self_test_0
        MOV     A,R3
??run_self_test_0:
        JZ      $+5
        LJMP    ??run_self_test_1 & 0xFFFF
// 2889   {
// 2890       /* Test passed. We can trust the gyro data here, so let's push it down
// 2891       * to the DMP.
// 2892       */
// 2893       float sens;
// 2894       unsigned short accel_sens;
// 2895       mpu_get_gyro_sens(&sens);
        ; Setup parameters for call to function mpu_get_gyro_sens
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_gyro_sens?relay
// 2896       gyro[0] = (long)(gyro[0] * sens);
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        LCALL   ?FLT_TO_L
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2897       gyro[1] = (long)(gyro[1] * sens);
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        LCALL   ?FLT_TO_L
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2898       gyro[2] = (long)(gyro[2] * sens);
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        LCALL   ?FLT_TO_L
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 2899       dmp_set_gyro_bias(gyro);
        ; Setup parameters for call to function dmp_set_gyro_bias
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??dmp_set_gyro_bias?relay
// 2900       mpu_get_accel_sens(&accel_sens);
        ; Setup parameters for call to function mpu_get_accel_sens
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??mpu_get_accel_sens?relay
// 2901       accel_sens=0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 2902       accel[0] *= accel_sens;
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XSTORE_R2345
// 2903       accel[1] *= accel_sens;
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XSTORE_R2345
// 2904       accel[2] *= accel_sens;
        MOV     DPTR,#__Constant_0
        LCALL   ?XLOAD_R2345
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XSTORE_R2345
// 2905       dmp_set_accel_bias(accel);
        ; Setup parameters for call to function dmp_set_accel_bias
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??dmp_set_accel_bias?relay
// 2906       return 0;
        MOV     R1,#0x0
        SJMP    ??run_self_test_2
// 2907   }else return 1;
??run_self_test_1:
        MOV     R1,#0x1
??run_self_test_2:
        MOV     A,#0x1e
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock46
// 2908 }
// 2909 //陀螺仪方向控制

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2910 unsigned short inv_orientation_matrix_to_scalar(
inv_orientation_matrix_to_scalar:
        CFI Block cfiBlock47 Using cfiCommon0
        CFI Function inv_orientation_matrix_to_scalar
        CODE
// 2911     const signed char *mtx)
// 2912 {
        FUNCALL inv_orientation_matrix_to_scalar, inv_row_2_scale
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL inv_orientation_matrix_to_scalar, inv_row_2_scale
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL inv_orientation_matrix_to_scalar, inv_row_2_scale
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 2913     unsigned short scalar; 
// 2914     /*
// 2915        XYZ  010_001_000 Identity Matrix
// 2916        XZY  001_010_000
// 2917        YXZ  010_000_001
// 2918        YZX  000_010_001
// 2919        ZXY  001_000_010
// 2920        ZYX  000_001_010
// 2921      */
// 2922 
// 2923     scalar = inv_row_2_scale(mtx);
        ; Setup parameters for call to function inv_row_2_scale
        LCALL   ??inv_row_2_scale?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 2924     scalar |= inv_row_2_scale(mtx + 3) << 3;
        ; Setup parameters for call to function inv_row_2_scale
        MOV     A,R6
        ADD     A,#0x3
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??inv_row_2_scale?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,#0x3
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,?V0 + 2
        ORL     A,?V0 + 0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 3
        ORL     A,?V0 + 1
        MOV     ?V0 + 1,A
// 2925     scalar |= inv_row_2_scale(mtx + 6) << 6;
        ; Setup parameters for call to function inv_row_2_scale
        MOV     A,R6
        ADD     A,#0x6
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??inv_row_2_scale?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,#0x6
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,?V0 + 2
        ORL     A,?V0 + 0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 3
        ORL     A,?V0 + 1
// 2926 
// 2927 
// 2928     return scalar;
        MOV     R2,?V0 + 0
        MOV     R3,A
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock47
// 2929 }
// 2930 //方向转换

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2931 unsigned short inv_row_2_scale(const signed char *row)
inv_row_2_scale:
        CFI Block cfiBlock48 Using cfiCommon0
        CFI Function inv_row_2_scale
        CODE
// 2932 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 2933     unsigned short b;
// 2934 
// 2935     if (row[0] > 0)
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      ??inv_row_2_scale_0
// 2936         b = 0;
        MOV     R2,#0x0
        SJMP    ??inv_row_2_scale_1
// 2937     else if (row[0] < 0)
??inv_row_2_scale_0:
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??inv_row_2_scale_2
// 2938         b = 4;
        MOV     R2,#0x4
        SJMP    ??inv_row_2_scale_1
// 2939     else if (row[1] > 0)
??inv_row_2_scale_2:
        INC     DPTR
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      ??inv_row_2_scale_3
// 2940         b = 1;
        MOV     R2,#0x1
        SJMP    ??inv_row_2_scale_1
// 2941     else if (row[1] < 0)
??inv_row_2_scale_3:
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??inv_row_2_scale_4
// 2942         b = 5;
        MOV     R2,#0x5
        SJMP    ??inv_row_2_scale_1
// 2943     else if (row[2] > 0)
??inv_row_2_scale_4:
        MOV     A,R2
        ADD     A,#0x2
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      ??inv_row_2_scale_5
// 2944         b = 2;
        MOV     R2,#0x2
        SJMP    ??inv_row_2_scale_1
// 2945     else if (row[2] < 0)
??inv_row_2_scale_5:
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??inv_row_2_scale_6
// 2946         b = 6;
        MOV     R2,#0x6
        SJMP    ??inv_row_2_scale_1
// 2947     else
// 2948         b = 7;      // error
??inv_row_2_scale_6:
        MOV     R2,#0x7
??inv_row_2_scale_1:
        MOV     R3,#0x0
// 2949     return b;
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock48
// 2950 }
// 2951 //空函数,未用到.

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2952 void mget_ms(unsigned long *time)
mget_ms:
        CFI Block cfiBlock49 Using cfiCommon0
        CFI Function mget_ms
        CODE
// 2953 {
        ; Saved register size: 0
        ; Auto size: 0
// 2954 
// 2955 }
        LJMP    ?BRET
        CFI EndBlock cfiBlock49
// 2956 //mpu6050,dmp初始化
// 2957 //返回值:0,正常
// 2958 //    其他,失败

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2959 u8 mpu_dmp_init(void)
mpu_dmp_init:
        CFI Block cfiBlock50 Using cfiCommon0
        CFI Function mpu_dmp_init
        CODE
// 2960 {
        FUNCALL mpu_dmp_init, MPU_IIC_Init
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_init
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_set_sensors
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_configure_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_set_sample_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, dmp_load_motion_driver_firmware
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, inv_orientation_matrix_to_scalar
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, dmp_set_orientation
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, dmp_enable_feature
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, dmp_set_fifo_rate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_init, mpu_set_dmp_state
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
// 2961   u8 res=0;
// 2962   MPU_IIC_Init(); 	//初始化MPU_IIC总线
        ; Setup parameters for call to function MPU_IIC_Init
        LCALL   ??MPU_IIC_Init?relay
// 2963   if(mpu_init()==0)	//初始化MPU6050
        ; Setup parameters for call to function mpu_init
        LCALL   ??mpu_init?relay
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JNZ     ??mpu_dmp_init_0
// 2964   {	 
// 2965       res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);    //设置所需要的传感器
        ; Setup parameters for call to function mpu_set_sensors
        MOV     R1,#0x78
        LCALL   ??mpu_set_sensors?relay
        MOV     A,R2
// 2966       if(res)return 1; 
        JZ      ??mpu_dmp_init_1
        MOV     R1,#0x1
        SJMP    ??mpu_dmp_init_2
// 2967       res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL); //设置FIFO
??mpu_dmp_init_1:
        ; Setup parameters for call to function mpu_configure_fifo
        MOV     R1,#0x78
        LCALL   ??mpu_configure_fifo?relay
        MOV     A,R2
// 2968       if(res)return 2; 
        JZ      ??mpu_dmp_init_3
        MOV     R1,#0x2
        SJMP    ??mpu_dmp_init_2
// 2969       res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	          //设置采样率
??mpu_dmp_init_3:
        ; Setup parameters for call to function mpu_set_sample_rate
        MOV     R2,#0x64
        MOV     R3,#0x0
        LCALL   ??mpu_set_sample_rate?relay
        MOV     A,R2
// 2970       if(res)return 3; 
        JZ      ??mpu_dmp_init_4
        MOV     R1,#0x3
        SJMP    ??mpu_dmp_init_2
// 2971       res=dmp_load_motion_driver_firmware();		  //加载dmp固件
??mpu_dmp_init_4:
        ; Setup parameters for call to function dmp_load_motion_driver_firmware
        LCALL   ??dmp_load_motion_driver_firmware?relay
        MOV     A,R2
// 2972       if(res)return 4; 
        JZ      ??mpu_dmp_init_5
        MOV     R1,#0x4
        SJMP    ??mpu_dmp_init_2
// 2973       res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//设置陀螺仪方向
??mpu_dmp_init_5:
        ; Setup parameters for call to function dmp_set_orientation
        ; Setup parameters for call to function inv_orientation_matrix_to_scalar
        MOV     R2,#gyro_orientation & 0xff
        MOV     R3,#(gyro_orientation >> 8) & 0xff
        LCALL   ??inv_orientation_matrix_to_scalar?relay
        LCALL   ??dmp_set_orientation?relay
        MOV     A,R2
// 2974       if(res)return 5; 
        JZ      ??mpu_dmp_init_6
        MOV     R1,#0x5
        SJMP    ??mpu_dmp_init_2
// 2975       res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	          //设置dmp功能
// 2976           DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
// 2977           DMP_FEATURE_GYRO_CAL);
??mpu_dmp_init_6:
        ; Setup parameters for call to function dmp_enable_feature
        MOV     R2,#0x73
        MOV     R3,#0x1
        LCALL   ??dmp_enable_feature?relay
        MOV     A,R2
// 2978       if(res)return 6; 
        JZ      ??mpu_dmp_init_7
        MOV     R1,#0x6
        SJMP    ??mpu_dmp_init_2
// 2979       res=dmp_set_fifo_rate(DEFAULT_DMP_HZ);  //设置DMP输出速率(最大不超过200Hz)
??mpu_dmp_init_7:
        ; Setup parameters for call to function dmp_set_fifo_rate
        MOV     R2,#0x64
        MOV     R3,#0x0
        LCALL   ??dmp_set_fifo_rate?relay
        MOV     A,R2
// 2980       if(res)return 7;   
        JZ      ??mpu_dmp_init_8
        MOV     R1,#0x7
        SJMP    ??mpu_dmp_init_2
// 2981 //      res=run_self_test();		      //自检
// 2982 //      if(res)return 8;    
// 2983       res=mpu_set_dmp_state(1);	              //使能DMP
??mpu_dmp_init_8:
        ; Setup parameters for call to function mpu_set_dmp_state
        MOV     R1,#0x1
        LCALL   ??mpu_set_dmp_state?relay
        MOV     A,R2
// 2984       if(res)return 9;     
        JZ      ??mpu_dmp_init_9
        MOV     R1,#0x9
        SJMP    ??mpu_dmp_init_2
// 2985   }else return 10;
// 2986   return 0;
??mpu_dmp_init_9:
        MOV     R1,#0x0
        SJMP    ??mpu_dmp_init_2
??mpu_dmp_init_0:
        MOV     R1,#0xa
??mpu_dmp_init_2:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock50
// 2987 }
// 2988 
// 2989 //得到dmp处理后的数据(注意,本函数需要比较多堆栈,局部变量有点多)
// 2990 //pitch:俯仰角 精度:0.1°   范围:-90.0° <---> +90.0°
// 2991 //roll:横滚角  精度:0.1°   范围:-180.0°<---> +180.0°
// 2992 //yaw:航向角   精度:0.1°   范围:-180.0°<---> +180.0°
// 2993 //返回值:0,正常
// 2994 //    其他,失败

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2995 u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
mpu_dmp_get_data:
        CFI Block cfiBlock51 Using cfiCommon0
        CFI Function mpu_dmp_get_data
        CODE
// 2996 {
        FUNCALL mpu_dmp_get_data, dmp_read_fifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 87, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 87, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_get_data, asin
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 79, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 79, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_get_data, atan2
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 83, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 83, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL mpu_dmp_get_data, atan2
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 83, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 83, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 55
        MOV     A,#-0x37
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 79)
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 2997 	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
// 2998 	unsigned long sensor_timestamp;
// 2999 	short gyro[3], accel[3], sensors;
// 3000 	unsigned char more;
// 3001 	long quat[4]; 
// 3002 	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))
        ; Setup parameters for call to function dmp_read_fifo
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 81)
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 83)
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 85)
        MOV     A,#0x21
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 87)
        MOV     A,#0x33
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x39
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??dmp_read_fifo?relay
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 79)
        MOV     ?V0 + 1,R3
        MOV     A,R2
        ORL     A,?V0 + 1
        JZ      ??mpu_dmp_get_data_0
// 3003         {
// 3004           //printf("dmp_read_fifo error\r\n");
// 3005           return 1;	 //gyro
        MOV     R1,#0x1
        LJMP    ??mpu_dmp_get_data_1 & 0xFFFF
// 3006         }
// 3007 	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
// 3008 	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
// 3009 	**/
// 3010 	/*if (sensors & INV_XYZ_GYRO )
// 3011 	send_packet(PACKET_TYPE_GYRO, gyro);
// 3012 	if (sensors & INV_XYZ_ACCEL)
// 3013 	send_packet(PACKET_TYPE_ACCEL, accel); */
// 3014 	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
// 3015 	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
// 3016 	**/
// 3017 	if(sensors&INV_WXYZ_QUAT) 
??mpu_dmp_get_data_0:
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x1
        JNZ     $+5
        LJMP    ??mpu_dmp_get_data_2 & 0xFFFF
// 3018 	{
// 3019 		q0 = quat[0] / q30;	//q30格式转换为浮点数
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_30800000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3020 		q1 = quat[1] / q30;
        MOV     A,#0x1f
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_30800000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3021 		q2 = quat[2] / q30;
        MOV     A,#0x23
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_30800000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3022 		q3 = quat[3] / q30; 
        MOV     A,#0x27
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        LCALL   ?L_TO_FLT
        MOV     DPTR,#__Constant_30800000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3023 		//计算得到俯仰角/横滚角/航向角
// 3024 		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_40000000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 12
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_c0000000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        ; Setup parameters for call to function asin
        MOV     ?V0 + 0,?V0 + 12
        MOV     ?V0 + 1,?V0 + 13
        MOV     ?V0 + 2,?V0 + 14
        MOV     ?V0 + 3,?V0 + 15
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        PUSH    ?V0 + 0
        CFI CFA_SP SP+-1
        PUSH    ?V0 + 1
        CFI CFA_SP SP+-2
        PUSH    ?V0 + 2
        CFI CFA_SP SP+-3
        PUSH    ?V0 + 3
        CFI CFA_SP SP+-4
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
        MOV     ?V0 + 2,?V0 + 6
        MOV     ?V0 + 3,?V0 + 7
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        POP     ?V0 + 11
        CFI CFA_SP SP+-3
        POP     ?V0 + 10
        CFI CFA_SP SP+-2
        POP     ?V0 + 9
        CFI CFA_SP SP+-1
        POP     ?V0 + 8
        CFI CFA_SP SP+0
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_ADD
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        LCALL   ??asin?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     DPTR,#__Constant_42653333
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3025 		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     DPTR,#__Constant_40000000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        ; Setup parameters for call to function atan2
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        PUSH    ?V0 + 12
        CFI CFA_SP SP+-1
        PUSH    ?V0 + 13
        CFI CFA_SP SP+-2
        PUSH    ?V0 + 14
        CFI CFA_SP SP+-3
        PUSH    ?V0 + 15
        CFI CFA_SP SP+-4
        MOV     ?V0 + 0,?V0 + 8
        MOV     ?V0 + 1,?V0 + 9
        MOV     ?V0 + 2,?V0 + 10
        MOV     ?V0 + 3,?V0 + 11
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 12
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 12
        LCALL   ?FLT_MUL
        POP     ?V0 + 15
        CFI CFA_SP SP+-3
        POP     ?V0 + 14
        CFI CFA_SP SP+-2
        POP     ?V0 + 13
        CFI CFA_SP SP+-1
        POP     ?V0 + 12
        CFI CFA_SP SP+0
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_SUB
        MOV     DPTR,#__Constant_3f800000
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_ADD
        MOV     R0,#?V0 + 12
        LCALL   ?PUSH_XSTACK_I_FOUR
        CFI CFA_XSP16 add(XSP16, 83)
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 0
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 8
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_ADD
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        LCALL   ??atan2?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 79)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     DPTR,#__Constant_42653333
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3026 		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
        ; Setup parameters for call to function atan2
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_ADD
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_SUB
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_SUB
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_FOUR
        CFI CFA_XSP16 add(XSP16, 83)
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 8
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 4
        MOV     R1,#?V0 + 8
        LCALL   ?FLT_MUL
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_ADD
        MOV     DPTR,#__Constant_40000000
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        LCALL   ??atan2?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 79)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     DPTR,#__Constant_42653333
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?FLT_MUL
        MOV     A,#0x4f
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
// 3027 	}
// 3028         else 
// 3029         {
// 3030           return 2;
// 3031         }
// 3032 	return 0;
        MOV     R1,#0x0
        SJMP    ??mpu_dmp_get_data_1
??mpu_dmp_get_data_2:
        MOV     R1,#0x2
??mpu_dmp_get_data_1:
        MOV     A,#0x37
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock51
// 3033 }

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for st>`:
        DATA16
        DW reg
        DW hw
        DATA8
        DB 0
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0
        DATA16
        DW test

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for gyro_orientation>`:
        DATA8
        DB 1
        DB 0
        DB 0
        DB 0
        DB 1
        DB 0
        DB 0
        DB 0
        DB 1

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??set_int_enable?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    set_int_enable

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_reg_dump?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_reg_dump

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_read_reg?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_read_reg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_init?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_lp_accel_mode?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_lp_accel_mode

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_gyro_reg?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_gyro_reg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_accel_reg?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_accel_reg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_temperature?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_temperature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_accel_bias?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_accel_bias

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_reset_fifo?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_reset_fifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_gyro_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_gyro_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_gyro_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_gyro_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_accel_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_accel_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_accel_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_accel_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_lpf?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_lpf

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_lpf?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_lpf

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_sample_rate?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_sample_rate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_sample_rate?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_sample_rate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_compass_sample_rate?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_compass_sample_rate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_compass_sample_rate?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_compass_sample_rate

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_gyro_sens?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_gyro_sens

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_accel_sens?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_accel_sens

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_fifo_config?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_fifo_config

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_configure_fifo?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_configure_fifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_power_state?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_power_state

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_sensors?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_sensors

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_int_status?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_int_status

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_read_fifo?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_read_fifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_read_fifo_stream?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_read_fifo_stream

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_bypass?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_bypass

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_int_level?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_int_level

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_int_latched?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_int_latched

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??get_accel_prod_shift?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    get_accel_prod_shift

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??accel_self_test?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    accel_self_test

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gyro_self_test?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    gyro_self_test

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??get_st_biases?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    get_st_biases

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_run_self_test?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_run_self_test

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_write_mem?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_write_mem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_read_mem?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_read_mem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_load_firmware?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_load_firmware

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_set_dmp_state?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_set_dmp_state

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_dmp_state?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_dmp_state

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??setup_compass?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    setup_compass

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_compass_reg?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_compass_reg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_get_compass_fsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_get_compass_fsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_lp_motion_interrupt?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_lp_motion_interrupt

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??run_self_test?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    run_self_test

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??inv_orientation_matrix_to_scalar?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    inv_orientation_matrix_to_scalar

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??inv_row_2_scale?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    inv_row_2_scale

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mget_ms?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mget_ms

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_dmp_init?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_dmp_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??mpu_dmp_get_data?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    mpu_dmp_get_data

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant "%#5x: %#5x\\r\\n">`:
        DB "%#5x: %#5x\015\012"

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant "Unsupported software ...">`:
        DB "Unsupported software product rev %d.\012"

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant "Product ID read as 0 ...">`:
        DB 50H, 72H, 6FH, 64H, 75H, 63H, 74H, 20H
        DB 49H, 44H, 20H, 72H, 65H, 61H, 64H, 20H
        DB 61H, 73H, 20H, 30H, 20H, 69H, 6EH, 64H
        DB 69H, 63H, 61H, 74H, 65H, 73H, 20H, 64H
        DB 65H, 76H, 69H, 63H, 65H, 20H, 69H, 73H
        DB 20H, 65H, 69H, 74H, 68H, 65H, 72H, 20H
        DB 69H, 6EH, 63H, 6FH, 6DH, 70H, 61H, 74H
        DB 69H, 62H, 6CH, 65H, 20H, 6FH, 72H, 20H
        DB 61H, 6EH, 20H, 4DH, 50H, 55H, 33H, 30H
        DB 35H, 30H, 2EH, 0AH, 0

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant "Half sensitivity part...">`:
        DB "Half sensitivity part found.\012"

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_64:
        DD 100

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_420c0000:
        DD 420C0000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_47800000:
        DD 47800000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_32:
        DD 50

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_43030000:
        DD 43030000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_42830000:
        DD 42830000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_42033333:
        DD 42033333H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_41833333:
        DD 41833333H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3:
        DD 3

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3f845a1d:
        DD 3F845A1DH

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_0:
        DD 0H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3eae147b:
        DD 3EAE147BH

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3e99999a:
        DD 3E99999AH

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3f733334:
        DD 3F733334H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_37800000:
        DD 37800000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_bf800000:
        DD 0BF800000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3e0f5c2a:
        DD 3E0F5C2AH

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_41200000:
        DD 41200000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_42d20001:
        DD 42D20001H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_41c80000:
        DD 41C80000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3f85e354:
        DD 3F85E354H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_c8:
        DD 200

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_f:
        DD 15

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_83:
        DD 131

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_1:
        DD 1

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_ffff0000:
        DD -65536

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_10000:
        DD 65536

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_5:
        DD 5

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_30800000:
        DD 30800000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_40000000:
        DD 40000000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_c0000000:
        DD 0C0000000H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_42653333:
        DD 42653333H

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_3f800000:
        DD 3F800000H

        END
// 3034 
// 3035 
// 3036 
// 3037 
// 3038 
// 3039 
// 3040 
// 3041 
// 3042 
// 3043 
// 3044 
// 3045 
// 3046 
// 3047 
// 3048 
// 3049 
// 3050 
// 3051 
// 3052 
// 3053 
// 3054 
// 3055 
// 
// 13 618 bytes in segment BANKED_CODE
//    312 bytes in segment BANK_RELAYS
//     44 bytes in segment XDATA_I
//     44 bytes in segment XDATA_ID
//    366 bytes in segment XDATA_ROM_C
// 
// 13 974 bytes of CODE  memory
//    234 bytes of CONST memory (+ 132 bytes shared)
//     44 bytes of XDATA memory
//
//Errors: none
//Warnings: none
